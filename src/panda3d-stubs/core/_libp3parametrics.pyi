from array import array
from collections.abc import Sequence
from os import PathLike
from typing import Any, ClassVar, Literal, TypeAlias, overload
from panda3d.core import (
    ConfigVariableColor,
    ConfigVariableFilename,
    Filename,
    LMatrix3f,
    LMatrix4f,
    LPoint3f,
    LVecBase3f,
    LVecBase4f,
    LVector3f,
    NodePath,
    PandaNode,
    ReferenceCount,
    TypeHandle,
    UnalignedLMatrix4f,
    UnalignedLVecBase4f,
    ostream,
)

_Vec3f: TypeAlias = LVecBase3f | LMatrix3f.Row | LMatrix3f.CRow
_Filename: TypeAlias = Filename | ConfigVariableFilename | str | bytes | PathLike
_CoordinateSystem: TypeAlias = Literal[0, 1, 2, 3, 4, 5]
_Mat4f: TypeAlias = LMatrix4f | UnalignedLMatrix4f
_Vec4f: TypeAlias = LVecBase4f | UnalignedLVecBase4f | LMatrix4f.Row | LMatrix4f.CRow | ConfigVariableColor
_RopeNode_RenderMode: TypeAlias = Literal[0, 1, 2, 3]
_RopeNode_UVMode: TypeAlias = Literal[0, 1, 2, 3]
_RopeNode_NormalMode: TypeAlias = Literal[0, 1]

class ParametricCurve(PandaNode):
    """A virtual base class for parametric curves.  This encapsulates all curves
    in 3-d space defined for a single parameter t in the range [0,get_max_t()].
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def is_valid(self) -> bool: ...
    def get_max_t(self) -> float: ...
    def set_curve_type(self, type: int) -> None: ...
    def get_curve_type(self) -> int: ...
    def set_num_dimensions(self, num: int) -> None: ...
    def get_num_dimensions(self) -> int: ...
    @overload
    def calc_length(self) -> float: ...
    @overload
    def calc_length(self, _from: float, to: float) -> float: ...
    def find_length(self, start_t: float, length_offset: float) -> float: ...
    def get_point(self, t: float, point: _Vec3f) -> bool: ...
    def get_tangent(self, t: float, tangent: _Vec3f) -> bool: ...
    def get_pt(self, t: float, point: _Vec3f, tangent: _Vec3f) -> bool: ...
    def get_2ndtangent(self, t: float, tangent2: _Vec3f) -> bool: ...
    def adjust_point(self, t: float, px: float, py: float, pz: float) -> bool: ...
    def adjust_tangent(self, t: float, tx: float, ty: float, tz: float) -> bool: ...
    def adjust_pt(self, t: float, px: float, py: float, pz: float, tx: float, ty: float, tz: float) -> bool: ...
    def recompute(self) -> bool: ...
    def stitch(self, a: ParametricCurve, b: ParametricCurve) -> bool: ...
    @overload
    def write_egg(self, filename: _Filename, cs: _CoordinateSystem = ...) -> bool: ...
    @overload
    def write_egg(self, out: ostream, filename: _Filename, cs: _CoordinateSystem) -> bool: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    isValid = is_valid
    getMaxT = get_max_t
    setCurveType = set_curve_type
    getCurveType = get_curve_type
    setNumDimensions = set_num_dimensions
    getNumDimensions = get_num_dimensions
    calcLength = calc_length
    findLength = find_length
    getPoint = get_point
    getTangent = get_tangent
    getPt = get_pt
    get2ndtangent = get_2ndtangent
    adjustPoint = adjust_point
    adjustTangent = adjust_tangent
    adjustPt = adjust_pt
    writeEgg = write_egg
    getClassType = get_class_type

class CubicCurveseg(ParametricCurve):
    """A CubicCurveseg is any curve that can be completely described by four
    4-valued basis vectors, one for each dimension in three-space, and one for
    the homogeneous coordinate.  This includes Beziers, Hermites, and NURBS.
    
    This class encapsulates a single curve segment of the cubic curve.
    Normally, when we think of Bezier and Hermite curves, we think of a
    piecewise collection of such segments.
    
    Although this class includes methods such as hermite_basis() and
    nurbs_basis(), to generate a Hermite and NURBS curve segment, respectively,
    only the final basis vectors are stored: the product of the basis matrix of
    the corresponding curve type, and its geometry vectors.  This is the
    minimum information needed to evaluate the curve.  However, the individual
    CV's that were used to compute these basis vectors are not retained; this
    might be handled in a subclass (for instance, HermiteCurve).
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getClassType = get_class_type

class ParametricCurveCollection(ReferenceCount):
    """This is a set of zero or more ParametricCurves, which may or may not be
    related.  If they are related, the set should contain no more than one XYZ
    curve, no more than one HPR curve, and zero or more Timewarp curves, which
    can then be evaluated as a unit to return a single transformation matrix
    for a given unit of time.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    curves: Sequence[ParametricCurve]
    @property
    def xyz_curve(self) -> ParametricCurve: ...
    @property
    def hpr_curve(self) -> ParametricCurve: ...
    @property
    def default_curve(self) -> ParametricCurve: ...
    @property
    def timewarp_curves(self) -> Sequence[ParametricCurve]: ...
    @property
    def max_t(self) -> float: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, __param0: ParametricCurveCollection) -> None: ...
    @overload
    def add_curve(self, curve: ParametricCurve) -> None: ...
    @overload
    def add_curve(self, curve: ParametricCurve, index: int) -> None: ...
    def insert_curve(self, index: int, curve: ParametricCurve) -> None: ...
    def add_curves(self, node: PandaNode) -> int: ...
    @overload
    def remove_curve(self, curve: ParametricCurve) -> bool: ...
    @overload
    def remove_curve(self, index: int) -> None: ...
    def set_curve(self, index: int, curve: ParametricCurve) -> None: ...
    def has_curve(self, curve: ParametricCurve) -> bool: ...
    def clear(self) -> None: ...
    def clear_timewarps(self) -> None: ...
    def get_num_curves(self) -> int: ...
    def get_curve(self, index: int) -> ParametricCurve: ...
    def get_xyz_curve(self) -> ParametricCurve: ...
    def get_hpr_curve(self) -> ParametricCurve: ...
    def get_default_curve(self) -> ParametricCurve: ...
    def get_num_timewarps(self) -> int: ...
    def get_timewarp_curve(self, n: int) -> ParametricCurve: ...
    def get_max_t(self) -> float: ...
    def make_even(self, max_t: float, segments_per_unit: float) -> None: ...
    def face_forward(self, segments_per_unit: float) -> None: ...
    def reset_max_t(self, max_t: float) -> None: ...
    @overload
    def evaluate(self, t: float, result: _Mat4f, cs: _CoordinateSystem = ...) -> bool: ...
    @overload
    def evaluate(self, t: float, xyz: _Vec3f, hpr: _Vec3f) -> bool: ...
    def evaluate_t(self, t: float) -> float: ...
    def evaluate_xyz(self, t: float, xyz: _Vec3f) -> bool: ...
    def evaluate_hpr(self, t: float, hpr: _Vec3f) -> bool: ...
    @overload
    def adjust_xyz(self, t: float, xyz: _Vec3f) -> bool: ...
    @overload
    def adjust_xyz(self, t: float, x: float, y: float, z: float) -> bool: ...
    @overload
    def adjust_hpr(self, t: float, xyz: _Vec3f) -> bool: ...
    @overload
    def adjust_hpr(self, t: float, h: float, p: float, r: float) -> bool: ...
    def recompute(self) -> bool: ...
    def stitch(self, a: ParametricCurveCollection, b: ParametricCurveCollection) -> bool: ...
    def output(self, out: ostream) -> None: ...
    def write(self, out: ostream, indent_level: int = ...) -> None: ...
    @overload
    def write_egg(self, filename: _Filename, cs: _CoordinateSystem = ...) -> bool: ...
    @overload
    def write_egg(self, out: ostream, filename: _Filename, cs: _CoordinateSystem) -> bool: ...
    def get_curves(self) -> tuple[ParametricCurve, ...]: ...
    def get_timewarp_curves(self) -> tuple[ParametricCurve, ...]: ...
    addCurve = add_curve
    insertCurve = insert_curve
    addCurves = add_curves
    removeCurve = remove_curve
    setCurve = set_curve
    hasCurve = has_curve
    clearTimewarps = clear_timewarps
    getNumCurves = get_num_curves
    getCurve = get_curve
    getXyzCurve = get_xyz_curve
    getHprCurve = get_hpr_curve
    getDefaultCurve = get_default_curve
    getNumTimewarps = get_num_timewarps
    getTimewarpCurve = get_timewarp_curve
    getMaxT = get_max_t
    makeEven = make_even
    faceForward = face_forward
    resetMaxT = reset_max_t
    evaluateT = evaluate_t
    evaluateXyz = evaluate_xyz
    evaluateHpr = evaluate_hpr
    adjustXyz = adjust_xyz
    adjustHpr = adjust_hpr
    writeEgg = write_egg
    getCurves = get_curves
    getTimewarpCurves = get_timewarp_curves

class CurveFitter:
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, __param0: CurveFitter) -> None: ...
    def reset(self) -> None: ...
    def add_xyz(self, t: float, xyz: _Vec3f) -> None: ...
    def add_hpr(self, t: float, hpr: _Vec3f) -> None: ...
    def add_xyz_hpr(self, t: float, xyz: _Vec3f, hpr: _Vec3f) -> None: ...
    def get_num_samples(self) -> int: ...
    def get_sample_t(self, n: int) -> float: ...
    def get_sample_xyz(self, n: int) -> LVecBase3f: ...
    def get_sample_hpr(self, n: int) -> LVecBase3f: ...
    def get_sample_tangent(self, n: int) -> LVecBase3f: ...
    def remove_samples(self, begin: int, end: int) -> None: ...
    def sample(self, curves: ParametricCurveCollection, count: int) -> None: ...
    def wrap_hpr(self) -> None: ...
    def sort_points(self) -> None: ...
    def desample(self, factor: float) -> None: ...
    def compute_tangents(self, scale: float) -> None: ...
    def make_hermite(self) -> ParametricCurveCollection: ...
    def make_nurbs(self) -> ParametricCurveCollection: ...
    def output(self, out: ostream) -> None: ...
    def write(self, out: ostream) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    addXyz = add_xyz
    addHpr = add_hpr
    addXyzHpr = add_xyz_hpr
    getNumSamples = get_num_samples
    getSampleT = get_sample_t
    getSampleXyz = get_sample_xyz
    getSampleHpr = get_sample_hpr
    getSampleTangent = get_sample_tangent
    removeSamples = remove_samples
    wrapHpr = wrap_hpr
    sortPoints = sort_points
    computeTangents = compute_tangents
    makeHermite = make_hermite
    makeNurbs = make_nurbs
    getClassType = get_class_type

class PiecewiseCurve(ParametricCurve):
    """A PiecewiseCurve is a curve made up of several curve segments, connected in
    a head-to-tail fashion.  The length of each curve segment in parametric
    space is definable.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getClassType = get_class_type

class HermiteCurve(PiecewiseCurve):
    """A parametric curve defined by a sequence of control vertices, each with an
    in and out tangent.
    
    This class is actually implemented as a PiecewiseCurve made up of several
    CubicCurvesegs, each of which is created using the hermite_basis() method.
    The HermiteCurve class itself keeps its own list of the CV's that are used
    to define the curve (since the CubicCurveseg class doesn't retain these).
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, pc: ParametricCurve) -> None: ...
    def get_num_cvs(self) -> int: ...
    def insert_cv(self, t: float) -> int: ...
    @overload
    def append_cv(self, type: int, v: _Vec3f) -> int: ...
    @overload
    def append_cv(self, type: int, x: float, y: float, z: float) -> int: ...
    def remove_cv(self, n: int) -> bool: ...
    def remove_all_cvs(self) -> None: ...
    def set_cv_type(self, n: int, type: int) -> bool: ...
    @overload
    def set_cv_point(self, n: int, v: _Vec3f) -> bool: ...
    @overload
    def set_cv_point(self, n: int, x: float, y: float, z: float) -> bool: ...
    @overload
    def set_cv_in(self, n: int, v: _Vec3f) -> bool: ...
    @overload
    def set_cv_in(self, n: int, x: float, y: float, z: float) -> bool: ...
    @overload
    def set_cv_out(self, n: int, v: _Vec3f) -> bool: ...
    @overload
    def set_cv_out(self, n: int, x: float, y: float, z: float) -> bool: ...
    def set_cv_tstart(self, n: int, tstart: float) -> bool: ...
    def set_cv_name(self, n: int, name: str) -> bool: ...
    def get_cv_type(self, n: int) -> int: ...
    @overload
    def get_cv_point(self, n: int) -> LVecBase3f: ...
    @overload
    def get_cv_point(self, n: int, v: _Vec3f) -> None: ...
    @overload
    def get_cv_in(self, n: int) -> LVecBase3f: ...
    @overload
    def get_cv_in(self, n: int, v: _Vec3f) -> None: ...
    @overload
    def get_cv_out(self, n: int) -> LVecBase3f: ...
    @overload
    def get_cv_out(self, n: int, v: _Vec3f) -> None: ...
    def get_cv_tstart(self, n: int) -> float: ...
    def get_cv_name(self, n: int) -> str: ...
    def write_cv(self, out: ostream, n: int) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getNumCvs = get_num_cvs
    insertCv = insert_cv
    appendCv = append_cv
    removeCv = remove_cv
    removeAllCvs = remove_all_cvs
    setCvType = set_cv_type
    setCvPoint = set_cv_point
    setCvIn = set_cv_in
    setCvOut = set_cv_out
    setCvTstart = set_cv_tstart
    setCvName = set_cv_name
    getCvType = get_cv_type
    getCvPoint = get_cv_point
    getCvIn = get_cv_in
    getCvOut = get_cv_out
    getCvTstart = get_cv_tstart
    getCvName = get_cv_name
    writeCv = write_cv
    getClassType = get_class_type

class NurbsCurveInterface:
    """This abstract class defines the interface only for a Nurbs-style curve,
    with knots and coordinates in homogeneous space.
    
    The NurbsCurve class inherits both from this and from ParametricCurve.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def set_order(self, order: int) -> None: ...
    def get_order(self) -> int: ...
    def get_num_cvs(self) -> int: ...
    def get_num_knots(self) -> int: ...
    def insert_cv(self, t: float) -> bool: ...
    @overload
    def append_cv(self, v: _Vec3f | _Vec4f) -> int: ...
    @overload
    def append_cv(self, x: float, y: float, z: float) -> int: ...
    def remove_cv(self, n: int) -> bool: ...
    def remove_all_cvs(self) -> None: ...
    @overload
    def set_cv_point(self, n: int, v: _Vec3f) -> bool: ...
    @overload
    def set_cv_point(self, n: int, x: float, y: float, z: float) -> bool: ...
    def get_cv_point(self, n: int) -> LVecBase3f: ...
    def set_cv_weight(self, n: int, w: float) -> bool: ...
    def get_cv_weight(self, n: int) -> float: ...
    def set_cv(self, n: int, v: _Vec4f) -> bool: ...
    def get_cv(self, n: int) -> LVecBase4f: ...
    def set_knot(self, n: int, t: float) -> bool: ...
    def get_knot(self, n: int) -> float: ...
    def write_cv(self, out: ostream, n: int) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    def get_cvs(self) -> tuple[LVecBase4f, ...]: ...
    def get_knots(self) -> tuple[float, ...]: ...
    setOrder = set_order
    getOrder = get_order
    getNumCvs = get_num_cvs
    getNumKnots = get_num_knots
    insertCv = insert_cv
    appendCv = append_cv
    removeCv = remove_cv
    removeAllCvs = remove_all_cvs
    setCvPoint = set_cv_point
    getCvPoint = get_cv_point
    setCvWeight = set_cv_weight
    getCvWeight = get_cv_weight
    setCv = set_cv
    getCv = get_cv
    setKnot = set_knot
    getKnot = get_knot
    writeCv = write_cv
    getClassType = get_class_type
    getCvs = get_cvs
    getKnots = get_knots

class NurbsCurve(PiecewiseCurve, NurbsCurveInterface):
    """A Nonuniform Rational B-Spline.
    
    This class is actually implemented as a PiecewiseCurve made up of several
    CubicCurvesegs, each of which is created using the nurbs_basis() method.
    The list of CV's and knots is kept here, within the NurbsCurve class.
    
    This class is the original Panda-native implementation of a NURBS curve.
    It is typedeffed as "NurbsCurve" and performs all NURBS curve functions if
    we do not have the NURBS++ library available.
    
    However, if we *do* have the NURBS++ library, another class exists, the
    NurbsPPCurve, which is a wrapper around that library and provides some
    additional functionality.  In that case, the other class is typedeffed to
    "NurbsCurve" instead of this one, and performs most of the NURBS curve
    functions.  This class then becomes vestigial.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, pc: ParametricCurve) -> None: ...
    def upcast_to_PiecewiseCurve(self) -> PiecewiseCurve: ...
    def upcast_to_NurbsCurveInterface(self) -> NurbsCurveInterface: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    upcastToPiecewiseCurve = upcast_to_PiecewiseCurve
    upcastToNurbsCurveInterface = upcast_to_NurbsCurveInterface
    getClassType = get_class_type

class NurbsCurveResult(ReferenceCount):
    """The result of a NurbsCurveEvaluator.  This object represents a curve in a
    particular coordinate space.  It can return the point and/or tangent to the
    curve at any point.
    
    This is not related to NurbsCurve, CubicCurveseg or any of the
    ParametricCurve-derived objects in this module.  It is a completely
    parallel implementation of NURBS curves, and will probably eventually
    replace the whole ParametricCurve class hierarchy.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, __param0: NurbsCurveResult) -> None: ...
    def get_start_t(self) -> float: ...
    def get_end_t(self) -> float: ...
    def eval_point(self, t: float, point: _Vec3f) -> bool: ...
    def eval_tangent(self, t: float, tangent: _Vec3f) -> bool: ...
    def eval_extended_point(self, t: float, d: int) -> float: ...
    def eval_extended_points(self, t: float, d: int, result: array[float], num_values: int) -> bool: ...
    def get_num_segments(self) -> int: ...
    def eval_segment_point(self, segment: int, t: float, point: _Vec3f) -> None: ...
    def eval_segment_tangent(self, segment: int, t: float, tangent: _Vec3f) -> None: ...
    def eval_segment_extended_point(self, segment: int, t: float, d: int) -> float: ...
    def eval_segment_extended_points(self, segment: int, t: float, d: int, result: array[float], num_values: int) -> None: ...
    def get_segment_t(self, segment: int, t: float) -> float: ...
    def adaptive_sample(self, tolerance: float) -> None: ...
    def get_num_samples(self) -> int: ...
    def get_sample_t(self, n: int) -> float: ...
    def get_sample_point(self, n: int) -> LPoint3f: ...
    def get_sample_ts(self) -> tuple[float, ...]: ...
    def get_sample_points(self) -> tuple[LPoint3f, ...]: ...
    getStartT = get_start_t
    getEndT = get_end_t
    evalPoint = eval_point
    evalTangent = eval_tangent
    evalExtendedPoint = eval_extended_point
    evalExtendedPoints = eval_extended_points
    getNumSegments = get_num_segments
    evalSegmentPoint = eval_segment_point
    evalSegmentTangent = eval_segment_tangent
    evalSegmentExtendedPoint = eval_segment_extended_point
    evalSegmentExtendedPoints = eval_segment_extended_points
    getSegmentT = get_segment_t
    adaptiveSample = adaptive_sample
    getNumSamples = get_num_samples
    getSampleT = get_sample_t
    getSamplePoint = get_sample_point
    getSampleTs = get_sample_ts
    getSamplePoints = get_sample_points

class NurbsCurveEvaluator(ReferenceCount):
    """This class is an abstraction for evaluating NURBS curves.  It accepts an
    array of vertices, each of which may be in a different coordinate space (as
    defined by a NodePath), as well as an optional knot vector.
    
    This is not related to NurbsCurve, CubicCurveseg or any of the
    ParametricCurve-derived objects in this module.  It is a completely
    parallel implementation of NURBS curves, and will probably eventually
    replace the whole ParametricCurve class hierarchy.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, __param0: NurbsCurveEvaluator) -> None: ...
    def set_order(self, order: int) -> None: ...
    def get_order(self) -> int: ...
    def reset(self, num_vertices: int) -> None: ...
    def get_num_vertices(self) -> int: ...
    @overload
    def set_vertex(self, i: int, vertex: _Vec4f) -> None: ...
    @overload
    def set_vertex(self, i: int, vertex: _Vec3f, weight: float = ...) -> None: ...
    @overload
    def get_vertex(self, i: int) -> LVecBase4f: ...
    @overload
    def get_vertex(self, i: int, rel_to: NodePath) -> LVecBase4f: ...
    def set_vertex_space(self, i: int, space: NodePath | str) -> None: ...
    def get_vertex_space(self, i: int, rel_to: NodePath) -> NodePath: ...
    def set_extended_vertex(self, i: int, d: int, value: float) -> None: ...
    def get_extended_vertex(self, i: int, d: int) -> float: ...
    def set_extended_vertices(self, i: int, d: int, values: array[float], num_values: int) -> None: ...
    def get_num_knots(self) -> int: ...
    def set_knot(self, i: int, knot: float) -> None: ...
    def get_knot(self, i: int) -> float: ...
    def normalize_knots(self) -> None: ...
    def get_num_segments(self) -> int: ...
    @overload
    def evaluate(self, rel_to: NodePath = ...) -> NurbsCurveResult: ...
    @overload
    def evaluate(self, rel_to: NodePath, mat: _Mat4f) -> NurbsCurveResult: ...
    def output(self, out: ostream) -> None: ...
    def get_vertices(self) -> tuple[LVecBase4f, ...]: ...
    def get_knots(self) -> tuple[float, ...]: ...
    setOrder = set_order
    getOrder = get_order
    getNumVertices = get_num_vertices
    setVertex = set_vertex
    getVertex = get_vertex
    setVertexSpace = set_vertex_space
    getVertexSpace = get_vertex_space
    setExtendedVertex = set_extended_vertex
    getExtendedVertex = get_extended_vertex
    setExtendedVertices = set_extended_vertices
    getNumKnots = get_num_knots
    setKnot = set_knot
    getKnot = get_knot
    normalizeKnots = normalize_knots
    getNumSegments = get_num_segments
    getVertices = get_vertices
    getKnots = get_knots

class NurbsSurfaceResult(ReferenceCount):
    """The result of a NurbsSurfaceEvaluator.  This object represents a surface in
    a particular coordinate space.  It can return the point and/or normal to
    the surface at any point.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, __param0: NurbsSurfaceResult) -> None: ...
    def get_start_u(self) -> float: ...
    def get_end_u(self) -> float: ...
    def get_start_v(self) -> float: ...
    def get_end_v(self) -> float: ...
    def eval_point(self, u: float, v: float, point: _Vec3f) -> bool: ...
    def eval_normal(self, u: float, v: float, normal: _Vec3f) -> bool: ...
    def eval_extended_point(self, u: float, v: float, d: int) -> float: ...
    def eval_extended_points(self, u: float, v: float, d: int, result: array[float], num_values: int) -> bool: ...
    def get_num_u_segments(self) -> int: ...
    def get_num_v_segments(self) -> int: ...
    def eval_segment_point(self, ui: int, vi: int, u: float, v: float, point: _Vec3f) -> None: ...
    def eval_segment_normal(self, ui: int, vi: int, u: float, v: float, normal: _Vec3f) -> None: ...
    def eval_segment_extended_point(self, ui: int, vi: int, u: float, v: float, d: int) -> float: ...
    def eval_segment_extended_points(self, ui: int, vi: int, u: float, v: float, d: int, result: array[float], num_values: int) -> None: ...
    def get_segment_u(self, ui: int, u: float) -> float: ...
    def get_segment_v(self, vi: int, v: float) -> float: ...
    getStartU = get_start_u
    getEndU = get_end_u
    getStartV = get_start_v
    getEndV = get_end_v
    evalPoint = eval_point
    evalNormal = eval_normal
    evalExtendedPoint = eval_extended_point
    evalExtendedPoints = eval_extended_points
    getNumUSegments = get_num_u_segments
    getNumVSegments = get_num_v_segments
    evalSegmentPoint = eval_segment_point
    evalSegmentNormal = eval_segment_normal
    evalSegmentExtendedPoint = eval_segment_extended_point
    evalSegmentExtendedPoints = eval_segment_extended_points
    getSegmentU = get_segment_u
    getSegmentV = get_segment_v

class NurbsSurfaceEvaluator(ReferenceCount):
    """This class is an abstraction for evaluating NURBS surfaces.  It accepts an
    array of vertices, each of which may be in a different coordinate space (as
    defined by a NodePath), as well as an optional knot vector.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    u_order: int
    v_order: int
    u_knots: Sequence[float]
    v_knots: Sequence[float]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, __param0: NurbsSurfaceEvaluator) -> None: ...
    def set_u_order(self, u_order: int) -> None: ...
    def get_u_order(self) -> int: ...
    def set_v_order(self, v_order: int) -> None: ...
    def get_v_order(self) -> int: ...
    def reset(self, num_u_vertices: int, num_v_vertices: int) -> None: ...
    def get_num_u_vertices(self) -> int: ...
    def get_num_v_vertices(self) -> int: ...
    @overload
    def set_vertex(self, ui: int, vi: int, vertex: _Vec4f) -> None: ...
    @overload
    def set_vertex(self, ui: int, vi: int, vertex: _Vec3f, weight: float = ...) -> None: ...
    @overload
    def get_vertex(self, ui: int, vi: int) -> LVecBase4f: ...
    @overload
    def get_vertex(self, ui: int, vi: int, rel_to: NodePath) -> LVecBase4f: ...
    def set_vertex_space(self, ui: int, vi: int, space: NodePath | str) -> None: ...
    def get_vertex_space(self, ui: int, vi: int, rel_to: NodePath) -> NodePath: ...
    def set_extended_vertex(self, ui: int, vi: int, d: int, value: float) -> None: ...
    def get_extended_vertex(self, ui: int, vi: int, d: int) -> float: ...
    def set_extended_vertices(self, ui: int, vi: int, d: int, values: array[float], num_values: int) -> None: ...
    def get_num_u_knots(self) -> int: ...
    def set_u_knot(self, i: int, knot: float) -> None: ...
    def get_u_knot(self, i: int) -> float: ...
    def normalize_u_knots(self) -> None: ...
    def get_num_v_knots(self) -> int: ...
    def set_v_knot(self, i: int, knot: float) -> None: ...
    def get_v_knot(self, i: int) -> float: ...
    def normalize_v_knots(self) -> None: ...
    def get_num_u_segments(self) -> int: ...
    def get_num_v_segments(self) -> int: ...
    def evaluate(self, rel_to: NodePath = ...) -> NurbsSurfaceResult: ...
    def output(self, out: ostream) -> None: ...
    def get_u_knots(self) -> tuple[float, ...]: ...
    def get_v_knots(self) -> tuple[float, ...]: ...
    setUOrder = set_u_order
    getUOrder = get_u_order
    setVOrder = set_v_order
    getVOrder = get_v_order
    getNumUVertices = get_num_u_vertices
    getNumVVertices = get_num_v_vertices
    setVertex = set_vertex
    getVertex = get_vertex
    setVertexSpace = set_vertex_space
    getVertexSpace = get_vertex_space
    setExtendedVertex = set_extended_vertex
    getExtendedVertex = get_extended_vertex
    setExtendedVertices = set_extended_vertices
    getNumUKnots = get_num_u_knots
    setUKnot = set_u_knot
    getUKnot = get_u_knot
    normalizeUKnots = normalize_u_knots
    getNumVKnots = get_num_v_knots
    setVKnot = set_v_knot
    getVKnot = get_v_knot
    normalizeVKnots = normalize_v_knots
    getNumUSegments = get_num_u_segments
    getNumVSegments = get_num_v_segments
    getUKnots = get_u_knots
    getVKnots = get_v_knots

class RopeNode(PandaNode):
    """This class draws a visible representation of the NURBS curve stored in its
    NurbsCurveEvaluator.  It automatically recomputes the curve every frame.
    
    This is not related to NurbsCurve, CubicCurveseg or any of the
    ParametricCurve-derived objects in this module.  It is a completely
    parallel implementation of NURBS curves, and will probably eventually
    replace the whole ParametricCurve class hierarchy.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    curve: NurbsCurveEvaluator
    render_mode: _RopeNode_RenderMode
    uv_mode: _RopeNode_UVMode
    uv_direction: bool
    uv_scale: float
    normal_mode: _RopeNode_NormalMode
    tube_up: LVector3f
    use_vertex_color: bool
    num_subdiv: int
    num_slices: int
    use_vertex_thickness: bool
    thickness: float
    matrix: LMatrix4f
    RM_thread: ClassVar[Literal[0]]
    RM_tape: ClassVar[Literal[1]]
    RM_billboard: ClassVar[Literal[2]]
    RM_tube: ClassVar[Literal[3]]
    UV_none: ClassVar[Literal[0]]
    UV_parametric: ClassVar[Literal[1]]
    UV_distance: ClassVar[Literal[2]]
    UV_distance2: ClassVar[Literal[3]]
    NM_none: ClassVar[Literal[0]]
    NM_vertex: ClassVar[Literal[1]]
    @property
    def vertex_color_dimension(self) -> int: ...
    @property
    def vertex_thickness_dimension(self) -> int: ...
    def __init__(self, name: str) -> None: ...
    def set_curve(self, curve: NurbsCurveEvaluator) -> None: ...
    def get_curve(self) -> NurbsCurveEvaluator: ...
    def set_render_mode(self, render_mode: _RopeNode_RenderMode) -> None: ...
    def get_render_mode(self) -> _RopeNode_RenderMode: ...
    def set_uv_mode(self, uv_mode: _RopeNode_UVMode) -> None: ...
    def get_uv_mode(self) -> _RopeNode_UVMode: ...
    def set_uv_direction(self, u_dominant: bool) -> None: ...
    def get_uv_direction(self) -> bool: ...
    def set_uv_scale(self, scale: float) -> None: ...
    def get_uv_scale(self) -> float: ...
    def set_normal_mode(self, normal_mode: _RopeNode_NormalMode) -> None: ...
    def get_normal_mode(self) -> _RopeNode_NormalMode: ...
    def set_tube_up(self, tube_up: _Vec3f) -> None: ...
    def get_tube_up(self) -> LVector3f: ...
    def set_use_vertex_color(self, flag: bool) -> None: ...
    def get_use_vertex_color(self) -> bool: ...
    @staticmethod
    def get_vertex_color_dimension() -> int: ...
    def set_num_subdiv(self, num_subdiv: int) -> None: ...
    def get_num_subdiv(self) -> int: ...
    def set_num_slices(self, num_slices: int) -> None: ...
    def get_num_slices(self) -> int: ...
    def set_use_vertex_thickness(self, flag: bool) -> None: ...
    def get_use_vertex_thickness(self) -> bool: ...
    @staticmethod
    def get_vertex_thickness_dimension() -> int: ...
    def set_thickness(self, thickness: float) -> None: ...
    def get_thickness(self) -> float: ...
    def set_matrix(self, matrix: _Mat4f) -> None: ...
    def clear_matrix(self) -> None: ...
    def has_matrix(self) -> bool: ...
    def get_matrix(self) -> LMatrix4f: ...
    def reset_bound(self, rel_to: NodePath) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    setCurve = set_curve
    getCurve = get_curve
    setRenderMode = set_render_mode
    getRenderMode = get_render_mode
    setUvMode = set_uv_mode
    getUvMode = get_uv_mode
    setUvDirection = set_uv_direction
    getUvDirection = get_uv_direction
    setUvScale = set_uv_scale
    getUvScale = get_uv_scale
    setNormalMode = set_normal_mode
    getNormalMode = get_normal_mode
    setTubeUp = set_tube_up
    getTubeUp = get_tube_up
    setUseVertexColor = set_use_vertex_color
    getUseVertexColor = get_use_vertex_color
    getVertexColorDimension = get_vertex_color_dimension
    setNumSubdiv = set_num_subdiv
    getNumSubdiv = get_num_subdiv
    setNumSlices = set_num_slices
    getNumSlices = get_num_slices
    setUseVertexThickness = set_use_vertex_thickness
    getUseVertexThickness = get_use_vertex_thickness
    getVertexThicknessDimension = get_vertex_thickness_dimension
    setThickness = set_thickness
    getThickness = get_thickness
    setMatrix = set_matrix
    clearMatrix = clear_matrix
    hasMatrix = has_matrix
    getMatrix = get_matrix
    resetBound = reset_bound
    getClassType = get_class_type
    RMThread = RM_thread
    RMTape = RM_tape
    RMBillboard = RM_billboard
    RMTube = RM_tube
    UVNone = UV_none
    UVParametric = UV_parametric
    UVDistance = UV_distance
    UVDistance2 = UV_distance2
    NMNone = NM_none
    NMVertex = NM_vertex

class SheetNode(PandaNode):
    """This class draws a visible representation of the NURBS surface stored in
    its NurbsSurfaceEvaluator.  It automatically recomputes the surface every
    frame.
    
    This is not related to NurbsSurface, CubicSurfaceseg or any of the
    ParametricSurface-derived objects in this module.  It is a completely
    parallel implementation of NURBS surfaces, and will probably eventually
    replace the whole ParametricSurface class hierarchy.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, name: str) -> None: ...
    def set_surface(self, surface: NurbsSurfaceEvaluator) -> None: ...
    def get_surface(self) -> NurbsSurfaceEvaluator: ...
    def set_use_vertex_color(self, flag: bool) -> None: ...
    def get_use_vertex_color(self) -> bool: ...
    def set_num_u_subdiv(self, num_u_subdiv: int) -> None: ...
    def get_num_u_subdiv(self) -> int: ...
    def set_num_v_subdiv(self, num_v_subdiv: int) -> None: ...
    def get_num_v_subdiv(self) -> int: ...
    def reset_bound(self, rel_to: NodePath) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    setSurface = set_surface
    getSurface = get_surface
    setUseVertexColor = set_use_vertex_color
    getUseVertexColor = get_use_vertex_color
    setNumUSubdiv = set_num_u_subdiv
    getNumUSubdiv = get_num_u_subdiv
    setNumVSubdiv = set_num_v_subdiv
    getNumVSubdiv = get_num_v_subdiv
    resetBound = reset_bound
    getClassType = get_class_type
