from collections.abc import Sequence
from typing import Any, ClassVar, Literal, TypeAlias, overload
from panda3d.core import (
    AnimInterface,
    CallbackData,
    CallbackObject,
    Camera,
    ConfigVariableColor,
    CullTraverser,
    CullTraverserData,
    GeomVertexAnimationSpec,
    GraphicsOutputBase,
    GraphicsStateGuardianBase,
    LMatrix3f,
    LMatrix4f,
    LPoint3f,
    LVecBase2i,
    LVecBase3f,
    LVecBase3i,
    LVecBase4f,
    LVector3f,
    Light,
    PandaNode,
    RenderState,
    ShaderAttrib,
    Texture,
    TypeHandle,
    TypedReferenceCount,
    UnalignedLVecBase4f,
    ostream,
)

_Vec4f: TypeAlias = LVecBase4f | UnalignedLVecBase4f | LMatrix4f.Row | LMatrix4f.CRow | ConfigVariableColor
_Vec3f: TypeAlias = LVecBase3f | LMatrix3f.Row | LMatrix3f.CRow
_SceneGraphAnalyzer_LodMode: TypeAlias = Literal[0, 1, 2, 3]

class LightNode(Light, PandaNode):
    """A derivative of Light and of PandaNode.  All kinds of Light except
    Spotlight (which must inherit from LensNode instead) inherit from this
    class.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def upcast_to_Light(self) -> Light: ...
    def upcast_to_PandaNode(self) -> PandaNode: ...
    def output(self, out: ostream) -> None: ...
    def write(self, out: ostream, indent_level: int = ...) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    upcastToLight = upcast_to_Light
    upcastToPandaNode = upcast_to_PandaNode
    getClassType = get_class_type

class AmbientLight(LightNode):
    """A light source that seems to illuminate all points in space at once.  This
    kind of light need not actually be part of the scene graph, since it has no
    meaningful position.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, name: str) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getClassType = get_class_type

class CallbackNode(PandaNode):
    """A special node that can issue arbitrary callbacks to user code, either
    during the cull or draw traversals.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    cull_callback: CallbackObject
    draw_callback: CallbackObject
    def __init__(self, name: str) -> None: ...
    def set_cull_callback(self, object: CallbackObject) -> None: ...
    def clear_cull_callback(self) -> None: ...
    def get_cull_callback(self) -> CallbackObject: ...
    def set_draw_callback(self, object: CallbackObject) -> None: ...
    def clear_draw_callback(self) -> None: ...
    def get_draw_callback(self) -> CallbackObject: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    setCullCallback = set_cull_callback
    clearCullCallback = clear_cull_callback
    getCullCallback = get_cull_callback
    setDrawCallback = set_draw_callback
    clearDrawCallback = clear_draw_callback
    getDrawCallback = get_draw_callback
    getClassType = get_class_type

class ComputeNode(PandaNode):
    """A special node, the sole purpose of which is to invoke a dispatch operation
    on the assigned compute shader.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    dispatches: Sequence[LVecBase3i]
    def __init__(self, name: str) -> None: ...
    @overload
    def add_dispatch(self, num_groups: LVecBase3i) -> None: ...
    @overload
    def add_dispatch(self, num_groups_x: int, num_groups_y: int, num_groups_z: int) -> None: ...
    def get_num_dispatches(self) -> int: ...
    def get_dispatch(self, i: int) -> LVecBase3i: ...
    def set_dispatch(self, i: int, num_groups: LVecBase3i) -> None: ...
    def insert_dispatch(self, i: int, num_groups: LVecBase3i) -> None: ...
    def remove_dispatch(self, i: int) -> None: ...
    def clear_dispatches(self) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    def get_dispatches(self) -> tuple[LVecBase3i, ...]: ...
    addDispatch = add_dispatch
    getNumDispatches = get_num_dispatches
    getDispatch = get_dispatch
    setDispatch = set_dispatch
    insertDispatch = insert_dispatch
    removeDispatch = remove_dispatch
    clearDispatches = clear_dispatches
    getClassType = get_class_type
    getDispatches = get_dispatches

class LightLensNode(Light, Camera):
    """A derivative of Light and of Camera.  The name might be misleading: it does
    not directly derive from LensNode, but through the Camera class.  The
    Camera serves no purpose unless shadows are enabled.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    shadow_buffer_size: LVecBase2i
    @property
    def shadow_caster(self) -> bool: ...
    def upcast_to_Light(self) -> Light: ...
    def upcast_to_Camera(self) -> Camera: ...
    def has_specular_color(self) -> bool: ...
    def is_shadow_caster(self) -> bool: ...
    @overload
    def set_shadow_caster(self, caster: bool) -> None: ...
    @overload
    def set_shadow_caster(self, caster: bool, buffer_xsize: int, buffer_ysize: int, sort: int = ...) -> None: ...
    def get_shadow_buffer_sort(self) -> int: ...
    def get_shadow_buffer_size(self) -> LVecBase2i: ...
    def set_shadow_buffer_size(self, size: LVecBase2i) -> None: ...
    def get_shadow_buffer(self, gsg: GraphicsStateGuardianBase) -> GraphicsOutputBase: ...
    def output(self, out: ostream) -> None: ...
    def write(self, out: ostream, indent_level: int = ...) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    upcastToLight = upcast_to_Light
    upcastToCamera = upcast_to_Camera
    hasSpecularColor = has_specular_color
    isShadowCaster = is_shadow_caster
    setShadowCaster = set_shadow_caster
    getShadowBufferSort = get_shadow_buffer_sort
    getShadowBufferSize = get_shadow_buffer_size
    setShadowBufferSize = set_shadow_buffer_size
    getShadowBuffer = get_shadow_buffer
    getClassType = get_class_type

class DirectionalLight(LightLensNode):
    """A light shining from infinitely far away in a particular direction, like
    sunlight.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    specular_color: LVecBase4f
    point: LPoint3f
    direction: LVector3f
    def __init__(self, name: str) -> None: ...
    def set_specular_color(self, color: _Vec4f) -> None: ...
    def clear_specular_color(self) -> None: ...
    def get_point(self) -> LPoint3f: ...
    def set_point(self, point: _Vec3f) -> None: ...
    def get_direction(self) -> LVector3f: ...
    def set_direction(self, direction: _Vec3f) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    setSpecularColor = set_specular_color
    clearSpecularColor = clear_specular_color
    getPoint = get_point
    setPoint = set_point
    getDirection = get_direction
    setDirection = set_direction
    getClassType = get_class_type

class LODNode(PandaNode):
    """A Level-of-Detail node.  This selects only one of its children for
    rendering, according to the distance from the camera and the table
    indicated in the associated LOD object.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    lod_scale: float
    center: LPoint3f
    @property
    def ins(self) -> Sequence[float]: ...
    @property
    def outs(self) -> Sequence[float]: ...
    @property
    def lowest_switch(self) -> int: ...
    @property
    def highest_switch(self) -> int: ...
    def __init__(self, name: str) -> None: ...
    @staticmethod
    def make_default_lod(name: str) -> LODNode: ...
    def add_switch(self, _in: float, out: float) -> None: ...
    def set_switch(self, index: int, _in: float, out: float) -> bool: ...
    def clear_switches(self) -> None: ...
    def get_num_switches(self) -> int: ...
    def get_in(self, index: int) -> float: ...
    def get_out(self, index: int) -> float: ...
    def get_lowest_switch(self) -> int: ...
    def get_highest_switch(self) -> int: ...
    def force_switch(self, index: int) -> None: ...
    def clear_force_switch(self) -> None: ...
    def set_lod_scale(self, value: float) -> None: ...
    def get_lod_scale(self) -> float: ...
    def set_center(self, center: _Vec3f) -> None: ...
    def get_center(self) -> LPoint3f: ...
    @overload
    def show_switch(self, index: int) -> None: ...
    @overload
    def show_switch(self, index: int, color: _Vec4f) -> None: ...
    def hide_switch(self, index: int) -> None: ...
    def show_all_switches(self) -> None: ...
    def hide_all_switches(self) -> None: ...
    def is_any_shown(self) -> bool: ...
    def verify_child_bounds(self) -> bool: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    def get_ins(self) -> tuple[float, ...]: ...
    def get_outs(self) -> tuple[float, ...]: ...
    makeDefaultLod = make_default_lod
    addSwitch = add_switch
    setSwitch = set_switch
    clearSwitches = clear_switches
    getNumSwitches = get_num_switches
    getIn = get_in
    getOut = get_out
    getLowestSwitch = get_lowest_switch
    getHighestSwitch = get_highest_switch
    forceSwitch = force_switch
    clearForceSwitch = clear_force_switch
    setLodScale = set_lod_scale
    getLodScale = get_lod_scale
    setCenter = set_center
    getCenter = get_center
    showSwitch = show_switch
    hideSwitch = hide_switch
    showAllSwitches = show_all_switches
    hideAllSwitches = hide_all_switches
    isAnyShown = is_any_shown
    verifyChildBounds = verify_child_bounds
    getClassType = get_class_type
    getIns = get_ins
    getOuts = get_outs

class FadeLODNode(LODNode):
    """A Level-of-Detail node with alpha based switching."""
    DtoolClassDict: ClassVar[dict[str, Any]]
    fade_time: float
    fade_state_override: int
    @property
    def fade_bin_name(self) -> str: ...
    @property
    def fade_bin_draw_order(self) -> int: ...
    def __init__(self, name: str) -> None: ...
    def set_fade_time(self, t: float) -> None: ...
    def get_fade_time(self) -> float: ...
    def set_fade_bin(self, name: str, draw_order: int) -> None: ...
    def get_fade_bin_name(self) -> str: ...
    def get_fade_bin_draw_order(self) -> int: ...
    def set_fade_state_override(self, override: int) -> None: ...
    def get_fade_state_override(self) -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    setFadeTime = set_fade_time
    getFadeTime = get_fade_time
    setFadeBin = set_fade_bin
    getFadeBinName = get_fade_bin_name
    getFadeBinDrawOrder = get_fade_bin_draw_order
    setFadeStateOverride = set_fade_state_override
    getFadeStateOverride = get_fade_state_override
    getClassType = get_class_type

class NodeCullCallbackData(CallbackData):
    """This kind of CallbackData is passed to the CallbackObject added to
    CallbackNode:set_cull_callback().
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def get_trav(self) -> CullTraverser: ...
    def get_data(self) -> CullTraverserData: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getTrav = get_trav
    getData = get_data
    getClassType = get_class_type

class PointLight(LightLensNode):
    """A light originating from a single point in space, and shining in all
    directions.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    specular_color: LVecBase4f
    attenuation: LVecBase3f
    max_distance: float
    point: LPoint3f
    def __init__(self, name: str) -> None: ...
    def set_specular_color(self, color: _Vec4f) -> None: ...
    def clear_specular_color(self) -> None: ...
    def set_attenuation(self, attenuation: _Vec3f) -> None: ...
    def get_max_distance(self) -> float: ...
    def set_max_distance(self, max_distance: float) -> None: ...
    def get_point(self) -> LPoint3f: ...
    def set_point(self, point: _Vec3f) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    setSpecularColor = set_specular_color
    clearSpecularColor = clear_specular_color
    setAttenuation = set_attenuation
    getMaxDistance = get_max_distance
    setMaxDistance = set_max_distance
    getPoint = get_point
    setPoint = set_point
    getClassType = get_class_type

class RectangleLight(LightLensNode):
    """This is a type of area light that is an axis aligned rectangle, pointing
    along the Y axis in the positive direction.
    
    @since 1.10.0
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    max_distance: float
    def __init__(self, name: str) -> None: ...
    def get_max_distance(self) -> float: ...
    def set_max_distance(self, max_distance: float) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getMaxDistance = get_max_distance
    setMaxDistance = set_max_distance
    getClassType = get_class_type

class SelectiveChildNode(PandaNode):
    """A base class for nodes like LODNode and SequenceNode that select only one
    visible child at a time.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, name: str) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getClassType = get_class_type

class SequenceNode(SelectiveChildNode, AnimInterface):
    """A node that automatically cycles through rendering each one of its children
    according to its frame rate.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    frame_rate: float
    def __init__(self, name: str) -> None: ...
    def upcast_to_SelectiveChildNode(self) -> SelectiveChildNode: ...
    def upcast_to_AnimInterface(self) -> AnimInterface: ...
    def get_num_frames(self) -> int: ...
    def set_frame_rate(self, frame_rate: float) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    upcastToSelectiveChildNode = upcast_to_SelectiveChildNode
    upcastToAnimInterface = upcast_to_AnimInterface
    getNumFrames = get_num_frames
    setFrameRate = set_frame_rate
    getClassType = get_class_type

class ShaderGenerator(TypedReferenceCount):
    """The ShaderGenerator is a device that effectively replaces the classic fixed
    function pipeline with a 'next-gen' fixed function pipeline.  The next-gen
    fixed function pipeline supports features like normal mapping, gloss
    mapping, cartoon lighting, and so forth.  It works by automatically
    generating a shader from a given RenderState.
    
    Currently, there is one ShaderGenerator object per GraphicsStateGuardian.
    It is our intent that in time, people will write classes that derive from
    ShaderGenerator but which yield slightly different results.
    
    The ShaderGenerator owes its existence to the 'Bamboo Team' at Carnegie
    Mellon's Entertainment Technology Center.  This is a group of students who,
    as a semester project, decided that next-gen graphics should be accessible
    to everyone, even if they don't know shader programming.  The group
    consisted of:
    
    Aaron Lo, Programmer Heegun Lee, Programmer Erin Fernandez, Artist/Tester
    Joe Grubb, Artist/Tester Ivan Ortega, Technical Artist/Tester
    
    Thanks to them!
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self, gsg: GraphicsStateGuardianBase) -> None: ...
    @overload
    def __init__(self, __param0: ShaderGenerator) -> None: ...
    def synthesize_shader(self, rs: RenderState, anim: GeomVertexAnimationSpec) -> ShaderAttrib: ...
    def rehash_generated_shaders(self) -> None: ...
    def clear_generated_shaders(self) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    synthesizeShader = synthesize_shader
    rehashGeneratedShaders = rehash_generated_shaders
    clearGeneratedShaders = clear_generated_shaders
    getClassType = get_class_type

class SphereLight(PointLight):
    """A sphere light is like a point light, except that it represents a sphere
    with a radius, rather than being an infinitely thin point in space.
    
    @since 1.10.0
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    radius: float
    def __init__(self, name: str) -> None: ...
    def get_radius(self) -> float: ...
    def set_radius(self, radius: float) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getRadius = get_radius
    setRadius = set_radius
    getClassType = get_class_type

class Spotlight(LightLensNode):
    """A light originating from a single point in space, and shining in a
    particular direction, with a cone-shaped falloff.
    
    The Spotlight frustum is defined using a Lens, so it can have any of the
    properties that a camera lens can have.
    
    Note that the class is named Spotlight instead of SpotLight, because
    "spotlight" is a single English word, instead of two words.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    exponent: float
    specular_color: LVecBase4f
    attenuation: LVecBase3f
    max_distance: float
    def __init__(self, name: str) -> None: ...
    def set_exponent(self, exponent: float) -> None: ...
    def set_specular_color(self, color: _Vec4f) -> None: ...
    def clear_specular_color(self) -> None: ...
    def set_attenuation(self, attenuation: _Vec3f) -> None: ...
    def get_max_distance(self) -> float: ...
    def set_max_distance(self, max_distance: float) -> None: ...
    @staticmethod
    def make_spot(pixel_width: int, full_radius: float, fg: _Vec4f, bg: _Vec4f) -> Texture: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    setExponent = set_exponent
    setSpecularColor = set_specular_color
    clearSpecularColor = clear_specular_color
    setAttenuation = set_attenuation
    getMaxDistance = get_max_distance
    setMaxDistance = set_max_distance
    makeSpot = make_spot
    getClassType = get_class_type

class SwitchNode(SelectiveChildNode):
    """A node that renders only one of its children, according to the user's
    indication.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    visible_child: int
    def __init__(self, name: str) -> None: ...
    def set_visible_child(self, index: int) -> None: ...
    def get_visible_child(self) -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    setVisibleChild = set_visible_child
    getVisibleChild = get_visible_child
    getClassType = get_class_type

class UvScrollNode(PandaNode):
    """This node is placed at key points within the scene graph to animate uvs."""
    DtoolClassDict: ClassVar[dict[str, Any]]
    u_speed: float
    v_speed: float
    w_speed: float
    r_speed: float
    @overload
    def __init__(self, name: str) -> None: ...
    @overload
    def __init__(self, name: str, u_speed: float, v_speed: float, w_speed: float, r_speed: float) -> None: ...
    def set_u_speed(self, u_speed: float) -> None: ...
    def set_v_speed(self, v_speed: float) -> None: ...
    def set_w_speed(self, w_speed: float) -> None: ...
    def set_r_speed(self, r_speed: float) -> None: ...
    def get_u_speed(self) -> float: ...
    def get_v_speed(self) -> float: ...
    def get_w_speed(self) -> float: ...
    def get_r_speed(self) -> float: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    setUSpeed = set_u_speed
    setVSpeed = set_v_speed
    setWSpeed = set_w_speed
    setRSpeed = set_r_speed
    getUSpeed = get_u_speed
    getVSpeed = get_v_speed
    getWSpeed = get_w_speed
    getRSpeed = get_r_speed
    getClassType = get_class_type

class SceneGraphAnalyzer:
    """A handy class that can scrub over a scene graph and collect interesting
    statistics on it.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    LM_lowest: ClassVar[Literal[0]]
    LM_highest: ClassVar[Literal[1]]
    LM_all: ClassVar[Literal[2]]
    LM_none: ClassVar[Literal[3]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, __param0: SceneGraphAnalyzer) -> None: ...
    def set_lod_mode(self, lod_mode: _SceneGraphAnalyzer_LodMode) -> None: ...
    def get_lod_mode(self, lod_mode: _SceneGraphAnalyzer_LodMode) -> _SceneGraphAnalyzer_LodMode: ...
    def clear(self) -> None: ...
    def add_node(self, node: PandaNode) -> None: ...
    def write(self, out: ostream, indent_level: int = ...) -> None: ...
    def get_num_nodes(self) -> int: ...
    def get_num_instances(self) -> int: ...
    def get_num_transforms(self) -> int: ...
    def get_num_nodes_with_attribs(self) -> int: ...
    def get_num_lod_nodes(self) -> int: ...
    def get_num_geom_nodes(self) -> int: ...
    def get_num_geoms(self) -> int: ...
    def get_num_geom_vertex_datas(self) -> int: ...
    def get_num_geom_vertex_formats(self) -> int: ...
    def get_vertex_data_size(self) -> int: ...
    def get_num_vertices(self) -> int: ...
    def get_num_normals(self) -> int: ...
    def get_num_colors(self) -> int: ...
    def get_num_texcoords(self) -> int: ...
    def get_num_tris(self) -> int: ...
    def get_num_lines(self) -> int: ...
    def get_num_points(self) -> int: ...
    def get_num_patches(self) -> int: ...
    def get_num_individual_tris(self) -> int: ...
    def get_num_tristrips(self) -> int: ...
    def get_num_triangles_in_strips(self) -> int: ...
    def get_num_trifans(self) -> int: ...
    def get_num_triangles_in_fans(self) -> int: ...
    def get_num_vertices_in_patches(self) -> int: ...
    def get_texture_bytes(self) -> int: ...
    def get_num_long_normals(self) -> int: ...
    def get_num_short_normals(self) -> int: ...
    def get_total_normal_length(self) -> float: ...
    setLodMode = set_lod_mode
    getLodMode = get_lod_mode
    addNode = add_node
    getNumNodes = get_num_nodes
    getNumInstances = get_num_instances
    getNumTransforms = get_num_transforms
    getNumNodesWithAttribs = get_num_nodes_with_attribs
    getNumLodNodes = get_num_lod_nodes
    getNumGeomNodes = get_num_geom_nodes
    getNumGeoms = get_num_geoms
    getNumGeomVertexDatas = get_num_geom_vertex_datas
    getNumGeomVertexFormats = get_num_geom_vertex_formats
    getVertexDataSize = get_vertex_data_size
    getNumVertices = get_num_vertices
    getNumNormals = get_num_normals
    getNumColors = get_num_colors
    getNumTexcoords = get_num_texcoords
    getNumTris = get_num_tris
    getNumLines = get_num_lines
    getNumPoints = get_num_points
    getNumPatches = get_num_patches
    getNumIndividualTris = get_num_individual_tris
    getNumTristrips = get_num_tristrips
    getNumTrianglesInStrips = get_num_triangles_in_strips
    getNumTrifans = get_num_trifans
    getNumTrianglesInFans = get_num_triangles_in_fans
    getNumVerticesInPatches = get_num_vertices_in_patches
    getTextureBytes = get_texture_bytes
    getNumLongNormals = get_num_long_normals
    getNumShortNormals = get_num_short_normals
    getTotalNormalLength = get_total_normal_length
    LMLowest = LM_lowest
    LMHighest = LM_highest
    LMAll = LM_all
    LMNone = LM_none

LNT_pop: Literal[0]
LNT_fade: Literal[1]
LNTPop = LNT_pop
LNTFade = LNT_fade
