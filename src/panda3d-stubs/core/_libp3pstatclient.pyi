from collections.abc import Sequence
from typing import Any, ClassVar, overload
from panda3d.core import PStatCollectorForwardBase, Thread, ostream

class PStatClient:
    DtoolClassDict: ClassVar[dict[str, Any]]
    client_name: str
    max_rate: float
    @property
    def collectors(self) -> Sequence[PStatCollector]: ...
    @property
    def threads(self) -> Sequence[PStatThread]: ...
    @property
    def main_thread(self) -> PStatThread: ...
    @property
    def current_thread(self) -> PStatThread: ...
    @property
    def real_time(self) -> float: ...
    def set_client_name(self, name: str) -> None: ...
    def get_client_name(self) -> str: ...
    def set_max_rate(self, rate: float) -> None: ...
    def get_max_rate(self) -> float: ...
    def get_num_collectors(self) -> int: ...
    def get_collector(self, index: int) -> PStatCollector: ...
    def get_collector_name(self, index: int) -> str: ...
    def get_collector_fullname(self, index: int) -> str: ...
    def get_num_threads(self) -> int: ...
    def get_thread(self, index: int) -> PStatThread: ...
    def get_thread_name(self, index: int) -> str: ...
    def get_thread_sync_name(self, index: int) -> str: ...
    def get_thread_object(self, index: int) -> Thread: ...
    def get_main_thread(self) -> PStatThread: ...
    def get_current_thread(self) -> PStatThread: ...
    def get_real_time(self) -> float: ...
    @staticmethod
    def connect(hostname: str = ..., port: int = ...) -> bool: ...
    @staticmethod
    def disconnect() -> None: ...
    @staticmethod
    def is_connected() -> bool: ...
    @staticmethod
    def resume_after_pause() -> None: ...
    @staticmethod
    def main_tick() -> None: ...
    @staticmethod
    def thread_tick(sync_name: str) -> None: ...
    def client_main_tick(self) -> None: ...
    def client_thread_tick(self, sync_name: str) -> None: ...
    def client_connect(self, hostname: str, port: int) -> bool: ...
    def client_disconnect(self) -> None: ...
    def client_is_connected(self) -> bool: ...
    def client_resume_after_pause(self) -> None: ...
    @staticmethod
    def get_global_pstats() -> PStatClient: ...
    def get_collectors(self) -> tuple[PStatCollector, ...]: ...
    def get_threads(self) -> tuple[PStatThread, ...]: ...
    setClientName = set_client_name
    getClientName = get_client_name
    setMaxRate = set_max_rate
    getMaxRate = get_max_rate
    getNumCollectors = get_num_collectors
    getCollector = get_collector
    getCollectorName = get_collector_name
    getCollectorFullname = get_collector_fullname
    getNumThreads = get_num_threads
    getThread = get_thread
    getThreadName = get_thread_name
    getThreadSyncName = get_thread_sync_name
    getThreadObject = get_thread_object
    getMainThread = get_main_thread
    getCurrentThread = get_current_thread
    getRealTime = get_real_time
    isConnected = is_connected
    resumeAfterPause = resume_after_pause
    mainTick = main_tick
    threadTick = thread_tick
    clientMainTick = client_main_tick
    clientThreadTick = client_thread_tick
    clientConnect = client_connect
    clientDisconnect = client_disconnect
    clientIsConnected = client_is_connected
    clientResumeAfterPause = client_resume_after_pause
    getGlobalPstats = get_global_pstats
    getCollectors = get_collectors
    getThreads = get_threads

class PStatCollector:
    """A lightweight class that represents a single element that may be timed
    and/or counted via stats.
    
    Collectors can be used to measure two different kinds of values: elapsed
    time, and "other".
    
    To measure elapsed time, call start() and stop() as appropriate to bracket
    the section of code you want to time (or use a PStatTimer to do this
    automatically).
    
    To measure anything else, call set_level() and/or add_level() to set the
    "level" value associated with this collector.  The meaning of the value set
    for the "level" is entirely up to the user; it may represent the number of
    triangles rendered or the kilobytes of texture memory consumed, for
    instance.  The level set will remain fixed across multiple frames until it
    is reset via another set_level() or adjusted via a call to add_level().  It
    may also be completely removed via clear_level().
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self, copy: PStatCollector) -> None: ...
    @overload
    def __init__(self, name: str, client: PStatClient = ...) -> None: ...
    @overload
    def __init__(self, parent: PStatCollector, name: str) -> None: ...
    def assign(self, copy: PStatCollector) -> PStatCollector: ...
    def is_valid(self) -> bool: ...
    def get_name(self) -> str: ...
    def get_fullname(self) -> str: ...
    def output(self, out: ostream) -> None: ...
    @overload
    def is_active(self) -> bool: ...
    @overload
    def is_active(self, thread: PStatThread) -> bool: ...
    @overload
    def is_started(self) -> bool: ...
    @overload
    def is_started(self, thread: PStatThread) -> bool: ...
    @overload
    def start(self) -> None: ...
    @overload
    def start(self, thread: PStatThread) -> None: ...
    @overload
    def start(self, thread: PStatThread, as_of: float) -> None: ...
    @overload
    def stop(self) -> None: ...
    @overload
    def stop(self, thread: PStatThread) -> None: ...
    @overload
    def stop(self, thread: PStatThread, as_of: float) -> None: ...
    @overload
    def clear_level(self) -> None: ...
    @overload
    def clear_level(self, thread: PStatThread) -> None: ...
    @overload
    def set_level(self, level: float) -> None: ...
    @overload
    def set_level(self, thread: PStatThread, level: float) -> None: ...
    @overload
    def add_level(self, increment: float) -> None: ...
    @overload
    def add_level(self, thread: PStatThread, increment: float) -> None: ...
    @overload
    def sub_level(self, decrement: float) -> None: ...
    @overload
    def sub_level(self, thread: PStatThread, decrement: float) -> None: ...
    def add_level_now(self, increment: float) -> None: ...
    def sub_level_now(self, decrement: float) -> None: ...
    def flush_level(self) -> None: ...
    @overload
    def get_level(self) -> float: ...
    @overload
    def get_level(self, thread: PStatThread) -> float: ...
    def clear_thread_level(self) -> None: ...
    def set_thread_level(self, level: float) -> None: ...
    def add_thread_level(self, increment: float) -> None: ...
    def sub_thread_level(self, decrement: float) -> None: ...
    def get_thread_level(self) -> float: ...
    def get_index(self) -> int: ...
    isValid = is_valid
    getName = get_name
    getFullname = get_fullname
    isActive = is_active
    isStarted = is_started
    clearLevel = clear_level
    setLevel = set_level
    addLevel = add_level
    subLevel = sub_level
    addLevelNow = add_level_now
    subLevelNow = sub_level_now
    flushLevel = flush_level
    getLevel = get_level
    clearThreadLevel = clear_thread_level
    setThreadLevel = set_thread_level
    addThreadLevel = add_thread_level
    subThreadLevel = sub_thread_level
    getThreadLevel = get_thread_level
    getIndex = get_index

class PStatThread:
    """A lightweight class that represents a single thread of execution to PStats.
    It corresponds one-to-one with Panda's Thread instance.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def thread(self) -> Thread: ...
    @property
    def index(self) -> int: ...
    @overload
    def __init__(self, copy: PStatThread) -> None: ...
    @overload
    def __init__(self, thread: Thread, client: PStatClient = ...) -> None: ...
    @overload
    def __init__(self, client: PStatClient, index: int) -> None: ...
    def assign(self, copy: PStatThread) -> PStatThread: ...
    def new_frame(self) -> None: ...
    def get_thread(self) -> Thread: ...
    def get_index(self) -> int: ...
    newFrame = new_frame
    getThread = get_thread
    getIndex = get_index

class PStatCollectorForward(PStatCollectorForwardBase):
    """This class serves as a cheap forward reference to a PStatCollector, so that
    classes that are defined before the pstats module may access the
    PStatCollector.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, col: PStatCollector) -> None: ...
