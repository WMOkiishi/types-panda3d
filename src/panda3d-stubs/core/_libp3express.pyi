from collections.abc import Sequence
from os import PathLike
from typing import Any, ClassVar, Literal, TypeAlias, overload
from panda3d.core import (
    ConfigVariableFilename,
    ConfigVariableSearchPath,
    DSearchPath,
    Filename,
    IStreamWrapper,
    OStreamWrapper,
    StreamReader,
    StreamWrapper,
    StreamWriter,
    TypeHandle,
    TypedObject,
    iostream,
    istream,
    ostream,
)

_Filename: TypeAlias = Filename | ConfigVariableFilename | str | bytes | PathLike
_ErrorUtilCode: TypeAlias = Literal[-80, -73, -72, -71, -70, -67, -66, -65, -64, -63, -62, -61, -60, -54, -53, -52, -51, -50, -42, -41, -40, -34, -33, -32, -31, -30, -4, -3, -2, -1, 1, 2, 3, 4, 5, 6, 7]
_WindowsRegistry_RegLevel: TypeAlias = Literal[0, 1]
_WindowsRegistry_Type: TypeAlias = Literal[0, 1, 2]

class ConstPointerToArray_double(PointerToArrayBase_double):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, copy: ConstPointerToArray_double | PointerToArray_double) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, n: int) -> float: ...
    def clear(self) -> None: ...
    def get_element(self, n: int) -> float: ...
    def get_data(self) -> bytes: ...
    def get_subdata(self, n: int, count: int) -> bytes: ...
    def get_ref_count(self) -> int: ...
    def get_node_ref_count(self) -> int: ...
    def count(self, __param0: float) -> int: ...
    getElement = get_element
    getData = get_data
    getSubdata = get_subdata
    getRefCount = get_ref_count
    getNodeRefCount = get_node_ref_count

class PointerToArrayBase_double(PointerToBase_ReferenceCountedVector_double):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...

class PointerToBase_ReferenceCountedVector_double(PointerToVoid):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def clear(self) -> None: ...
    def output(self, out: ostream) -> None: ...

class PointerToVoid:
    """This is the non-template part of the base class for PointerTo and
    ConstPointerTo.  It is necessary so we can keep a pointer to a non-template
    class within the ReferenceCount object, to implement weak reference
    pointers--we need to have something to clean up when the ReferenceCount
    object destructs.
    
    This is the base class for PointerToBase<T>.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def is_null(self) -> bool: ...
    def get_hash(self) -> int: ...
    isNull = is_null
    getHash = get_hash

class ConstPointerToArray_float(PointerToArrayBase_float):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, copy: ConstPointerToArray_float | PointerToArray_float) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, n: int) -> float: ...
    def clear(self) -> None: ...
    def get_element(self, n: int) -> float: ...
    def get_data(self) -> bytes: ...
    def get_subdata(self, n: int, count: int) -> bytes: ...
    def get_ref_count(self) -> int: ...
    def get_node_ref_count(self) -> int: ...
    def count(self, __param0: float) -> int: ...
    getElement = get_element
    getData = get_data
    getSubdata = get_subdata
    getRefCount = get_ref_count
    getNodeRefCount = get_node_ref_count

class PointerToArrayBase_float(PointerToBase_ReferenceCountedVector_float):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...

class PointerToBase_ReferenceCountedVector_float(PointerToVoid):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def clear(self) -> None: ...
    def output(self, out: ostream) -> None: ...

class ConstPointerToArray_int(PointerToArrayBase_int):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, copy: ConstPointerToArray_int | PointerToArray_int) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, n: int) -> int: ...
    def clear(self) -> None: ...
    def get_element(self, n: int) -> int: ...
    def get_data(self) -> bytes: ...
    def get_subdata(self, n: int, count: int) -> bytes: ...
    def get_ref_count(self) -> int: ...
    def get_node_ref_count(self) -> int: ...
    def count(self, __param0: int) -> int: ...
    getElement = get_element
    getData = get_data
    getSubdata = get_subdata
    getRefCount = get_ref_count
    getNodeRefCount = get_node_ref_count

class PointerToArrayBase_int(PointerToBase_ReferenceCountedVector_int):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...

class PointerToBase_ReferenceCountedVector_int(PointerToVoid):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def clear(self) -> None: ...
    def output(self, out: ostream) -> None: ...

class ConstPointerToArray_unsigned_char(PointerToArrayBase_unsigned_char):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, copy: ConstPointerToArray_unsigned_char | PointerToArray_unsigned_char) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, n: int) -> str: ...
    def clear(self) -> None: ...
    def get_element(self, n: int) -> str: ...
    def get_data(self) -> bytes: ...
    def get_subdata(self, n: int, count: int) -> bytes: ...
    def get_ref_count(self) -> int: ...
    def get_node_ref_count(self) -> int: ...
    def count(self, __param0: str) -> int: ...
    getElement = get_element
    getData = get_data
    getSubdata = get_subdata
    getRefCount = get_ref_count
    getNodeRefCount = get_node_ref_count

class PointerToArrayBase_unsigned_char(PointerToBase_ReferenceCountedVector_unsigned_char):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...

class PointerToBase_ReferenceCountedVector_unsigned_char(PointerToVoid):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def clear(self) -> None: ...
    def output(self, out: ostream) -> None: ...

class PointerToArray_double(PointerToArrayBase_double):
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self, type_handle: TypeHandle = ...) -> None: ...
    @overload
    def __init__(self, copy: PointerToArray_double) -> None: ...
    @overload
    def __init__(self, source: Any) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, n: int) -> float: ...
    def __setitem__(self, n: int, value: float) -> None: ...
    @staticmethod
    def empty_array(n: int, type_handle: TypeHandle = ...) -> PointerToArray_double: ...
    def clear(self) -> None: ...
    def push_back(self, x: float) -> None: ...
    def pop_back(self) -> None: ...
    def get_element(self, n: int) -> float: ...
    def set_element(self, n: int, value: float) -> None: ...
    def get_data(self) -> bytes: ...
    def set_data(self, data: Any) -> None: ...
    def get_subdata(self, n: int, count: int) -> bytes: ...
    def set_subdata(self, n: int, count: int, data: str) -> None: ...
    def get_ref_count(self) -> int: ...
    def get_node_ref_count(self) -> int: ...
    def count(self, __param0: float) -> int: ...
    emptyArray = empty_array
    pushBack = push_back
    popBack = pop_back
    getElement = get_element
    setElement = set_element
    getData = get_data
    setData = set_data
    getSubdata = get_subdata
    setSubdata = set_subdata
    getRefCount = get_ref_count
    getNodeRefCount = get_node_ref_count

class PointerToArray_float(PointerToArrayBase_float):
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self, type_handle: TypeHandle = ...) -> None: ...
    @overload
    def __init__(self, copy: PointerToArray_float) -> None: ...
    @overload
    def __init__(self, source: Any) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, n: int) -> float: ...
    def __setitem__(self, n: int, value: float) -> None: ...
    @staticmethod
    def empty_array(n: int, type_handle: TypeHandle = ...) -> PointerToArray_float: ...
    def clear(self) -> None: ...
    def push_back(self, x: float) -> None: ...
    def pop_back(self) -> None: ...
    def get_element(self, n: int) -> float: ...
    def set_element(self, n: int, value: float) -> None: ...
    def get_data(self) -> bytes: ...
    def set_data(self, data: Any) -> None: ...
    def get_subdata(self, n: int, count: int) -> bytes: ...
    def set_subdata(self, n: int, count: int, data: str) -> None: ...
    def get_ref_count(self) -> int: ...
    def get_node_ref_count(self) -> int: ...
    def count(self, __param0: float) -> int: ...
    emptyArray = empty_array
    pushBack = push_back
    popBack = pop_back
    getElement = get_element
    setElement = set_element
    getData = get_data
    setData = set_data
    getSubdata = get_subdata
    setSubdata = set_subdata
    getRefCount = get_ref_count
    getNodeRefCount = get_node_ref_count

class PointerToArray_int(PointerToArrayBase_int):
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self, type_handle: TypeHandle = ...) -> None: ...
    @overload
    def __init__(self, copy: PointerToArray_int) -> None: ...
    @overload
    def __init__(self, source: Any) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, n: int) -> int: ...
    def __setitem__(self, n: int, value: int) -> None: ...
    @staticmethod
    def empty_array(n: int, type_handle: TypeHandle = ...) -> PointerToArray_int: ...
    def clear(self) -> None: ...
    def push_back(self, x: int) -> None: ...
    def pop_back(self) -> None: ...
    def get_element(self, n: int) -> int: ...
    def set_element(self, n: int, value: int) -> None: ...
    def get_data(self) -> bytes: ...
    def set_data(self, data: Any) -> None: ...
    def get_subdata(self, n: int, count: int) -> bytes: ...
    def set_subdata(self, n: int, count: int, data: str) -> None: ...
    def get_ref_count(self) -> int: ...
    def get_node_ref_count(self) -> int: ...
    def count(self, __param0: int) -> int: ...
    emptyArray = empty_array
    pushBack = push_back
    popBack = pop_back
    getElement = get_element
    setElement = set_element
    getData = get_data
    setData = set_data
    getSubdata = get_subdata
    setSubdata = set_subdata
    getRefCount = get_ref_count
    getNodeRefCount = get_node_ref_count

class PointerToArray_unsigned_char(PointerToArrayBase_unsigned_char):
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self, type_handle: TypeHandle = ...) -> None: ...
    @overload
    def __init__(self, copy: PointerToArray_unsigned_char) -> None: ...
    @overload
    def __init__(self, source: Any) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, n: int) -> str: ...
    def __setitem__(self, n: int, value: str) -> None: ...
    @staticmethod
    def empty_array(n: int, type_handle: TypeHandle = ...) -> PointerToArray_unsigned_char: ...
    def clear(self) -> None: ...
    def push_back(self, x: str) -> None: ...
    def pop_back(self) -> None: ...
    def get_element(self, n: int) -> str: ...
    def set_element(self, n: int, value: str) -> None: ...
    def get_data(self) -> bytes: ...
    def set_data(self, data: Any) -> None: ...
    def get_subdata(self, n: int, count: int) -> bytes: ...
    def set_subdata(self, n: int, count: int, data: str) -> None: ...
    def get_ref_count(self) -> int: ...
    def get_node_ref_count(self) -> int: ...
    def count(self, __param0: str) -> int: ...
    emptyArray = empty_array
    pushBack = push_back
    popBack = pop_back
    getElement = get_element
    setElement = set_element
    getData = get_data
    setData = set_data
    getSubdata = get_subdata
    setSubdata = set_subdata
    getRefCount = get_ref_count
    getNodeRefCount = get_node_ref_count

class MemoryUsage:
    """This class is used strictly for debugging purposes, specifically for
    tracking memory leaks of reference-counted objects: it keeps a record of
    every such object currently allocated.
    
    When compiled with NDEBUG set, this entire class does nothing and compiles
    to a stub.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def tracking(self) -> bool: ...
    @property
    def counting(self) -> bool: ...
    @property
    def current_cpp_size(self) -> int: ...
    @property
    def total_cpp_size(self) -> int: ...
    @property
    def panda_heap_single_size(self) -> int: ...
    @property
    def panda_heap_array_size(self) -> int: ...
    @property
    def panda_heap_overhead(self) -> int: ...
    @property
    def panda_mmap_size(self) -> int: ...
    @property
    def external_size(self) -> int: ...
    @property
    def total_size(self) -> int: ...
    def __init__(self, __param0: MemoryUsage) -> None: ...
    @staticmethod
    def is_tracking() -> bool: ...
    @staticmethod
    def is_counting() -> bool: ...
    @staticmethod
    def get_current_cpp_size() -> int: ...
    @staticmethod
    def get_total_cpp_size() -> int: ...
    @staticmethod
    def get_panda_heap_single_size() -> int: ...
    @staticmethod
    def get_panda_heap_array_size() -> int: ...
    @staticmethod
    def get_panda_heap_overhead() -> int: ...
    @staticmethod
    def get_panda_mmap_size() -> int: ...
    @staticmethod
    def get_external_size() -> int: ...
    @staticmethod
    def get_total_size() -> int: ...
    @staticmethod
    def get_num_pointers() -> int: ...
    @staticmethod
    def get_pointers(result: MemoryUsagePointers) -> None: ...
    @staticmethod
    def get_pointers_of_type(result: MemoryUsagePointers, type: TypeHandle) -> None: ...
    @staticmethod
    def get_pointers_of_age(result: MemoryUsagePointers, _from: float, to: float) -> None: ...
    @staticmethod
    def get_pointers_with_zero_count(result: MemoryUsagePointers) -> None: ...
    @staticmethod
    def freeze() -> None: ...
    @staticmethod
    def show_current_types() -> None: ...
    @staticmethod
    def show_trend_types() -> None: ...
    @staticmethod
    def show_current_ages() -> None: ...
    @staticmethod
    def show_trend_ages() -> None: ...
    isTracking = is_tracking
    isCounting = is_counting
    getCurrentCppSize = get_current_cpp_size
    getTotalCppSize = get_total_cpp_size
    getPandaHeapSingleSize = get_panda_heap_single_size
    getPandaHeapArraySize = get_panda_heap_array_size
    getPandaHeapOverhead = get_panda_heap_overhead
    getPandaMmapSize = get_panda_mmap_size
    getExternalSize = get_external_size
    getTotalSize = get_total_size
    getNumPointers = get_num_pointers
    getPointers = get_pointers
    getPointersOfType = get_pointers_of_type
    getPointersOfAge = get_pointers_of_age
    getPointersWithZeroCount = get_pointers_with_zero_count
    showCurrentTypes = show_current_types
    showTrendTypes = show_trend_types
    showCurrentAges = show_current_ages
    showTrendAges = show_trend_ages

class ReferenceCount:
    """A base class for all things that want to be reference-counted.
    ReferenceCount works in conjunction with PointerTo to automatically delete
    objects when the last pointer to them goes away.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def ref_count(self) -> int: ...
    def get_ref_count(self) -> int: ...
    def ref(self) -> None: ...
    def unref(self) -> bool: ...
    def test_ref_count_integrity(self) -> bool: ...
    def test_ref_count_nonzero(self) -> bool: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getRefCount = get_ref_count
    testRefCountIntegrity = test_ref_count_integrity
    testRefCountNonzero = test_ref_count_nonzero
    getClassType = get_class_type

class Buffer(ReferenceCount):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, __param0: Buffer) -> None: ...
    def get_length(self) -> int: ...
    getLength = get_length

class PStatCollectorForwardBase(ReferenceCount):
    """This class serves as a cheap forward reference to a PStatCollector, which
    is defined in the pstatclient module (and is not directly accessible here
    in the express module).
    
    This is subclassed as PStatCollectorForward, which defines the actual
    functionality.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def add_level(self, level: float) -> None: ...
    addLevel = add_level

class NodeReferenceCount(ReferenceCount):
    """This class specializes ReferenceCount to add an additional counter, called
    node_ref_count, for the purposes of counting the number of times the object
    is referenced by a "node", whatever that may mean in context.
    
    The new methods node_ref() and node_unref() automatically increment and
    decrement the primary reference count as well.  There also exists a
    NodePointerTo<> class to maintain the node_ref counters automatically.
    
    See also CachedTypedWritableReferenceCount, which is similar in principle,
    as well as NodeCachedReferenceCount, which combines both of these.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def get_node_ref_count(self) -> int: ...
    def node_ref(self) -> None: ...
    def node_unref(self) -> bool: ...
    def test_ref_count_integrity(self) -> bool: ...
    def node_unref_only(self) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getNodeRefCount = get_node_ref_count
    nodeRef = node_ref
    nodeUnref = node_unref
    testRefCountIntegrity = test_ref_count_integrity
    nodeUnrefOnly = node_unref_only
    getClassType = get_class_type

class Datagram(TypedObject):
    """An ordered list of data elements, formatted in memory for transmission over
    a socket or writing to a data file.
    
    Data elements should be added one at a time, in order, to the Datagram.
    The nature and contents of the data elements are totally up to the user.
    When a Datagram has been transmitted and received, its data elements may be
    extracted using a DatagramIterator; it is up to the caller to know the
    correct type of each data element in order.
    
    A Datagram is itself headerless; it is simply a collection of data
    elements.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, copy: Datagram) -> None: ...
    @overload
    def __init__(self, data: bytes) -> None: ...
    def __bytes__(self) -> bytes: ...
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...
    def __lt__(self, other: Datagram) -> bool: ...
    def __le__(self, other: Datagram) -> bool: ...
    def assign(self, copy: Datagram) -> Datagram: ...
    def clear(self) -> None: ...
    def dump_hex(self, out: ostream, indent: int = ...) -> None: ...
    def add_bool(self, value: bool) -> None: ...
    def add_int8(self, value: str) -> None: ...
    def add_uint8(self, value: str) -> None: ...
    def add_int16(self, value: int) -> None: ...
    def add_int32(self, value: int) -> None: ...
    def add_int64(self, value: int) -> None: ...
    def add_uint16(self, value: int) -> None: ...
    def add_uint32(self, value: int) -> None: ...
    def add_uint64(self, value: int) -> None: ...
    def add_float32(self, value: float) -> None: ...
    def add_float64(self, value: float) -> None: ...
    def add_stdfloat(self, value: float) -> None: ...
    def add_be_int16(self, value: int) -> None: ...
    def add_be_int32(self, value: int) -> None: ...
    def add_be_int64(self, value: int) -> None: ...
    def add_be_uint16(self, value: int) -> None: ...
    def add_be_uint32(self, value: int) -> None: ...
    def add_be_uint64(self, value: int) -> None: ...
    def add_be_float32(self, value: float) -> None: ...
    def add_be_float64(self, value: float) -> None: ...
    def add_string(self, str: str) -> None: ...
    def add_string32(self, str: str) -> None: ...
    def add_z_string(self, str: str) -> None: ...
    def add_fixed_string(self, str: str, size: int) -> None: ...
    def add_wstring(self, str: str) -> None: ...
    def add_blob(self, __param0: bytes) -> None: ...
    def add_blob32(self, __param0: bytes) -> None: ...
    def pad_bytes(self, size: int) -> None: ...
    def append_data(self, data: bytes) -> None: ...
    def get_message(self) -> bytes: ...
    def get_length(self) -> int: ...
    def set_array(self, data: PointerToArray_unsigned_char) -> None: ...
    def copy_array(self, data: ConstPointerToArray_unsigned_char | PointerToArray_unsigned_char) -> None: ...
    def get_array(self) -> ConstPointerToArray_unsigned_char: ...
    def modify_array(self) -> PointerToArray_unsigned_char: ...
    def set_stdfloat_double(self, stdfloat_double: bool) -> None: ...
    def get_stdfloat_double(self) -> bool: ...
    def output(self, out: ostream) -> None: ...
    def write(self, out: ostream, indent: int = ...) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    dumpHex = dump_hex
    addBool = add_bool
    addInt8 = add_int8
    addUint8 = add_uint8
    addInt16 = add_int16
    addInt32 = add_int32
    addInt64 = add_int64
    addUint16 = add_uint16
    addUint32 = add_uint32
    addUint64 = add_uint64
    addFloat32 = add_float32
    addFloat64 = add_float64
    addStdfloat = add_stdfloat
    addBeInt16 = add_be_int16
    addBeInt32 = add_be_int32
    addBeInt64 = add_be_int64
    addBeUint16 = add_be_uint16
    addBeUint32 = add_be_uint32
    addBeUint64 = add_be_uint64
    addBeFloat32 = add_be_float32
    addBeFloat64 = add_be_float64
    addString = add_string
    addString32 = add_string32
    addZString = add_z_string
    addFixedString = add_fixed_string
    addWstring = add_wstring
    addBlob = add_blob
    addBlob32 = add_blob32
    padBytes = pad_bytes
    appendData = append_data
    getMessage = get_message
    Bytes = __bytes__
    getLength = get_length
    setArray = set_array
    copyArray = copy_array
    getArray = get_array
    modifyArray = modify_array
    setStdfloatDouble = set_stdfloat_double
    getStdfloatDouble = get_stdfloat_double
    getClassType = get_class_type

class DatagramGenerator:
    """This class defines the abstract interace to any source of datagrams,
    whether it be from a file or from the net.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def get_datagram(self, data: Datagram) -> bool: ...
    def save_datagram(self, info: SubfileInfo) -> bool: ...
    def is_eof(self) -> bool: ...
    def is_error(self) -> bool: ...
    def get_filename(self) -> Filename: ...
    def get_timestamp(self) -> int: ...
    def get_file(self) -> FileReference: ...
    def get_vfile(self) -> VirtualFile: ...
    def get_file_pos(self) -> int: ...
    getDatagram = get_datagram
    saveDatagram = save_datagram
    isEof = is_eof
    isError = is_error
    getFilename = get_filename
    getTimestamp = get_timestamp
    getFile = get_file
    getVfile = get_vfile
    getFilePos = get_file_pos

class DatagramIterator:
    """A class to retrieve the individual data elements previously stored in a
    Datagram.  Elements may be retrieved one at a time; it is up to the caller
    to know the correct type and order of each element.
    
    Note that it is the responsibility of the caller to ensure that the datagram
    object is not destructed while this DatagramIterator is in use.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, __param0: DatagramIterator) -> None: ...
    @overload
    def __init__(self, datagram: Datagram, offset: int = ...) -> None: ...
    def get_bool(self) -> bool: ...
    def get_int8(self) -> str: ...
    def get_uint8(self) -> str: ...
    def get_int16(self) -> int: ...
    def get_int32(self) -> int: ...
    def get_int64(self) -> int: ...
    def get_uint16(self) -> int: ...
    def get_uint32(self) -> int: ...
    def get_uint64(self) -> int: ...
    def get_float32(self) -> float: ...
    def get_float64(self) -> float: ...
    def get_stdfloat(self) -> float: ...
    def get_be_int16(self) -> int: ...
    def get_be_int32(self) -> int: ...
    def get_be_int64(self) -> int: ...
    def get_be_uint16(self) -> int: ...
    def get_be_uint32(self) -> int: ...
    def get_be_uint64(self) -> int: ...
    def get_be_float32(self) -> float: ...
    def get_be_float64(self) -> float: ...
    def get_string(self) -> str: ...
    def get_string32(self) -> str: ...
    def get_z_string(self) -> str: ...
    def get_fixed_string(self, size: int) -> str: ...
    def get_wstring(self) -> str: ...
    def get_blob(self) -> bytes: ...
    def get_blob32(self) -> bytes: ...
    def skip_bytes(self, size: int) -> None: ...
    def extract_bytes(self, size: int) -> bytes: ...
    def get_remaining_bytes(self) -> bytes: ...
    def get_remaining_size(self) -> int: ...
    def get_datagram(self) -> Datagram: ...
    def get_current_index(self) -> int: ...
    def output(self, out: ostream) -> None: ...
    def write(self, out: ostream, indent: int = ...) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getBool = get_bool
    getInt8 = get_int8
    getUint8 = get_uint8
    getInt16 = get_int16
    getInt32 = get_int32
    getInt64 = get_int64
    getUint16 = get_uint16
    getUint32 = get_uint32
    getUint64 = get_uint64
    getFloat32 = get_float32
    getFloat64 = get_float64
    getStdfloat = get_stdfloat
    getBeInt16 = get_be_int16
    getBeInt32 = get_be_int32
    getBeInt64 = get_be_int64
    getBeUint16 = get_be_uint16
    getBeUint32 = get_be_uint32
    getBeUint64 = get_be_uint64
    getBeFloat32 = get_be_float32
    getBeFloat64 = get_be_float64
    getString = get_string
    getString32 = get_string32
    getZString = get_z_string
    getFixedString = get_fixed_string
    getWstring = get_wstring
    getBlob = get_blob
    getBlob32 = get_blob32
    skipBytes = skip_bytes
    extractBytes = extract_bytes
    getRemainingBytes = get_remaining_bytes
    getRemainingSize = get_remaining_size
    getDatagram = get_datagram
    getCurrentIndex = get_current_index
    getClassType = get_class_type

class DatagramSink:
    """This class defines the abstract interface to sending datagrams to any
    target, whether it be into a file or across the net
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def filename(self) -> Filename: ...
    @property
    def file(self) -> FileReference: ...
    @property
    def file_pos(self) -> int: ...
    def put_datagram(self, data: Datagram) -> bool: ...
    @overload
    def copy_datagram(self, result: SubfileInfo, filename: _Filename) -> bool: ...
    @overload
    def copy_datagram(self, result: SubfileInfo, source: SubfileInfo) -> bool: ...
    def is_error(self) -> bool: ...
    def flush(self) -> None: ...
    def get_filename(self) -> Filename: ...
    def get_file(self) -> FileReference: ...
    def get_file_pos(self) -> int: ...
    putDatagram = put_datagram
    copyDatagram = copy_datagram
    isError = is_error
    getFilename = get_filename
    getFile = get_file
    getFilePos = get_file_pos

class FileReference(TypedReferenceCount):
    """Keeps a reference-counted pointer to a file on disk.  As long as the
    FileReference is held, someone presumably has a use for this file.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self, __param0: FileReference) -> None: ...
    @overload
    def __init__(self, filename: _Filename) -> None: ...
    def get_filename(self) -> Filename: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getFilename = get_filename
    getClassType = get_class_type

class TypedReferenceCount(TypedObject, ReferenceCount):
    """A base class for things which need to inherit from both TypedObject and
    from ReferenceCount.  It's convenient to define this intermediate base
    class instead of multiply inheriting from the two classes each time they
    are needed, so that we can sensibly pass around pointers to things which
    are both TypedObjects and ReferenceCounters.
    
    See also TypedObject for detailed instructions.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def upcast_to_TypedObject(self) -> TypedObject: ...
    def upcast_to_ReferenceCount(self) -> ReferenceCount: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    upcastToTypedObject = upcast_to_TypedObject
    upcastToReferenceCount = upcast_to_ReferenceCount
    getClassType = get_class_type

class Ramfile:
    """An in-memory buffer specifically designed for downloading files to memory."""
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, __param0: Ramfile) -> None: ...
    def seek(self, pos: int) -> None: ...
    def tell(self) -> int: ...
    def read(self, length: int) -> bytes: ...
    def readline(self) -> bytes: ...
    def readlines(self) -> list[bytes]: ...
    def get_data(self) -> bytes: ...
    def get_data_size(self) -> int: ...
    def clear(self) -> None: ...
    getData = get_data
    getDataSize = get_data_size

class HashVal:
    """Stores a 128-bit value that represents the hashed contents (typically MD5)
    of a file or buffer.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, copy: HashVal) -> None: ...
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...
    def __lt__(self, other: HashVal) -> bool: ...
    def __le__(self, other: HashVal) -> bool: ...
    def assign(self, copy: HashVal) -> HashVal: ...
    def compare_to(self, other: HashVal) -> int: ...
    def merge_with(self, other: HashVal) -> None: ...
    def output_dec(self, out: ostream) -> None: ...
    def input_dec(self, _in: istream) -> None: ...
    def output_hex(self, out: ostream) -> None: ...
    def input_hex(self, _in: istream) -> None: ...
    def output_binary(self, out: ostream) -> None: ...
    def input_binary(self, _in: istream) -> None: ...
    def output(self, out: ostream) -> None: ...
    def as_dec(self) -> str: ...
    def set_from_dec(self, text: str) -> bool: ...
    def as_hex(self) -> str: ...
    def set_from_hex(self, text: str) -> bool: ...
    def as_bin(self) -> bytes: ...
    def set_from_bin(self, text: bytes) -> bool: ...
    def write_datagram(self, destination: Datagram) -> None: ...
    def read_datagram(self, source: DatagramIterator) -> None: ...
    def write_stream(self, destination: StreamWriter) -> None: ...
    def read_stream(self, source: StreamReader) -> None: ...
    def hash_file(self, filename: _Filename) -> bool: ...
    def hash_stream(self, stream: istream) -> bool: ...
    def hash_ramfile(self, ramfile: Ramfile) -> None: ...
    def hash_string(self, data: str) -> None: ...
    def hash_bytes(self, data: bytes) -> None: ...
    def hash_buffer(self, buffer: str, length: int) -> None: ...
    compareTo = compare_to
    mergeWith = merge_with
    outputDec = output_dec
    inputDec = input_dec
    outputHex = output_hex
    inputHex = input_hex
    outputBinary = output_binary
    inputBinary = input_binary
    asDec = as_dec
    setFromDec = set_from_dec
    asHex = as_hex
    setFromHex = set_from_hex
    asBin = as_bin
    setFromBin = set_from_bin
    writeDatagram = write_datagram
    readDatagram = read_datagram
    writeStream = write_stream
    readStream = read_stream
    hashFile = hash_file
    hashStream = hash_stream
    hashRamfile = hash_ramfile
    hashString = hash_string
    hashBytes = hash_bytes
    hashBuffer = hash_buffer

class MemoryUsagePointers:
    """This is a list of pointers returned by a MemoryUsage object in response to
    some query.
    
    Warning: once pointers are stored in a MemoryUsagePointers object, they are
    reference-counted, and will not be freed until the MemoryUsagePointers
    object is freed (or clear() is called on the object).  However, they may
    not even be freed then; pointers may leak once they have been added to this
    structure.  This is because we don't store enough information in this
    structure to correctly free the pointers that have been added.  Since this
    is intended primarily as a debugging tool, this is not a major issue.
    
    This class is just a user interface to talk about pointers stored in a
    MemoryUsage object.  It doesn't even exist when compiled with NDEBUG.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, __param0: MemoryUsagePointers) -> None: ...
    def get_num_pointers(self) -> int: ...
    def get_pointer(self, n: int) -> ReferenceCount: ...
    def get_typed_pointer(self, n: int) -> TypedObject: ...
    def get_type(self, n: int) -> TypeHandle: ...
    def get_type_name(self, n: int) -> str: ...
    def get_age(self, n: int) -> float: ...
    def get_python_pointer(self, n: int) -> Any: ...
    def clear(self) -> None: ...
    def output(self, out: ostream) -> None: ...
    def get_pointers(self) -> tuple[ReferenceCount, ...]: ...
    def get_typed_pointers(self) -> tuple[TypedObject, ...]: ...
    getNumPointers = get_num_pointers
    getPointer = get_pointer
    getTypedPointer = get_typed_pointer
    getType = get_type
    getTypeName = get_type_name
    getAge = get_age
    getPythonPointer = get_python_pointer
    getPointers = get_pointers
    getTypedPointers = get_typed_pointers

class ISubStream(istream):
    """An istream object that presents a subwindow into another istream.  The
    first character read from this stream will be the "start" character from
    the source istream; just before the file pointer reaches the "end"
    character, eof is returned.
    
    The source stream must be one that we can randomly seek within.  The
    resulting ISubStream will also support arbitrary seeks.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, source: IStreamWrapper, start: int, end: int) -> None: ...
    def open(self, source: IStreamWrapper, start: int, end: int) -> ISubStream: ...
    def close(self) -> ISubStream: ...

class OSubStream(ostream):
    """An ostream object that presents a subwindow into another ostream.  The
    first character written to this stream will be the "start" character in the
    dest istream; no characters may be written to character "end" or later
    (unless end is zero).
    
    The dest stream must be one that we can randomly seek within.  The
    resulting OSubStream will also support arbitrary seeks.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dest: OStreamWrapper, start: int, end: int, append: bool = ...) -> None: ...
    def open(self, dest: OStreamWrapper, start: int, end: int, append: bool = ...) -> OSubStream: ...
    def close(self) -> OSubStream: ...

class SubStream(iostream):
    """Combined ISubStream and OSubStream for bidirectional I/O."""
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, nested: StreamWrapper, start: int, end: int, append: bool = ...) -> None: ...
    def open(self, nested: StreamWrapper, start: int, end: int, append: bool = ...) -> SubStream: ...
    def close(self) -> SubStream: ...

class Multifile(ReferenceCount):
    """A file that contains a set of files."""
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def magic_number(self) -> str: ...
    def __init__(self) -> None: ...
    @overload
    def open_read(self, multifile_name: _Filename, offset: int = ...) -> bool: ...
    @overload
    def open_read(self, multifile_stream: IStreamWrapper, owns_pointer: bool = ..., offset: int = ...) -> bool: ...
    @overload
    def open_write(self, multifile_name: _Filename) -> bool: ...
    @overload
    def open_write(self, multifile_stream: ostream, owns_pointer: bool = ...) -> bool: ...
    @overload
    def open_read_write(self, multifile_name: _Filename) -> bool: ...
    @overload
    def open_read_write(self, multifile_stream: iostream, owns_pointer: bool = ...) -> bool: ...
    def close(self) -> None: ...
    def get_multifile_name(self) -> Filename: ...
    def set_multifile_name(self, multifile_name: _Filename) -> None: ...
    def is_read_valid(self) -> bool: ...
    def is_write_valid(self) -> bool: ...
    def needs_repack(self) -> bool: ...
    def get_timestamp(self) -> int: ...
    def set_timestamp(self, timestamp: int) -> None: ...
    def set_record_timestamp(self, record_timestamp: bool) -> None: ...
    def get_record_timestamp(self) -> bool: ...
    def set_scale_factor(self, scale_factor: int) -> None: ...
    def get_scale_factor(self) -> int: ...
    def set_encryption_flag(self, flag: bool) -> None: ...
    def get_encryption_flag(self) -> bool: ...
    def set_encryption_password(self, encryption_password: str) -> None: ...
    def get_encryption_password(self) -> str: ...
    def set_encryption_algorithm(self, encryption_algorithm: str) -> None: ...
    def get_encryption_algorithm(self) -> str: ...
    def set_encryption_key_length(self, encryption_key_length: int) -> None: ...
    def get_encryption_key_length(self) -> int: ...
    def set_encryption_iteration_count(self, encryption_iteration_count: int) -> None: ...
    def get_encryption_iteration_count(self) -> int: ...
    @overload
    def add_subfile(self, subfile_name: str, filename: _Filename, compression_level: int) -> str: ...
    @overload
    def add_subfile(self, subfile_name: str, subfile_data: istream, compression_level: int) -> str: ...
    def update_subfile(self, subfile_name: str, filename: _Filename, compression_level: int) -> str: ...
    @overload
    def add_signature(self, composite: _Filename, password: str = ...) -> bool: ...
    @overload
    def add_signature(self, certificate: _Filename, chain: _Filename, pkey: _Filename, password: str = ...) -> bool: ...
    def get_num_signatures(self) -> int: ...
    def get_signature_subject_name(self, n: int) -> str: ...
    def get_signature_friendly_name(self, n: int) -> str: ...
    def get_signature_public_key(self, n: int) -> str: ...
    def print_signature_certificate(self, n: int, out: ostream) -> None: ...
    def write_signature_certificate(self, n: int, out: ostream) -> None: ...
    def validate_signature_certificate(self, n: int) -> int: ...
    def flush(self) -> bool: ...
    def repack(self) -> bool: ...
    def get_num_subfiles(self) -> int: ...
    def find_subfile(self, subfile_name: str) -> int: ...
    def has_directory(self, subfile_name: str) -> bool: ...
    @overload
    def remove_subfile(self, index: int) -> None: ...
    @overload
    def remove_subfile(self, subfile_name: str) -> bool: ...
    def get_subfile_name(self, index: int) -> str: ...
    def get_subfile_length(self, index: int) -> int: ...
    def get_subfile_timestamp(self, index: int) -> int: ...
    def is_subfile_compressed(self, index: int) -> bool: ...
    def is_subfile_encrypted(self, index: int) -> bool: ...
    def is_subfile_text(self, index: int) -> bool: ...
    def get_index_end(self) -> int: ...
    def get_subfile_internal_start(self, index: int) -> int: ...
    def get_subfile_internal_length(self, index: int) -> int: ...
    def read_subfile(self, index: int) -> bytes: ...
    def open_read_subfile(self, index: int) -> istream: ...
    @staticmethod
    def close_read_subfile(stream: istream) -> None: ...
    def extract_subfile(self, index: int, filename: _Filename) -> bool: ...
    def extract_subfile_to(self, index: int, out: ostream) -> bool: ...
    def compare_subfile(self, index: int, filename: _Filename) -> bool: ...
    def output(self, out: ostream) -> None: ...
    def ls(self, out: ostream = ...) -> None: ...
    @staticmethod
    def get_magic_number() -> str: ...
    def set_header_prefix(self, header_prefix: str) -> None: ...
    def get_header_prefix(self) -> str: ...
    def get_subfile_names(self) -> tuple[str, ...]: ...
    openRead = open_read
    openWrite = open_write
    openReadWrite = open_read_write
    getMultifileName = get_multifile_name
    setMultifileName = set_multifile_name
    isReadValid = is_read_valid
    isWriteValid = is_write_valid
    needsRepack = needs_repack
    getTimestamp = get_timestamp
    setTimestamp = set_timestamp
    setRecordTimestamp = set_record_timestamp
    getRecordTimestamp = get_record_timestamp
    setScaleFactor = set_scale_factor
    getScaleFactor = get_scale_factor
    setEncryptionFlag = set_encryption_flag
    getEncryptionFlag = get_encryption_flag
    setEncryptionPassword = set_encryption_password
    getEncryptionPassword = get_encryption_password
    setEncryptionAlgorithm = set_encryption_algorithm
    getEncryptionAlgorithm = get_encryption_algorithm
    setEncryptionKeyLength = set_encryption_key_length
    getEncryptionKeyLength = get_encryption_key_length
    setEncryptionIterationCount = set_encryption_iteration_count
    getEncryptionIterationCount = get_encryption_iteration_count
    addSubfile = add_subfile
    updateSubfile = update_subfile
    addSignature = add_signature
    getNumSignatures = get_num_signatures
    getSignatureSubjectName = get_signature_subject_name
    getSignatureFriendlyName = get_signature_friendly_name
    getSignaturePublicKey = get_signature_public_key
    printSignatureCertificate = print_signature_certificate
    writeSignatureCertificate = write_signature_certificate
    validateSignatureCertificate = validate_signature_certificate
    getNumSubfiles = get_num_subfiles
    findSubfile = find_subfile
    hasDirectory = has_directory
    removeSubfile = remove_subfile
    getSubfileName = get_subfile_name
    getSubfileLength = get_subfile_length
    getSubfileTimestamp = get_subfile_timestamp
    isSubfileCompressed = is_subfile_compressed
    isSubfileEncrypted = is_subfile_encrypted
    isSubfileText = is_subfile_text
    getIndexEnd = get_index_end
    getSubfileInternalStart = get_subfile_internal_start
    getSubfileInternalLength = get_subfile_internal_length
    readSubfile = read_subfile
    openReadSubfile = open_read_subfile
    closeReadSubfile = close_read_subfile
    extractSubfile = extract_subfile
    extractSubfileTo = extract_subfile_to
    compareSubfile = compare_subfile
    getMagicNumber = get_magic_number
    setHeaderPrefix = set_header_prefix
    getHeaderPrefix = get_header_prefix
    getSubfileNames = get_subfile_names

class Namable:
    """A base class for all things which can have a name.  The name is either
    empty or nonempty, but it is never NULL.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    name: str
    @overload
    def __init__(self, initial_name: str = ...) -> None: ...
    @overload
    def __init__(self, __param0: Namable) -> None: ...
    def set_name(self, name: str) -> None: ...
    def clear_name(self) -> None: ...
    def has_name(self) -> bool: ...
    def get_name(self) -> str: ...
    def output(self, out: ostream) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    setName = set_name
    clearName = clear_name
    hasName = has_name
    getName = get_name
    getClassType = get_class_type

class OpenSSLWrapper:
    """Provides an interface wrapper around the OpenSSL library, to ensure that
    the library is properly initialized in the application, and to provide some
    hooks into global OpenSSL context data.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def clear_certificates(self) -> None: ...
    def load_certificates(self, filename: _Filename) -> int: ...
    @overload
    def load_certificates_from_pem_ram(self, data: str) -> int: ...
    @overload
    def load_certificates_from_pem_ram(self, data: str, data_size: int) -> int: ...
    @overload
    def load_certificates_from_der_ram(self, data: str) -> int: ...
    @overload
    def load_certificates_from_der_ram(self, data: str, data_size: int) -> int: ...
    def notify_ssl_errors(self) -> None: ...
    def notify_debug_ssl_errors(self) -> None: ...
    @staticmethod
    def get_global_ptr() -> OpenSSLWrapper: ...
    clearCertificates = clear_certificates
    loadCertificates = load_certificates
    loadCertificatesFromPemRam = load_certificates_from_pem_ram
    loadCertificatesFromDerRam = load_certificates_from_der_ram
    notifySslErrors = notify_ssl_errors
    notifyDebugSslErrors = notify_debug_ssl_errors
    getGlobalPtr = get_global_ptr

class SubfileInfo:
    """This class records a particular byte sub-range within an existing file on
    disk.  Generally, the filename is understood as a physical file on disk,
    and not to be looked up via the vfs.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, copy: SubfileInfo) -> None: ...
    @overload
    def __init__(self, file: FileReference, start: int, size: int) -> None: ...
    @overload
    def __init__(self, filename: _Filename, start: int, size: int) -> None: ...
    def assign(self, copy: SubfileInfo) -> SubfileInfo: ...
    def is_empty(self) -> bool: ...
    def get_file(self) -> FileReference: ...
    def get_filename(self) -> Filename: ...
    def get_start(self) -> int: ...
    def get_size(self) -> int: ...
    def output(self, out: ostream) -> None: ...
    isEmpty = is_empty
    getFile = get_file
    getFilename = get_filename
    getStart = get_start
    getSize = get_size

class VirtualFile(TypedReferenceCount):
    """The abstract base class for a file or directory within the
    VirtualFileSystem.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def get_file_system(self) -> VirtualFileSystem: ...
    def get_filename(self) -> Filename: ...
    def get_original_filename(self) -> Filename: ...
    def has_file(self) -> bool: ...
    def is_directory(self) -> bool: ...
    def is_regular_file(self) -> bool: ...
    def is_writable(self) -> bool: ...
    def delete_file(self) -> bool: ...
    def rename_file(self, new_file: VirtualFile) -> bool: ...
    def copy_file(self, new_file: VirtualFile) -> bool: ...
    def scan_directory(self) -> VirtualFileList: ...
    def output(self, out: ostream) -> None: ...
    def ls(self, out: ostream = ...) -> None: ...
    def ls_all(self, out: ostream = ...) -> None: ...
    def read_file(self, auto_unwrap: bool) -> bytes: ...
    def open_read_file(self, auto_unwrap: bool) -> istream: ...
    def close_read_file(self, stream: istream) -> None: ...
    def was_read_successful(self) -> bool: ...
    def write_file(self, data: Any, auto_wrap: bool) -> Any: ...
    def open_write_file(self, auto_wrap: bool, truncate: bool) -> ostream: ...
    def open_append_file(self) -> ostream: ...
    def close_write_file(self, stream: ostream) -> None: ...
    def open_read_write_file(self, truncate: bool) -> iostream: ...
    def open_read_append_file(self) -> iostream: ...
    def close_read_write_file(self, stream: iostream) -> None: ...
    @overload
    def get_file_size(self) -> int: ...
    @overload
    def get_file_size(self, stream: istream) -> int: ...
    def get_timestamp(self) -> int: ...
    def get_system_info(self, info: SubfileInfo) -> bool: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getFileSystem = get_file_system
    getFilename = get_filename
    getOriginalFilename = get_original_filename
    hasFile = has_file
    isDirectory = is_directory
    isRegularFile = is_regular_file
    isWritable = is_writable
    deleteFile = delete_file
    renameFile = rename_file
    copyFile = copy_file
    scanDirectory = scan_directory
    lsAll = ls_all
    readFile = read_file
    openReadFile = open_read_file
    closeReadFile = close_read_file
    wasReadSuccessful = was_read_successful
    writeFile = write_file
    openWriteFile = open_write_file
    openAppendFile = open_append_file
    closeWriteFile = close_write_file
    openReadWriteFile = open_read_write_file
    openReadAppendFile = open_read_append_file
    closeReadWriteFile = close_read_write_file
    getFileSize = get_file_size
    getTimestamp = get_timestamp
    getSystemInfo = get_system_info
    getClassType = get_class_type

class VirtualFileComposite(VirtualFile):
    """A composite directory within the VirtualFileSystem: this maps to more than
    one directory on different mount points.  The resulting directory appears
    to be the union of all the individual simple directories.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getClassType = get_class_type

class VirtualFileMount(TypedReferenceCount):
    """The abstract base class for a mount definition used within a
    VirtualFileSystem.  Normally users don't need to monkey with this class
    directly.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def get_file_system(self) -> VirtualFileSystem: ...
    def get_mount_point(self) -> Filename: ...
    def get_mount_flags(self) -> int: ...
    def output(self, out: ostream) -> None: ...
    def write(self, out: ostream) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getFileSystem = get_file_system
    getMountPoint = get_mount_point
    getMountFlags = get_mount_flags
    getClassType = get_class_type

class VirtualFileMountMultifile(VirtualFileMount):
    """Maps a Multifile's contents into the VirtualFileSystem."""
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, multifile: Multifile) -> None: ...
    def get_multifile(self) -> Multifile: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getMultifile = get_multifile
    getClassType = get_class_type

class VirtualFileMountRamdisk(VirtualFileMount):
    """Simulates an actual directory on disk with in-memory storage.  This is
    useful mainly for performing high level functions that expect disk I/O
    without actually writing files to disk.  Naturally, there are significant
    limits to the size of the files that may be written with this system; and
    "files" written here are not automatically persistent between sessions.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getClassType = get_class_type

class VirtualFileMountSystem(VirtualFileMount):
    """Maps an actual OS directory into the VirtualFileSystem."""
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, physical_filename: _Filename) -> None: ...
    def get_physical_filename(self) -> Filename: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getPhysicalFilename = get_physical_filename
    getClassType = get_class_type

class VirtualFileSimple(VirtualFile):
    """A simple file or directory within the VirtualFileSystem: this maps to
    exactly one file on one mount point.  Most directories, and all regular
    files, are of this kind.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def get_mount(self) -> VirtualFileMount: ...
    def is_implicit_pz_file(self) -> bool: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getMount = get_mount
    isImplicitPzFile = is_implicit_pz_file
    getClassType = get_class_type

class TemporaryFile(FileReference):
    """This is a special kind of FileReference class that automatically deletes
    the file in question when it is deleted.  It is not responsible for
    creating, opening, or closing the file, however.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self, filename: _Filename) -> None: ...
    @overload
    def __init__(self, __param0: TemporaryFile) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getClassType = get_class_type

class IDecompressStream(istream):
    """An input stream object that uses zlib to decompress (inflate) the input
    from another source stream on-the-fly.
    
    Attach an IDecompressStream to an existing istream that provides compressed
    data, and read the corresponding uncompressed data from the
    IDecompressStream.
    
    Seeking is not supported.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, source: istream, owns_source: bool) -> None: ...
    def open(self, source: istream, owns_source: bool) -> IDecompressStream: ...
    def close(self) -> IDecompressStream: ...

class OCompressStream(ostream):
    """An input stream object that uses zlib to compress (deflate) data to another
    destination stream on-the-fly.
    
    Attach an OCompressStream to an existing ostream that will accept
    compressed data, and write your uncompressed source data to the
    OCompressStream.
    
    Seeking is not supported.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, dest: ostream, owns_dest: bool, compression_level: int = ...) -> None: ...
    def open(self, dest: ostream, owns_dest: bool, compression_level: int = ...) -> OCompressStream: ...
    def close(self) -> OCompressStream: ...

class VirtualFileList(ReferenceCount):
    """A list of VirtualFiles, as returned by VirtualFile::scan_directory()."""
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, __param0: VirtualFileList) -> None: ...
    def __getitem__(self, n: int) -> VirtualFile: ...
    def __len__(self) -> int: ...
    def __iadd__(self, other: VirtualFileList) -> VirtualFileList: ...
    def __add__(self, other: VirtualFileList) -> VirtualFileList: ...
    def get_num_files(self) -> int: ...
    def get_file(self, n: int) -> VirtualFile: ...
    def get_files(self) -> tuple[VirtualFile, ...]: ...
    getNumFiles = get_num_files
    getFile = get_file
    getFiles = get_files

class VirtualFileSystem:
    """A hierarchy of directories and files that appears to be one continuous file
    system, even though the files may originate from several different sources
    that may not be related to the actual OS's file system.
    
    For instance, a VirtualFileSystem can transparently mount one or more
    Multifiles as their own subdirectory hierarchies.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    MF_read_only: ClassVar[Literal[2]]
    @property
    def mounts(self) -> Sequence[PointerTo_VirtualFileMount]: ...
    def __init__(self) -> None: ...
    @overload
    def mount(self, multifile: Multifile, mount_point: _Filename, flags: int) -> bool: ...
    @overload
    def mount(self, mount: VirtualFileMount, mount_point: _Filename, flags: int) -> bool: ...
    @overload
    def mount(self, physical_filename: _Filename, mount_point: _Filename, flags: int, password: str = ...) -> bool: ...
    def mount_loop(self, virtual_filename: _Filename, mount_point: _Filename, flags: int, password: str = ...) -> bool: ...
    @overload
    def unmount(self, physical_filename: _Filename) -> int: ...
    @overload
    def unmount(self, multifile: Multifile) -> int: ...
    @overload
    def unmount(self, mount: VirtualFileMount) -> int: ...
    def unmount_point(self, mount_point: _Filename) -> int: ...
    def unmount_all(self) -> int: ...
    def get_num_mounts(self) -> int: ...
    def get_mount(self, n: int) -> VirtualFileMount: ...
    def chdir(self, new_directory: _Filename) -> bool: ...
    def get_cwd(self) -> Filename: ...
    def make_directory(self, filename: _Filename) -> bool: ...
    def make_directory_full(self, filename: _Filename) -> bool: ...
    def get_file(self, filename: _Filename, status_only: bool = ...) -> VirtualFile: ...
    def create_file(self, filename: _Filename) -> VirtualFile: ...
    def find_file(self, filename: _Filename, searchpath: ConfigVariableSearchPath | DSearchPath, status_only: bool = ...) -> VirtualFile: ...
    def delete_file(self, filename: _Filename) -> bool: ...
    def rename_file(self, orig_filename: _Filename, new_filename: _Filename) -> bool: ...
    def copy_file(self, orig_filename: _Filename, new_filename: _Filename) -> bool: ...
    def resolve_filename(self, filename: _Filename, searchpath: ConfigVariableSearchPath | DSearchPath, default_extension: str = ...) -> bool: ...
    def find_all_files(self, filename: _Filename, searchpath: ConfigVariableSearchPath | DSearchPath, results: DSearchPath.Results) -> int: ...
    def exists(self, filename: _Filename) -> bool: ...
    def is_directory(self, filename: _Filename) -> bool: ...
    def is_regular_file(self, filename: _Filename) -> bool: ...
    def scan_directory(self, filename: _Filename) -> VirtualFileList: ...
    def ls(self, filename: _Filename) -> None: ...
    def ls_all(self, filename: _Filename) -> None: ...
    def write(self, out: ostream) -> None: ...
    @staticmethod
    def get_global_ptr() -> VirtualFileSystem: ...
    def read_file(self, filename: _Filename, auto_unwrap: bool) -> Any: ...
    def open_read_file(self, filename: _Filename, auto_unwrap: bool) -> istream: ...
    @staticmethod
    def close_read_file(stream: istream) -> None: ...
    def write_file(self, filename: _Filename, data: Any, auto_wrap: bool) -> Any: ...
    def open_write_file(self, filename: _Filename, auto_wrap: bool, truncate: bool) -> ostream: ...
    def open_append_file(self, filename: _Filename) -> ostream: ...
    @staticmethod
    def close_write_file(stream: ostream) -> None: ...
    def open_read_write_file(self, filename: _Filename, truncate: bool) -> iostream: ...
    def open_read_append_file(self, filename: _Filename) -> iostream: ...
    @staticmethod
    def close_read_write_file(stream: iostream) -> None: ...
    def get_mounts(self) -> tuple[VirtualFileMount, ...]: ...
    mountLoop = mount_loop
    unmountPoint = unmount_point
    unmountAll = unmount_all
    getNumMounts = get_num_mounts
    getMount = get_mount
    getCwd = get_cwd
    makeDirectory = make_directory
    makeDirectoryFull = make_directory_full
    getFile = get_file
    createFile = create_file
    findFile = find_file
    deleteFile = delete_file
    renameFile = rename_file
    copyFile = copy_file
    resolveFilename = resolve_filename
    findAllFiles = find_all_files
    isDirectory = is_directory
    isRegularFile = is_regular_file
    scanDirectory = scan_directory
    lsAll = ls_all
    getGlobalPtr = get_global_ptr
    readFile = read_file
    openReadFile = open_read_file
    closeReadFile = close_read_file
    writeFile = write_file
    openWriteFile = open_write_file
    openAppendFile = open_append_file
    closeWriteFile = close_write_file
    openReadWriteFile = open_read_write_file
    openReadAppendFile = open_read_append_file
    closeReadWriteFile = close_read_write_file
    getMounts = get_mounts
    MFReadOnly = MF_read_only

class PointerTo_VirtualFileMount(PointerToBase_VirtualFileMount):
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, copy: VirtualFileMount) -> None: ...
    @overload
    def __init__(self, ptr: VirtualFileMount) -> None: ...
    @overload
    def __init__(self, __param0: None) -> None: ...
    def p(self) -> VirtualFileMount: ...
    @overload
    def assign(self, copy: VirtualFileMount) -> PointerTo_VirtualFileMount: ...
    @overload
    def assign(self, ptr: VirtualFileMount) -> PointerTo_VirtualFileMount: ...
    def is_null(self) -> bool: ...
    def clear(self) -> None: ...
    isNull = is_null

class PointerToBase_VirtualFileMount(PointerToVoid):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def clear(self) -> None: ...
    def output(self, out: ostream) -> None: ...

class TrueClock:
    """An interface to whatever real-time clock we might have available in the
    current environment.  There is only one TrueClock in existence, and it
    constructs itself.
    
    The TrueClock returns elapsed real time in seconds since some undefined
    epoch.  Since it is not defined at what time precisely the clock indicates
    zero, this value can only be meaningfully used to measure elapsed time, by
    sampling it at two different times and subtracting.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def long_time(self) -> float: ...
    @property
    def short_time(self) -> float: ...
    @property
    def short_raw_time(self) -> float: ...
    @property
    def error_count(self) -> int: ...
    def get_long_time(self) -> float: ...
    def get_short_time(self) -> float: ...
    def get_short_raw_time(self) -> float: ...
    def get_error_count(self) -> int: ...
    @staticmethod
    def get_global_ptr() -> TrueClock: ...
    def set_cpu_affinity(self, mask: int) -> bool: ...
    getLongTime = get_long_time
    getShortTime = get_short_time
    getShortRawTime = get_short_raw_time
    getErrorCount = get_error_count
    getGlobalPtr = get_global_ptr
    setCpuAffinity = set_cpu_affinity

class Patchfile:
    DtoolClassDict: ClassVar[dict[str, Any]]
    allow_multifile: bool
    footprint_length: int
    @property
    def progress(self) -> float: ...
    @property
    def source_hash(self) -> HashVal: ...
    @property
    def result_hash(self) -> HashVal: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, buffer: Buffer) -> None: ...
    def build(self, file_orig: _Filename, file_new: _Filename, patch_name: _Filename) -> bool: ...
    def read_header(self, patch_file: _Filename) -> int: ...
    @overload
    def initiate(self, patch_file: _Filename, file: _Filename) -> int: ...
    @overload
    def initiate(self, patch_file: _Filename, orig_file: _Filename, target_file: _Filename) -> int: ...
    def run(self) -> int: ...
    @overload
    def apply(self, patch_file: _Filename, file: _Filename) -> bool: ...
    @overload
    def apply(self, patch_file: _Filename, orig_file: _Filename, target_file: _Filename) -> bool: ...
    def get_progress(self) -> float: ...
    def set_allow_multifile(self, allow_multifile: bool) -> None: ...
    def get_allow_multifile(self) -> bool: ...
    def set_footprint_length(self, length: int) -> None: ...
    def get_footprint_length(self) -> int: ...
    def reset_footprint_length(self) -> None: ...
    def has_source_hash(self) -> bool: ...
    def get_source_hash(self) -> HashVal: ...
    def get_result_hash(self) -> HashVal: ...
    readHeader = read_header
    getProgress = get_progress
    setAllowMultifile = set_allow_multifile
    getAllowMultifile = get_allow_multifile
    setFootprintLength = set_footprint_length
    getFootprintLength = get_footprint_length
    resetFootprintLength = reset_footprint_length
    hasSourceHash = has_source_hash
    getSourceHash = get_source_hash
    getResultHash = get_result_hash

class ProfileTimer:
    """ProfileTimer
    
        HowTo:
          Create a ProfileTimer and hold onto it.
          Call init() whenever you like (the timer doesn't
            start yet).
          Call on() to start the timer.
          While the timer is on, call mark() at each point of interest,
            in the code you are timing.
          You can turn the timer off() and on() to skip things you
            don't want to time.
          When your timing is finished, call printTo() to see the
            results (e.g. myTimer.printTo(cerr)).
    
        Notes:
          You should be able to time things down to the millisecond
          well enough, but if you call on() and off() within micro-
          seconds of each other, I don't think you'll get very good
          results.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self, name: str = ..., maxEntries: int = ...) -> None: ...
    @overload
    def __init__(self, other: ProfileTimer) -> None: ...
    def init(self, name: str, maxEntries: int = ...) -> None: ...
    def on(self) -> None: ...
    def mark(self, tag: str) -> None: ...
    @overload
    def off(self) -> None: ...
    @overload
    def off(self, tag: str) -> None: ...
    def getTotalTime(self) -> float: ...
    @staticmethod
    def consolidateAllTo(out: ostream = ...) -> None: ...
    def consolidateTo(self, out: ostream = ...) -> None: ...
    @staticmethod
    def printAllTo(out: ostream = ...) -> None: ...
    def printTo(self, out: ostream = ...) -> None: ...

class WeakPointerToVoid(PointerToVoid):
    """This is the specialization of PointerToVoid for weak pointers.  It needs an
    additional flag to indicate that the pointer has been deleted.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def was_deleted(self) -> bool: ...
    def is_valid_pointer(self) -> bool: ...
    wasDeleted = was_deleted
    isValidPointer = is_valid_pointer

class WindowsRegistry:
    """This class provides a hook to Python to read and write strings and integers
    to the windows registry.  It automatically converts strings from utf-8
    encoding and stores them in Unicode (and conversely reconverts them on
    retrieval).
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    rl_machine: ClassVar[Literal[0]]
    rl_user: ClassVar[Literal[1]]
    T_none: ClassVar[Literal[0]]
    T_int: ClassVar[Literal[1]]
    T_string: ClassVar[Literal[2]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, __param0: WindowsRegistry) -> None: ...
    @staticmethod
    def set_string_value(key: str, name: str, value: str, rl: _WindowsRegistry_RegLevel = ...) -> bool: ...
    @staticmethod
    def set_int_value(key: str, name: str, value: int, rl: _WindowsRegistry_RegLevel = ...) -> bool: ...
    @staticmethod
    def get_key_type(key: str, name: str, rl: _WindowsRegistry_RegLevel = ...) -> _WindowsRegistry_Type: ...
    @staticmethod
    def get_string_value(key: str, name: str, default_value: str, rl: _WindowsRegistry_RegLevel = ...) -> str: ...
    @staticmethod
    def get_int_value(key: str, name: str, default_value: int, rl: _WindowsRegistry_RegLevel = ...) -> int: ...
    setStringValue = set_string_value
    setIntValue = set_int_value
    getKeyType = get_key_type
    getStringValue = get_string_value
    getIntValue = get_int_value
    RlMachine = rl_machine
    RlUser = rl_user
    TNone = T_none
    TInt = T_int
    TString = T_string

EU_http_redirect: Literal[7]
EU_eof: Literal[6]
EU_network_no_data: Literal[5]
EU_write_ram: Literal[4]
EU_write: Literal[3]
EU_ok: Literal[2]
EU_success: Literal[1]
EU_error_abort: Literal[-1]
EU_error_file_empty: Literal[-2]
EU_error_file_invalid: Literal[-3]
EU_error_invalid_checksum: Literal[-4]
EU_error_network_dead: Literal[-30]
EU_error_network_unreachable: Literal[-31]
EU_error_network_disconnected: Literal[-32]
EU_error_network_timeout: Literal[-33]
EU_error_network_no_data: Literal[-34]
EU_error_network_disconnected_locally: Literal[-40]
EU_error_network_buffer_overflow: Literal[-41]
EU_error_network_disk_quota_exceeded: Literal[-42]
EU_error_network_remote_host_disconnected: Literal[-50]
EU_error_network_remote_host_down: Literal[-51]
EU_error_network_remote_host_unreachable: Literal[-52]
EU_error_network_remote_host_not_found: Literal[-53]
EU_error_network_remote_host_no_response: Literal[-54]
EU_error_write_out_of_files: Literal[-60]
EU_error_write_out_of_memory: Literal[-61]
EU_error_write_sharing_violation: Literal[-62]
EU_error_write_disk_full: Literal[-63]
EU_error_write_disk_not_found: Literal[-64]
EU_error_write_disk_sector_not_found: Literal[-65]
EU_error_write_disk_fault: Literal[-66]
EU_error_write_file_rename: Literal[-67]
EU_error_http_server_timeout: Literal[-70]
EU_error_http_gateway_timeout: Literal[-71]
EU_error_http_service_unavailable: Literal[-72]
EU_error_http_proxy_authentication: Literal[-73]
EU_error_zlib: Literal[-80]
def compress_string(source: str, compression_level: int) -> str: ...
def decompress_string(source: str) -> str: ...
def compress_file(source: _Filename, dest: _Filename, compression_level: int) -> bool: ...
def decompress_file(source: _Filename, dest: _Filename) -> bool: ...
def compress_stream(source: istream, dest: ostream, compression_level: int) -> bool: ...
def decompress_stream(source: istream, dest: ostream) -> bool: ...
def copy_stream(source: istream, dest: ostream) -> bool: ...
def encrypt_string(source: str, password: str, algorithm: str = ..., key_length: int = ..., iteration_count: int = ...) -> str: ...
def decrypt_string(source: str, password: str) -> str: ...
def encrypt_file(source: _Filename, dest: _Filename, password: str, algorithm: str = ..., key_length: int = ..., iteration_count: int = ...) -> bool: ...
def decrypt_file(source: _Filename, dest: _Filename, password: str) -> bool: ...
def encrypt_stream(source: istream, dest: ostream, password: str, algorithm: str = ..., key_length: int = ..., iteration_count: int = ...) -> bool: ...
def decrypt_stream(source: istream, dest: ostream, password: str) -> bool: ...
def error_to_text(err: _ErrorUtilCode) -> str: ...
def get_write_error() -> int: ...
def handle_socket_error() -> str: ...
def get_network_error() -> int: ...
def password_hash(password: str, salt: str, iters: int, keylen: int) -> str: ...
compressString = compress_string
decompressString = decompress_string
compressFile = compress_file
decompressFile = decompress_file
compressStream = compress_stream
decompressStream = decompress_stream
copyStream = copy_stream
encryptString = encrypt_string
decryptString = decrypt_string
encryptFile = encrypt_file
decryptFile = decrypt_file
encryptStream = encrypt_stream
decryptStream = decrypt_stream
errorToText = error_to_text
getWriteError = get_write_error
handleSocketError = handle_socket_error
getNetworkError = get_network_error
passwordHash = password_hash
CPTA_double = ConstPointerToArray_double
CPTADouble = CPTA_double
ConstPointerToArrayDouble = ConstPointerToArray_double
PointerToArrayBaseDouble = PointerToArrayBase_double
PointerToBaseReferenceCountedVectorDouble = PointerToBase_ReferenceCountedVector_double
CPTA_float = ConstPointerToArray_float
CPTAFloat = CPTA_float
ConstPointerToArrayFloat = ConstPointerToArray_float
PointerToArrayBaseFloat = PointerToArrayBase_float
PointerToBaseReferenceCountedVectorFloat = PointerToBase_ReferenceCountedVector_float
CPTA_int = ConstPointerToArray_int
CPTAInt = CPTA_int
ConstPointerToArrayInt = ConstPointerToArray_int
PointerToArrayBaseInt = PointerToArrayBase_int
PointerToBaseReferenceCountedVectorInt = PointerToBase_ReferenceCountedVector_int
CPTA_uchar = ConstPointerToArray_unsigned_char
CPTAUchar = CPTA_uchar
ConstPointerToArrayUnsignedChar = ConstPointerToArray_unsigned_char
PointerToArrayBaseUnsignedChar = PointerToArrayBase_unsigned_char
PointerToBaseReferenceCountedVectorUnsignedChar = PointerToBase_ReferenceCountedVector_unsigned_char
PTA_double = PointerToArray_double
PTADouble = PTA_double
PointerToArrayDouble = PointerToArray_double
PTA_float = PointerToArray_float
PTAFloat = PTA_float
PointerToArrayFloat = PointerToArray_float
PTA_int = PointerToArray_int
PTAInt = PTA_int
PointerToArrayInt = PointerToArray_int
PTA_uchar = PointerToArray_unsigned_char
PTAUchar = PTA_uchar
PointerToArrayUnsignedChar = PointerToArray_unsigned_char
EUHttpRedirect = EU_http_redirect
EUEof = EU_eof
EUNetworkNoData = EU_network_no_data
EUWriteRam = EU_write_ram
EUWrite = EU_write
EUOk = EU_ok
EUSuccess = EU_success
EUErrorAbort = EU_error_abort
EUErrorFileEmpty = EU_error_file_empty
EUErrorFileInvalid = EU_error_file_invalid
EUErrorInvalidChecksum = EU_error_invalid_checksum
EUErrorNetworkDead = EU_error_network_dead
EUErrorNetworkUnreachable = EU_error_network_unreachable
EUErrorNetworkDisconnected = EU_error_network_disconnected
EUErrorNetworkTimeout = EU_error_network_timeout
EUErrorNetworkNoData = EU_error_network_no_data
EUErrorNetworkDisconnectedLocally = EU_error_network_disconnected_locally
EUErrorNetworkBufferOverflow = EU_error_network_buffer_overflow
EUErrorNetworkDiskQuotaExceeded = EU_error_network_disk_quota_exceeded
EUErrorNetworkRemoteHostDisconnected = EU_error_network_remote_host_disconnected
EUErrorNetworkRemoteHostDown = EU_error_network_remote_host_down
EUErrorNetworkRemoteHostUnreachable = EU_error_network_remote_host_unreachable
EUErrorNetworkRemoteHostNotFound = EU_error_network_remote_host_not_found
EUErrorNetworkRemoteHostNoResponse = EU_error_network_remote_host_no_response
EUErrorWriteOutOfFiles = EU_error_write_out_of_files
EUErrorWriteOutOfMemory = EU_error_write_out_of_memory
EUErrorWriteSharingViolation = EU_error_write_sharing_violation
EUErrorWriteDiskFull = EU_error_write_disk_full
EUErrorWriteDiskNotFound = EU_error_write_disk_not_found
EUErrorWriteDiskSectorNotFound = EU_error_write_disk_sector_not_found
EUErrorWriteDiskFault = EU_error_write_disk_fault
EUErrorWriteFileRename = EU_error_write_file_rename
EUErrorHttpServerTimeout = EU_error_http_server_timeout
EUErrorHttpGatewayTimeout = EU_error_http_gateway_timeout
EUErrorHttpServiceUnavailable = EU_error_http_service_unavailable
EUErrorHttpProxyAuthentication = EU_error_http_proxy_authentication
EUErrorZlib = EU_error_zlib
PointerToVirtualFileMount = PointerTo_VirtualFileMount
PointerToBaseVirtualFileMount = PointerToBase_VirtualFileMount
PTA_stdfloat = PointerToArray_float
PTAStdfloat = PTA_stdfloat
CPTA_stdfloat = ConstPointerToArray_float
CPTAStdfloat = CPTA_stdfloat
