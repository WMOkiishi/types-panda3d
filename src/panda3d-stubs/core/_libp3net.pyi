from collections.abc import Sequence
from typing import Any, ClassVar, overload
from panda3d.core import (
    Datagram,
    DatagramGenerator,
    DatagramSink,
    PointerToVoid,
    ReferenceCount,
    Socket_Address,
    Socket_IP,
    TypeHandle,
    ostream,
)

class PointerTo_Connection(PointerToBase_Connection):
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, ptr: Connection) -> None: ...
    @overload
    def __init__(self, copy: Connection) -> None: ...
    @overload
    def __init__(self, __param0: None) -> None: ...
    def p(self) -> Connection: ...
    @overload
    def assign(self, ptr: Connection) -> PointerTo_Connection: ...
    @overload
    def assign(self, copy: Connection) -> PointerTo_Connection: ...
    def is_null(self) -> bool: ...
    def clear(self) -> None: ...
    isNull = is_null

class PointerToBase_Connection(PointerToVoid):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def clear(self) -> None: ...
    def output(self, out: ostream) -> None: ...

class NetAddress:
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, __param0: NetAddress) -> None: ...
    @overload
    def __init__(self, addr: Socket_Address) -> None: ...
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...
    def set_any(self, port: int) -> bool: ...
    def set_localhost(self, port: int) -> bool: ...
    def set_broadcast(self, port: int) -> bool: ...
    def set_host(self, hostname: str, port: int) -> bool: ...
    def clear(self) -> None: ...
    def get_port(self) -> int: ...
    def set_port(self, port: int) -> None: ...
    def get_ip_string(self) -> str: ...
    def is_any(self) -> bool: ...
    def get_ip(self) -> int: ...
    def get_ip_component(self, n: int) -> str: ...
    def get_addr(self) -> Socket_Address: ...
    def output(self, out: ostream) -> None: ...
    def get_hash(self) -> int: ...
    setAny = set_any
    setLocalhost = set_localhost
    setBroadcast = set_broadcast
    setHost = set_host
    getPort = get_port
    setPort = set_port
    getIpString = get_ip_string
    isAny = is_any
    getIp = get_ip
    getIpComponent = get_ip_component
    getAddr = get_addr
    getHash = get_hash

class Connection(ReferenceCount):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, manager: ConnectionManager, socket: Socket_IP) -> None: ...
    def get_address(self) -> NetAddress: ...
    def get_manager(self) -> ConnectionManager: ...
    def get_socket(self) -> Socket_IP: ...
    def set_collect_tcp(self, collect_tcp: bool) -> None: ...
    def get_collect_tcp(self) -> bool: ...
    def set_collect_tcp_interval(self, interval: float) -> None: ...
    def get_collect_tcp_interval(self) -> float: ...
    def consider_flush(self) -> bool: ...
    def flush(self) -> bool: ...
    def set_linger(self, flag: bool, time: float) -> None: ...
    def set_reuse_addr(self, flag: bool) -> None: ...
    def set_keep_alive(self, flag: bool) -> None: ...
    def set_recv_buffer_size(self, size: int) -> None: ...
    def set_send_buffer_size(self, size: int) -> None: ...
    def set_ip_time_to_live(self, ttl: int) -> None: ...
    def set_ip_type_of_service(self, tos: int) -> None: ...
    def set_no_delay(self, flag: bool) -> None: ...
    def set_max_segment(self, size: int) -> None: ...
    getAddress = get_address
    getManager = get_manager
    getSocket = get_socket
    setCollectTcp = set_collect_tcp
    getCollectTcp = get_collect_tcp
    setCollectTcpInterval = set_collect_tcp_interval
    getCollectTcpInterval = get_collect_tcp_interval
    considerFlush = consider_flush
    setLinger = set_linger
    setReuseAddr = set_reuse_addr
    setKeepAlive = set_keep_alive
    setRecvBufferSize = set_recv_buffer_size
    setSendBufferSize = set_send_buffer_size
    setIpTimeToLive = set_ip_time_to_live
    setIpTypeOfService = set_ip_type_of_service
    setNoDelay = set_no_delay
    setMaxSegment = set_max_segment

class ConnectionReader:
    DtoolClassDict: ClassVar[dict[str, Any]]
    def add_connection(self, connection: Connection) -> bool: ...
    def remove_connection(self, connection: Connection) -> bool: ...
    def is_connection_ok(self, connection: Connection) -> bool: ...
    def poll(self) -> None: ...
    def get_manager(self) -> ConnectionManager: ...
    def is_polling(self) -> bool: ...
    def get_num_threads(self) -> int: ...
    def set_raw_mode(self, mode: bool) -> None: ...
    def get_raw_mode(self) -> bool: ...
    def set_tcp_header_size(self, tcp_header_size: int) -> None: ...
    def get_tcp_header_size(self) -> int: ...
    def shutdown(self) -> None: ...
    addConnection = add_connection
    removeConnection = remove_connection
    isConnectionOk = is_connection_ok
    getManager = get_manager
    isPolling = is_polling
    getNumThreads = get_num_threads
    setRawMode = set_raw_mode
    getRawMode = get_raw_mode
    setTcpHeaderSize = set_tcp_header_size
    getTcpHeaderSize = get_tcp_header_size

class ConnectionListener(ConnectionReader):
    DtoolClassDict: ClassVar[dict[str, Any]]

class NetDatagram(Datagram):
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, copy: Datagram) -> None: ...
    def assign(self, copy: Datagram) -> NetDatagram: ...
    def set_connection(self, connection: Connection) -> None: ...
    def get_connection(self) -> Connection: ...
    def set_address(self, address: NetAddress) -> None: ...
    def get_address(self) -> NetAddress: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    setConnection = set_connection
    getConnection = get_connection
    setAddress = set_address
    getAddress = get_address
    getClassType = get_class_type

class ConnectionManager:
    class Interface:
        DtoolClassDict: ClassVar[dict[str, Any]]
        def __init__(self, __param0: ConnectionManager.Interface) -> None: ...
        def get_name(self) -> str: ...
        def get_mac_address(self) -> str: ...
        def has_ip(self) -> bool: ...
        def get_ip(self) -> NetAddress: ...
        def has_netmask(self) -> bool: ...
        def get_netmask(self) -> NetAddress: ...
        def has_broadcast(self) -> bool: ...
        def get_broadcast(self) -> NetAddress: ...
        def has_p2p(self) -> bool: ...
        def get_p2p(self) -> NetAddress: ...
        def output(self, out: ostream) -> None: ...
        getName = get_name
        getMacAddress = get_mac_address
        hasIp = has_ip
        getIp = get_ip
        hasNetmask = has_netmask
        getNetmask = get_netmask
        hasBroadcast = has_broadcast
        getBroadcast = get_broadcast
        hasP2p = has_p2p
        getP2p = get_p2p
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def host_name(self) -> str: ...
    @property
    def interfaces(self) -> Sequence[ConnectionManager.Interface]: ...
    def __init__(self) -> None: ...
    @overload
    def open_UDP_connection(self, port: int = ...) -> Connection: ...
    @overload
    def open_UDP_connection(self, hostname: str, port: int, for_broadcast: bool = ...) -> Connection: ...
    @overload
    def open_TCP_server_rendezvous(self, address: NetAddress, backlog: int) -> Connection: ...
    @overload
    def open_TCP_server_rendezvous(self, port: int, backlog: int) -> Connection: ...
    @overload
    def open_TCP_server_rendezvous(self, hostname: str, port: int, backlog: int) -> Connection: ...
    @overload
    def open_TCP_client_connection(self, address: NetAddress, timeout_ms: int) -> Connection: ...
    @overload
    def open_TCP_client_connection(self, hostname: str, port: int, timeout_ms: int) -> Connection: ...
    def close_connection(self, connection: Connection) -> bool: ...
    def wait_for_readers(self, timeout: float) -> bool: ...
    @staticmethod
    def get_host_name() -> str: ...
    def scan_interfaces(self) -> None: ...
    def get_num_interfaces(self) -> int: ...
    def get_interface(self, n: int) -> ConnectionManager.Interface: ...
    def get_interfaces(self) -> tuple[ConnectionManager.Interface, ...]: ...
    openUDPConnection = open_UDP_connection
    openTCPServerRendezvous = open_TCP_server_rendezvous
    openTCPClientConnection = open_TCP_client_connection
    closeConnection = close_connection
    waitForReaders = wait_for_readers
    getHostName = get_host_name
    scanInterfaces = scan_interfaces
    getNumInterfaces = get_num_interfaces
    getInterface = get_interface
    getInterfaces = get_interfaces

class ConnectionWriter:
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, manager: ConnectionManager, num_threads: int, thread_name: str = ...) -> None: ...
    def set_max_queue_size(self, max_size: int) -> None: ...
    def get_max_queue_size(self) -> int: ...
    def get_current_queue_size(self) -> int: ...
    @overload
    def send(self, datagram: Datagram, connection: Connection, block: bool = ...) -> bool: ...
    @overload
    def send(self, datagram: Datagram, connection: Connection, address: NetAddress, block: bool = ...) -> bool: ...
    def is_valid_for_udp(self, datagram: Datagram) -> bool: ...
    def get_manager(self) -> ConnectionManager: ...
    def is_immediate(self) -> bool: ...
    def get_num_threads(self) -> int: ...
    def set_raw_mode(self, mode: bool) -> None: ...
    def get_raw_mode(self) -> bool: ...
    def set_tcp_header_size(self, tcp_header_size: int) -> None: ...
    def get_tcp_header_size(self) -> int: ...
    def shutdown(self) -> None: ...
    setMaxQueueSize = set_max_queue_size
    getMaxQueueSize = get_max_queue_size
    getCurrentQueueSize = get_current_queue_size
    isValidForUdp = is_valid_for_udp
    getManager = get_manager
    isImmediate = is_immediate
    getNumThreads = get_num_threads
    setRawMode = set_raw_mode
    getRawMode = get_raw_mode
    setTcpHeaderSize = set_tcp_header_size
    getTcpHeaderSize = get_tcp_header_size

class DatagramGeneratorNet(DatagramGenerator, ConnectionReader, QueuedReturn_Datagram):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, manager: ConnectionManager, num_threads: int) -> None: ...
    def upcast_to_DatagramGenerator(self) -> DatagramGenerator: ...
    def upcast_to_ConnectionReader(self) -> ConnectionReader: ...
    def upcast_to_QueuedReturn_Datagram(self) -> QueuedReturn_Datagram: ...
    def get_datagram(self, data: Datagram) -> bool: ...
    def is_eof(self) -> bool: ...
    def is_error(self) -> bool: ...
    upcastToDatagramGenerator = upcast_to_DatagramGenerator
    upcastToConnectionReader = upcast_to_ConnectionReader
    upcastToQueuedReturnDatagram = upcast_to_QueuedReturn_Datagram
    getDatagram = get_datagram
    isEof = is_eof
    isError = is_error

class QueuedReturn_Datagram:
    DtoolClassDict: ClassVar[dict[str, Any]]
    def set_max_queue_size(self, max_size: int) -> None: ...
    def get_max_queue_size(self) -> int: ...
    def get_current_queue_size(self) -> int: ...
    def get_overflow_flag(self) -> bool: ...
    def reset_overflow_flag(self) -> None: ...
    setMaxQueueSize = set_max_queue_size
    getMaxQueueSize = get_max_queue_size
    getCurrentQueueSize = get_current_queue_size
    getOverflowFlag = get_overflow_flag
    resetOverflowFlag = reset_overflow_flag

class DatagramSinkNet(DatagramSink, ConnectionWriter):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, manager: ConnectionManager, num_threads: int) -> None: ...
    def upcast_to_DatagramSink(self) -> DatagramSink: ...
    def upcast_to_ConnectionWriter(self) -> ConnectionWriter: ...
    def set_target(self, connection: Connection) -> None: ...
    def get_target(self) -> Connection: ...
    def put_datagram(self, data: Datagram) -> bool: ...
    def is_error(self) -> bool: ...
    def flush(self) -> None: ...
    upcastToDatagramSink = upcast_to_DatagramSink
    upcastToConnectionWriter = upcast_to_ConnectionWriter
    setTarget = set_target
    getTarget = get_target
    putDatagram = put_datagram
    isError = is_error

class QueuedConnectionListener(ConnectionListener, QueuedReturn_ConnectionListenerData):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, manager: ConnectionManager, num_threads: int) -> None: ...
    def upcast_to_ConnectionListener(self) -> ConnectionListener: ...
    def upcast_to_QueuedReturn_ConnectionListenerData(self) -> QueuedReturn_ConnectionListenerData: ...
    def new_connection_available(self) -> bool: ...
    @overload
    def get_new_connection(self, new_connection: Connection | PointerTo_Connection | None) -> bool: ...
    @overload
    def get_new_connection(self, rendezvous: Connection | PointerTo_Connection | None, address: NetAddress, new_connection: Connection | PointerTo_Connection | None) -> bool: ...
    upcastToConnectionListener = upcast_to_ConnectionListener
    upcastToQueuedReturnConnectionListenerData = upcast_to_QueuedReturn_ConnectionListenerData
    newConnectionAvailable = new_connection_available
    getNewConnection = get_new_connection

class QueuedReturn_ConnectionListenerData:
    DtoolClassDict: ClassVar[dict[str, Any]]
    def set_max_queue_size(self, max_size: int) -> None: ...
    def get_max_queue_size(self) -> int: ...
    def get_current_queue_size(self) -> int: ...
    def get_overflow_flag(self) -> bool: ...
    def reset_overflow_flag(self) -> None: ...
    setMaxQueueSize = set_max_queue_size
    getMaxQueueSize = get_max_queue_size
    getCurrentQueueSize = get_current_queue_size
    getOverflowFlag = get_overflow_flag
    resetOverflowFlag = reset_overflow_flag

class QueuedConnectionManager(ConnectionManager, QueuedReturn_PointerTo_Connection):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self) -> None: ...
    def upcast_to_ConnectionManager(self) -> ConnectionManager: ...
    def upcast_to_QueuedReturn_PointerTo_Connection(self) -> QueuedReturn_PointerTo_Connection: ...
    def reset_connection_available(self) -> bool: ...
    def get_reset_connection(self, connection: Connection | PointerTo_Connection | None) -> bool: ...
    upcastToConnectionManager = upcast_to_ConnectionManager
    upcastToQueuedReturnPointerToConnection = upcast_to_QueuedReturn_PointerTo_Connection
    resetConnectionAvailable = reset_connection_available
    getResetConnection = get_reset_connection

class QueuedReturn_PointerTo_Connection:
    DtoolClassDict: ClassVar[dict[str, Any]]
    def set_max_queue_size(self, max_size: int) -> None: ...
    def get_max_queue_size(self) -> int: ...
    def get_current_queue_size(self) -> int: ...
    def get_overflow_flag(self) -> bool: ...
    def reset_overflow_flag(self) -> None: ...
    setMaxQueueSize = set_max_queue_size
    getMaxQueueSize = get_max_queue_size
    getCurrentQueueSize = get_current_queue_size
    getOverflowFlag = get_overflow_flag
    resetOverflowFlag = reset_overflow_flag

class QueuedConnectionReader(ConnectionReader, QueuedReturn_NetDatagram):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, manager: ConnectionManager, num_threads: int) -> None: ...
    def upcast_to_ConnectionReader(self) -> ConnectionReader: ...
    def upcast_to_QueuedReturn_NetDatagram(self) -> QueuedReturn_NetDatagram: ...
    def data_available(self) -> bool: ...
    def get_data(self, result: Datagram) -> bool: ...
    upcastToConnectionReader = upcast_to_ConnectionReader
    upcastToQueuedReturnNetDatagram = upcast_to_QueuedReturn_NetDatagram
    dataAvailable = data_available
    getData = get_data

class QueuedReturn_NetDatagram:
    DtoolClassDict: ClassVar[dict[str, Any]]
    def set_max_queue_size(self, max_size: int) -> None: ...
    def get_max_queue_size(self) -> int: ...
    def get_current_queue_size(self) -> int: ...
    def get_overflow_flag(self) -> bool: ...
    def reset_overflow_flag(self) -> None: ...
    setMaxQueueSize = set_max_queue_size
    getMaxQueueSize = get_max_queue_size
    getCurrentQueueSize = get_current_queue_size
    getOverflowFlag = get_overflow_flag
    resetOverflowFlag = reset_overflow_flag

class RecentConnectionReader(ConnectionReader):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, manager: ConnectionManager) -> None: ...
    def data_available(self) -> bool: ...
    def get_data(self, result: Datagram) -> bool: ...
    dataAvailable = data_available
    getData = get_data

PointerToConnection = PointerTo_Connection
PointerToBaseConnection = PointerToBase_Connection
QueuedReturnDatagram = QueuedReturn_Datagram
QueuedReturnConnectionListenerData = QueuedReturn_ConnectionListenerData
QueuedReturnPointerToConnection = QueuedReturn_PointerTo_Connection
QueuedReturnNetDatagram = QueuedReturn_NetDatagram
