from collections.abc import Sequence
from typing import Any, ClassVar, overload
from panda3d.core import (
    Datagram,
    DatagramGenerator,
    DatagramSink,
    PointerToVoid,
    ReferenceCount,
    Socket_Address,
    Socket_IP,
    TypeHandle,
    ostream,
)

class PointerTo_Connection(PointerToBase_Connection):
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, ptr: Connection) -> None: ...
    @overload
    def __init__(self, copy: Connection) -> None: ...
    @overload
    def __init__(self, __param0: None) -> None: ...
    def p(self) -> Connection: ...
    @overload
    def assign(self, ptr: Connection) -> PointerTo_Connection: ...
    @overload
    def assign(self, copy: Connection) -> PointerTo_Connection: ...
    def is_null(self) -> bool: ...
    def clear(self) -> None: ...
    isNull = is_null

class PointerToBase_Connection(PointerToVoid):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def clear(self) -> None: ...
    def output(self, out: ostream) -> None: ...

class NetAddress:
    """Represents a network address to which UDP packets may be sent or to which a
    TCP socket may be bound.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, __param0: NetAddress) -> None: ...
    @overload
    def __init__(self, addr: Socket_Address) -> None: ...
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...
    def set_any(self, port: int) -> bool: ...
    def set_localhost(self, port: int) -> bool: ...
    def set_broadcast(self, port: int) -> bool: ...
    def set_host(self, hostname: str, port: int) -> bool: ...
    def clear(self) -> None: ...
    def get_port(self) -> int: ...
    def set_port(self, port: int) -> None: ...
    def get_ip_string(self) -> str: ...
    def is_any(self) -> bool: ...
    def get_ip(self) -> int: ...
    def get_ip_component(self, n: int) -> str: ...
    def get_addr(self) -> Socket_Address: ...
    def output(self, out: ostream) -> None: ...
    def get_hash(self) -> int: ...
    setAny = set_any
    setLocalhost = set_localhost
    setBroadcast = set_broadcast
    setHost = set_host
    getPort = get_port
    setPort = set_port
    getIpString = get_ip_string
    isAny = is_any
    getIp = get_ip
    getIpComponent = get_ip_component
    getAddr = get_addr
    getHash = get_hash

class Connection(ReferenceCount):
    """Represents a single TCP or UDP socket for input or output."""
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, manager: ConnectionManager, socket: Socket_IP) -> None: ...
    def get_address(self) -> NetAddress: ...
    def get_manager(self) -> ConnectionManager: ...
    def get_socket(self) -> Socket_IP: ...
    def set_collect_tcp(self, collect_tcp: bool) -> None: ...
    def get_collect_tcp(self) -> bool: ...
    def set_collect_tcp_interval(self, interval: float) -> None: ...
    def get_collect_tcp_interval(self) -> float: ...
    def consider_flush(self) -> bool: ...
    def flush(self) -> bool: ...
    def set_linger(self, flag: bool, time: float) -> None: ...
    def set_reuse_addr(self, flag: bool) -> None: ...
    def set_keep_alive(self, flag: bool) -> None: ...
    def set_recv_buffer_size(self, size: int) -> None: ...
    def set_send_buffer_size(self, size: int) -> None: ...
    def set_ip_time_to_live(self, ttl: int) -> None: ...
    def set_ip_type_of_service(self, tos: int) -> None: ...
    def set_no_delay(self, flag: bool) -> None: ...
    def set_max_segment(self, size: int) -> None: ...
    getAddress = get_address
    getManager = get_manager
    getSocket = get_socket
    setCollectTcp = set_collect_tcp
    getCollectTcp = get_collect_tcp
    setCollectTcpInterval = set_collect_tcp_interval
    getCollectTcpInterval = get_collect_tcp_interval
    considerFlush = consider_flush
    setLinger = set_linger
    setReuseAddr = set_reuse_addr
    setKeepAlive = set_keep_alive
    setRecvBufferSize = set_recv_buffer_size
    setSendBufferSize = set_send_buffer_size
    setIpTimeToLive = set_ip_time_to_live
    setIpTypeOfService = set_ip_type_of_service
    setNoDelay = set_no_delay
    setMaxSegment = set_max_segment

class ConnectionReader:
    """This is an abstract base class for a family of classes that listen for
    activity on a socket and respond to it, for instance by reading a datagram
    and serving it (or queueing it up for later service).
    
    A ConnectionReader may define an arbitrary number of threads (at least one)
    to process datagrams coming in from an arbitrary number of sockets that it
    is monitoring.  The number of threads is specified at construction time and
    cannot be changed, but the set of sockets that is to be monitored may be
    constantly modified at will.
    
    This is an abstract class because it doesn't define how to process each
    received datagram.  See QueuedConnectionReader.  Also note that
    ConnectionListener derives from this class, extending it to accept
    connections on a rendezvous socket rather than read datagrams.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def add_connection(self, connection: Connection) -> bool: ...
    def remove_connection(self, connection: Connection) -> bool: ...
    def is_connection_ok(self, connection: Connection) -> bool: ...
    def poll(self) -> None: ...
    def get_manager(self) -> ConnectionManager: ...
    def is_polling(self) -> bool: ...
    def get_num_threads(self) -> int: ...
    def set_raw_mode(self, mode: bool) -> None: ...
    def get_raw_mode(self) -> bool: ...
    def set_tcp_header_size(self, tcp_header_size: int) -> None: ...
    def get_tcp_header_size(self) -> int: ...
    def shutdown(self) -> None: ...
    addConnection = add_connection
    removeConnection = remove_connection
    isConnectionOk = is_connection_ok
    getManager = get_manager
    isPolling = is_polling
    getNumThreads = get_num_threads
    setRawMode = set_raw_mode
    getRawMode = get_raw_mode
    setTcpHeaderSize = set_tcp_header_size
    getTcpHeaderSize = get_tcp_header_size

class ConnectionListener(ConnectionReader):
    """This is a special kind of ConnectionReader that waits for activity on a
    rendezvous port and accepts a TCP connection (instead of attempting to read
    a datagram from the rendezvous port).
    
    It is itself an abstract class, as it doesn't define what to do with the
    established connection.  See QueuedConnectionListener.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]

class NetDatagram(Datagram):
    """A specific kind of Datagram, especially for sending across or receiving
    from a network.  It's different only in that it knows which Connection
    and/or NetAddress it is to be sent to or was received from.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, copy: Datagram) -> None: ...
    def assign(self, copy: Datagram) -> NetDatagram: ...
    def set_connection(self, connection: Connection) -> None: ...
    def get_connection(self) -> Connection: ...
    def set_address(self, address: NetAddress) -> None: ...
    def get_address(self) -> NetAddress: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    setConnection = set_connection
    getConnection = get_connection
    setAddress = set_address
    getAddress = get_address
    getClassType = get_class_type

class ConnectionManager:
    """The primary interface to the low-level networking layer in this package.  A
    ConnectionManager is used to establish and destroy TCP and UDP connections.
    Communication on these connections, once established, is handled via
    ConnectionReader, ConnectionWriter, and ConnectionListener.
    
    You may use this class directly if you don't care about tracking which
    connections have been unexpectedly closed; otherwise, you should use
    QueuedConnectionManager to get reports about these events (or derive your
    own class to handle these events properly).
    """
    class Interface:
        DtoolClassDict: ClassVar[dict[str, Any]]
        def __init__(self, __param0: ConnectionManager.Interface) -> None: ...
        def get_name(self) -> str: ...
        def get_mac_address(self) -> str: ...
        def has_ip(self) -> bool: ...
        def get_ip(self) -> NetAddress: ...
        def has_netmask(self) -> bool: ...
        def get_netmask(self) -> NetAddress: ...
        def has_broadcast(self) -> bool: ...
        def get_broadcast(self) -> NetAddress: ...
        def has_p2p(self) -> bool: ...
        def get_p2p(self) -> NetAddress: ...
        def output(self, out: ostream) -> None: ...
        getName = get_name
        getMacAddress = get_mac_address
        hasIp = has_ip
        getIp = get_ip
        hasNetmask = has_netmask
        getNetmask = get_netmask
        hasBroadcast = has_broadcast
        getBroadcast = get_broadcast
        hasP2p = has_p2p
        getP2p = get_p2p
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def host_name(self) -> str: ...
    @property
    def interfaces(self) -> Sequence[ConnectionManager.Interface]: ...
    def __init__(self) -> None: ...
    @overload
    def open_UDP_connection(self, port: int = ...) -> Connection: ...
    @overload
    def open_UDP_connection(self, hostname: str, port: int, for_broadcast: bool = ...) -> Connection: ...
    @overload
    def open_TCP_server_rendezvous(self, address: NetAddress, backlog: int) -> Connection: ...
    @overload
    def open_TCP_server_rendezvous(self, port: int, backlog: int) -> Connection: ...
    @overload
    def open_TCP_server_rendezvous(self, hostname: str, port: int, backlog: int) -> Connection: ...
    @overload
    def open_TCP_client_connection(self, address: NetAddress, timeout_ms: int) -> Connection: ...
    @overload
    def open_TCP_client_connection(self, hostname: str, port: int, timeout_ms: int) -> Connection: ...
    def close_connection(self, connection: Connection) -> bool: ...
    def wait_for_readers(self, timeout: float) -> bool: ...
    @staticmethod
    def get_host_name() -> str: ...
    def scan_interfaces(self) -> None: ...
    def get_num_interfaces(self) -> int: ...
    def get_interface(self, n: int) -> ConnectionManager.Interface: ...
    def get_interfaces(self) -> tuple[ConnectionManager.Interface, ...]: ...
    openUDPConnection = open_UDP_connection
    openTCPServerRendezvous = open_TCP_server_rendezvous
    openTCPClientConnection = open_TCP_client_connection
    closeConnection = close_connection
    waitForReaders = wait_for_readers
    getHostName = get_host_name
    scanInterfaces = scan_interfaces
    getNumInterfaces = get_num_interfaces
    getInterface = get_interface
    getInterfaces = get_interfaces

class ConnectionWriter:
    """This class handles threaded delivery of datagrams to various TCP or UDP
    sockets.
    
    A ConnectionWriter may define an arbitrary number of threads (0 or more) to
    write its datagrams to sockets.  The number of threads is specified at
    construction time and cannot be changed.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, manager: ConnectionManager, num_threads: int, thread_name: str = ...) -> None: ...
    def set_max_queue_size(self, max_size: int) -> None: ...
    def get_max_queue_size(self) -> int: ...
    def get_current_queue_size(self) -> int: ...
    @overload
    def send(self, datagram: Datagram, connection: Connection, block: bool = ...) -> bool: ...
    @overload
    def send(self, datagram: Datagram, connection: Connection, address: NetAddress, block: bool = ...) -> bool: ...
    def is_valid_for_udp(self, datagram: Datagram) -> bool: ...
    def get_manager(self) -> ConnectionManager: ...
    def is_immediate(self) -> bool: ...
    def get_num_threads(self) -> int: ...
    def set_raw_mode(self, mode: bool) -> None: ...
    def get_raw_mode(self) -> bool: ...
    def set_tcp_header_size(self, tcp_header_size: int) -> None: ...
    def get_tcp_header_size(self) -> int: ...
    def shutdown(self) -> None: ...
    setMaxQueueSize = set_max_queue_size
    getMaxQueueSize = get_max_queue_size
    getCurrentQueueSize = get_current_queue_size
    isValidForUdp = is_valid_for_udp
    getManager = get_manager
    isImmediate = is_immediate
    getNumThreads = get_num_threads
    setRawMode = set_raw_mode
    getRawMode = get_raw_mode
    setTcpHeaderSize = set_tcp_header_size
    getTcpHeaderSize = get_tcp_header_size

class DatagramGeneratorNet(DatagramGenerator, ConnectionReader, QueuedReturn_Datagram):
    """This class provides datagrams one-at-a-time as read directly from the net,
    via a TCP connection.  If a datagram is not available, get_datagram() will
    block until one is.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, manager: ConnectionManager, num_threads: int) -> None: ...
    def upcast_to_DatagramGenerator(self) -> DatagramGenerator: ...
    def upcast_to_ConnectionReader(self) -> ConnectionReader: ...
    def upcast_to_QueuedReturn_Datagram(self) -> QueuedReturn_Datagram: ...
    def get_datagram(self, data: Datagram) -> bool: ...
    def is_eof(self) -> bool: ...
    def is_error(self) -> bool: ...
    upcastToDatagramGenerator = upcast_to_DatagramGenerator
    upcastToConnectionReader = upcast_to_ConnectionReader
    upcastToQueuedReturnDatagram = upcast_to_QueuedReturn_Datagram
    getDatagram = get_datagram
    isEof = is_eof
    isError = is_error

class QueuedReturn_Datagram:
    DtoolClassDict: ClassVar[dict[str, Any]]
    def set_max_queue_size(self, max_size: int) -> None: ...
    def get_max_queue_size(self) -> int: ...
    def get_current_queue_size(self) -> int: ...
    def get_overflow_flag(self) -> bool: ...
    def reset_overflow_flag(self) -> None: ...
    setMaxQueueSize = set_max_queue_size
    getMaxQueueSize = get_max_queue_size
    getCurrentQueueSize = get_current_queue_size
    getOverflowFlag = get_overflow_flag
    resetOverflowFlag = reset_overflow_flag

class DatagramSinkNet(DatagramSink, ConnectionWriter):
    """This class accepts datagrams one-at-a-time and sends them over the net, via
    a TCP connection.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, manager: ConnectionManager, num_threads: int) -> None: ...
    def upcast_to_DatagramSink(self) -> DatagramSink: ...
    def upcast_to_ConnectionWriter(self) -> ConnectionWriter: ...
    def set_target(self, connection: Connection) -> None: ...
    def get_target(self) -> Connection: ...
    def put_datagram(self, data: Datagram) -> bool: ...
    def is_error(self) -> bool: ...
    def flush(self) -> None: ...
    upcastToDatagramSink = upcast_to_DatagramSink
    upcastToConnectionWriter = upcast_to_ConnectionWriter
    setTarget = set_target
    getTarget = get_target
    putDatagram = put_datagram
    isError = is_error

class QueuedConnectionListener(ConnectionListener, QueuedReturn_ConnectionListenerData):
    """This flavor of ConnectionListener will queue up all of the TCP connections
    it established for later detection by the client code.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, manager: ConnectionManager, num_threads: int) -> None: ...
    def upcast_to_ConnectionListener(self) -> ConnectionListener: ...
    def upcast_to_QueuedReturn_ConnectionListenerData(self) -> QueuedReturn_ConnectionListenerData: ...
    def new_connection_available(self) -> bool: ...
    @overload
    def get_new_connection(self, new_connection: Connection | PointerTo_Connection | None) -> bool: ...
    @overload
    def get_new_connection(self, rendezvous: Connection | PointerTo_Connection | None, address: NetAddress, new_connection: Connection | PointerTo_Connection | None) -> bool: ...
    upcastToConnectionListener = upcast_to_ConnectionListener
    upcastToQueuedReturnConnectionListenerData = upcast_to_QueuedReturn_ConnectionListenerData
    newConnectionAvailable = new_connection_available
    getNewConnection = get_new_connection

class QueuedReturn_ConnectionListenerData:
    DtoolClassDict: ClassVar[dict[str, Any]]
    def set_max_queue_size(self, max_size: int) -> None: ...
    def get_max_queue_size(self) -> int: ...
    def get_current_queue_size(self) -> int: ...
    def get_overflow_flag(self) -> bool: ...
    def reset_overflow_flag(self) -> None: ...
    setMaxQueueSize = set_max_queue_size
    getMaxQueueSize = get_max_queue_size
    getCurrentQueueSize = get_current_queue_size
    getOverflowFlag = get_overflow_flag
    resetOverflowFlag = reset_overflow_flag

class QueuedConnectionManager(ConnectionManager, QueuedReturn_PointerTo_Connection):
    """This flavor of ConnectionManager will queue up all of the reset-connection
    messages from the ConnectionReaders and ConnectionWriters and report them
    to the client on demand.
    
    When a reset connection has been discovered via
    reset_connection_available()/get_reset_connection(), it is still the
    responsibility of the client to call close_connection() on that connection
    to free up its resources.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self) -> None: ...
    def upcast_to_ConnectionManager(self) -> ConnectionManager: ...
    def upcast_to_QueuedReturn_PointerTo_Connection(self) -> QueuedReturn_PointerTo_Connection: ...
    def reset_connection_available(self) -> bool: ...
    def get_reset_connection(self, connection: Connection | PointerTo_Connection | None) -> bool: ...
    upcastToConnectionManager = upcast_to_ConnectionManager
    upcastToQueuedReturnPointerToConnection = upcast_to_QueuedReturn_PointerTo_Connection
    resetConnectionAvailable = reset_connection_available
    getResetConnection = get_reset_connection

class QueuedReturn_PointerTo_Connection:
    DtoolClassDict: ClassVar[dict[str, Any]]
    def set_max_queue_size(self, max_size: int) -> None: ...
    def get_max_queue_size(self) -> int: ...
    def get_current_queue_size(self) -> int: ...
    def get_overflow_flag(self) -> bool: ...
    def reset_overflow_flag(self) -> None: ...
    setMaxQueueSize = set_max_queue_size
    getMaxQueueSize = get_max_queue_size
    getCurrentQueueSize = get_current_queue_size
    getOverflowFlag = get_overflow_flag
    resetOverflowFlag = reset_overflow_flag

class QueuedConnectionReader(ConnectionReader, QueuedReturn_NetDatagram):
    """This flavor of ConnectionReader will read from its sockets and queue up all
    of the datagrams read for later receipt by the client code.  This class is
    useful for client code that doesn't want to deal with threading and is
    willing to poll for datagrams at its convenience.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, manager: ConnectionManager, num_threads: int) -> None: ...
    def upcast_to_ConnectionReader(self) -> ConnectionReader: ...
    def upcast_to_QueuedReturn_NetDatagram(self) -> QueuedReturn_NetDatagram: ...
    def data_available(self) -> bool: ...
    def get_data(self, result: Datagram) -> bool: ...
    upcastToConnectionReader = upcast_to_ConnectionReader
    upcastToQueuedReturnNetDatagram = upcast_to_QueuedReturn_NetDatagram
    dataAvailable = data_available
    getData = get_data

class QueuedReturn_NetDatagram:
    DtoolClassDict: ClassVar[dict[str, Any]]
    def set_max_queue_size(self, max_size: int) -> None: ...
    def get_max_queue_size(self) -> int: ...
    def get_current_queue_size(self) -> int: ...
    def get_overflow_flag(self) -> bool: ...
    def reset_overflow_flag(self) -> None: ...
    setMaxQueueSize = set_max_queue_size
    getMaxQueueSize = get_max_queue_size
    getCurrentQueueSize = get_current_queue_size
    getOverflowFlag = get_overflow_flag
    resetOverflowFlag = reset_overflow_flag

class RecentConnectionReader(ConnectionReader):
    """This flavor of ConnectionReader will read from its sockets and retain only
    the single most recent datagram for inspection by client code.  It's useful
    particularly for reading telemetry-type data from UDP sockets where you
    don't care about getting every last socket, and in fact if the sockets are
    coming too fast you'd prefer to skip some of them.
    
    This class will always create one thread for itself.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, manager: ConnectionManager) -> None: ...
    def data_available(self) -> bool: ...
    def get_data(self, result: Datagram) -> bool: ...
    dataAvailable = data_available
    getData = get_data

PointerToConnection = PointerTo_Connection
PointerToBaseConnection = PointerToBase_Connection
QueuedReturnDatagram = QueuedReturn_Datagram
QueuedReturnConnectionListenerData = QueuedReturn_ConnectionListenerData
QueuedReturnPointerToConnection = QueuedReturn_PointerTo_Connection
QueuedReturnNetDatagram = QueuedReturn_NetDatagram
