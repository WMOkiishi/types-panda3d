from os import PathLike
from typing import Any, ClassVar, TypeAlias, overload
from panda3d.core import (
    ConfigVariableFilename,
    DataNode,
    Datagram,
    Filename,
    ReferenceCount,
    SocketStream,
    TypeHandle,
    TypedReferenceCount,
)

_Filename: TypeAlias = Filename | ConfigVariableFilename | str | bytes | PathLike

class RecorderBase:
    """This is the base class to a number of objects that record particular kinds
    of user input (like a MouseRecorder) to use in conjunction with a
    RecorderController to record the user's inputs for a session.
    
    Note that RecorderBase does not actually inherit from TypedObject, even
    though it defines get_type().  The assumption is that the classes that
    derive from RecorderBase might also inherit independently from TypedObject.
    
    It also does not inherit from TypedWritable, but it defines a method called
    write_recorder() which is very similar to a TypedWritable's
    write_datagram(). Classes that derive from RecorderBase and also inherit
    from TypedWritable may choose to remap write_recorder() to do exactly the
    same thing as write_datagram(), or they may choose to write something
    slightly different.
    
    Most types of recorders should derive from Recorder, as it derives from
    ReferenceCount, except for MouseRecorder, which would otherwise doubly
    inherit from ReferenceCount.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def is_recording(self) -> bool: ...
    def is_playing(self) -> bool: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    isRecording = is_recording
    isPlaying = is_playing
    getClassType = get_class_type

class MouseRecorder(DataNode, RecorderBase):
    """This object records any data generated by a particular MouseAndKeyboard
    node on the datagraph for a session for eventual playback via a
    DataGraphPlayback (and a PlaybackController).  To use it, make it a child
    of the node you wish to record.  It also serves as a pass-through, so that
    additional child nodes may be parented directly to it.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, name: str) -> None: ...
    def upcast_to_DataNode(self) -> DataNode: ...
    def upcast_to_RecorderBase(self) -> RecorderBase: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    upcastToDataNode = upcast_to_DataNode
    upcastToRecorderBase = upcast_to_RecorderBase
    getClassType = get_class_type

class RecorderController(TypedReferenceCount):
    """This object manages the process of recording the user's runtime inputs to a
    bam file so that the session can be recreated later.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self) -> None: ...
    def begin_record(self, filename: _Filename) -> bool: ...
    def begin_playback(self, filename: _Filename) -> bool: ...
    def close(self) -> None: ...
    def get_start_time(self) -> int: ...
    def set_random_seed(self, random_seed: int) -> None: ...
    def get_random_seed(self) -> int: ...
    def is_recording(self) -> bool: ...
    def is_playing(self) -> bool: ...
    def is_open(self) -> bool: ...
    def get_filename(self) -> Filename: ...
    def is_error(self) -> bool: ...
    def get_clock_offset(self) -> float: ...
    def get_frame_offset(self) -> int: ...
    def add_recorder(self, name: str, recorder: RecorderBase) -> None: ...
    def has_recorder(self, name: str) -> bool: ...
    def get_recorder(self, name: str) -> RecorderBase: ...
    def remove_recorder(self, name: str) -> bool: ...
    def set_frame_tie(self, frame_tie: bool) -> None: ...
    def get_frame_tie(self) -> bool: ...
    def record_frame(self) -> None: ...
    def play_frame(self) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    beginRecord = begin_record
    beginPlayback = begin_playback
    getStartTime = get_start_time
    setRandomSeed = set_random_seed
    getRandomSeed = get_random_seed
    isRecording = is_recording
    isPlaying = is_playing
    isOpen = is_open
    getFilename = get_filename
    isError = is_error
    getClockOffset = get_clock_offset
    getFrameOffset = get_frame_offset
    addRecorder = add_recorder
    hasRecorder = has_recorder
    getRecorder = get_recorder
    removeRecorder = remove_recorder
    setFrameTie = set_frame_tie
    getFrameTie = get_frame_tie
    recordFrame = record_frame
    playFrame = play_frame
    getClassType = get_class_type

class SocketStreamRecorder(RecorderBase, ReferenceCount):
    """Records any data received from the indicated socket stream.  On playback,
    it will act as if the incoming data is coming over the wire again even if
    an actual connection is not available.
    
    Outbound data will not be recorded, but will be sent straight through to
    the socket if it is connected, or silently ignored if it is not.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, stream: SocketStream, owns_stream: bool) -> None: ...
    def upcast_to_RecorderBase(self) -> RecorderBase: ...
    def upcast_to_ReferenceCount(self) -> ReferenceCount: ...
    def receive_datagram(self, dg: Datagram) -> bool: ...
    def send_datagram(self, dg: Datagram) -> bool: ...
    def is_closed(self) -> bool: ...
    def close(self) -> None: ...
    def set_collect_tcp(self, collect_tcp: bool) -> None: ...
    def get_collect_tcp(self) -> bool: ...
    def set_collect_tcp_interval(self, interval: float) -> None: ...
    def get_collect_tcp_interval(self) -> float: ...
    def consider_flush(self) -> bool: ...
    def flush(self) -> bool: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    upcastToRecorderBase = upcast_to_RecorderBase
    upcastToReferenceCount = upcast_to_ReferenceCount
    receiveDatagram = receive_datagram
    sendDatagram = send_datagram
    isClosed = is_closed
    setCollectTcp = set_collect_tcp
    getCollectTcp = get_collect_tcp
    setCollectTcpInterval = set_collect_tcp_interval
    getCollectTcpInterval = get_collect_tcp_interval
    considerFlush = consider_flush
    getClassType = get_class_type
