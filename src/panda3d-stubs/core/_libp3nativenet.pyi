from typing import Any, ClassVar, overload
from panda3d.core import Datagram, TypeHandle, TypedObject

class Socket_Address:
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self, port: int = ...) -> None: ...
    @overload
    def __init__(self, inaddr: Socket_Address) -> None: ...
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...
    def __lt__(self, _in: Socket_Address) -> bool: ...
    def __le__(self, _in: Socket_Address) -> bool: ...
    def set_any_IP(self, port: int) -> bool: ...
    def set_any_IPv6(self, port: int) -> bool: ...
    def set_port(self, port: int) -> bool: ...
    def set_broadcast(self, port: int) -> bool: ...
    @overload
    def set_host(self, hostname: str) -> bool: ...
    @overload
    def set_host(self, hostname: str, port: int) -> bool: ...
    @overload
    def set_host(self, ip4addr: int, port: int) -> bool: ...
    def clear(self) -> None: ...
    def get_family(self) -> int: ...
    def get_port(self) -> int: ...
    def get_ip(self) -> str: ...
    def get_ip_port(self) -> str: ...
    def GetIPAddressRaw(self) -> int: ...
    def is_any(self) -> bool: ...
    def is_mcast_range(self) -> bool: ...
    setAnyIP = set_any_IP
    setAnyIPv6 = set_any_IPv6
    setPort = set_port
    setBroadcast = set_broadcast
    setHost = set_host
    getFamily = get_family
    getPort = get_port
    getIp = get_ip
    getIpPort = get_ip_port
    isAny = is_any
    isMcastRange = is_mcast_range

class Socket_IP(TypedObject):
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, _in: int) -> None: ...
    def Close(self) -> None: ...
    @staticmethod
    def GetLastError() -> int: ...
    def SetNonBlocking(self) -> int: ...
    def SetBlocking(self) -> int: ...
    def SetReuseAddress(self, flag: bool = ...) -> bool: ...
    def SetV6Only(self, flag: bool) -> bool: ...
    def Active(self) -> bool: ...
    def SetRecvBufferSize(self, size: int) -> int: ...
    def SetSocket(self, ins: int) -> None: ...
    def GetSocket(self) -> int: ...
    def GetPeerName(self) -> Socket_Address: ...
    @staticmethod
    def InitNetworkDriver() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getClassType = get_class_type

class Socket_TCP(Socket_IP):
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, __param0: int) -> None: ...
    def SetNoDelay(self, flag: bool = ...) -> int: ...
    def SetLinger(self, interval_seconds: int = ...) -> int: ...
    def DontLinger(self) -> int: ...
    def SetSendBufferSize(self, insize: int) -> int: ...
    def ActiveOpen(self, theaddress: Socket_Address, setdelay: bool) -> bool: ...
    def ActiveOpenNonBlocking(self, theaddress: Socket_Address) -> bool: ...
    def ErrorIs_WouldBlocking(self, err: int) -> bool: ...
    def ShutdownSend(self) -> bool: ...
    def SendData(self, str: str) -> int: ...
    def RecvData(self, max_len: int) -> str: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    ErrorIsWouldBlocking = ErrorIs_WouldBlocking
    getClassType = get_class_type

class Socket_TCP_Listen(Socket_IP):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self) -> None: ...
    @overload
    def OpenForListen(self, address: Socket_Address, backlog_size: int = ...) -> bool: ...
    @overload
    def OpenForListen(self, port: int, backlog_size: int = ...) -> bool: ...
    def GetIncomingConnection(self, newsession: Socket_TCP | int, address: Socket_Address) -> bool: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getClassType = get_class_type

class Socket_UDP_Incoming(Socket_IP):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self) -> None: ...
    @overload
    def OpenForInput(self, address: Socket_Address) -> bool: ...
    @overload
    def OpenForInput(self, port: int) -> bool: ...
    def OpenForInputMCast(self, address: Socket_Address) -> bool: ...
    def SendTo(self, data: str, len: int, address: Socket_Address) -> bool: ...
    def InitNoAddress(self) -> bool: ...
    def SetToBroadCast(self) -> bool: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getClassType = get_class_type

class Socket_UDP_Outgoing(Socket_IP):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self) -> None: ...
    def InitToAddress(self, address: Socket_Address) -> bool: ...
    def Send(self, data: str) -> bool: ...
    def InitNoAddress(self) -> bool: ...
    def SendTo(self, data: str, address: Socket_Address) -> bool: ...
    def SetToBroadCast(self) -> bool: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getClassType = get_class_type

class Socket_fdset:
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, __param0: Socket_fdset) -> None: ...
    def setForSocket(self, incon: Socket_IP) -> None: ...
    def IsSetFor(self, incon: Socket_IP) -> bool: ...
    def WaitForRead(self, zeroFds: bool, sleep_time: int = ...) -> int: ...
    def WaitForWrite(self, zeroFds: bool, sleep_time: int = ...) -> int: ...
    def WaitForError(self, zeroFds: bool, sleep_time: int = ...) -> int: ...
    def clear(self) -> None: ...

class Buffered_DatagramConnection(Socket_TCP):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, rbufsize: int, wbufsize: int, write_flush_point: int) -> None: ...
    def GetMessage(self, val: Datagram) -> bool: ...
    def DoConnect(self) -> bool: ...
    def IsConnected(self) -> bool: ...
    def SendMessage(self, msg: Datagram) -> bool: ...
    def Flush(self) -> bool: ...
    def Reset(self) -> None: ...
    def WaitForNetworkReadEvent(self, MaxTime: float) -> None: ...
    def AddressQueueSize(self) -> int: ...
    def AddAddress(self, inadr: Socket_Address) -> None: ...
    def ClearAddresses(self) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getClassType = get_class_type

class Socket_UDP(Socket_UDP_Incoming):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self) -> None: ...
    def InitToAddress(self, address: Socket_Address) -> bool: ...
    def Send(self, data: str) -> bool: ...
    def SendTo(self, data: str, address: Socket_Address) -> bool: ...
    def SetToBroadCast(self) -> bool: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getClassType = get_class_type

SocketAddress = Socket_Address
SocketIP = Socket_IP
SocketTCP = Socket_TCP
SocketTCPListen = Socket_TCP_Listen
SocketUDPIncoming = Socket_UDP_Incoming
SocketUDPOutgoing = Socket_UDP_Outgoing
SocketFdset = Socket_fdset
BufferedDatagramConnection = Buffered_DatagramConnection
SocketUDP = Socket_UDP
