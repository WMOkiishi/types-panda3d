from typing import Any, ClassVar, Literal, TypeAlias, overload
from panda3d.core import Namable, TypeHandle, TypedReferenceCount, ostream

_ThreadPriority: TypeAlias = Literal[0, 1, 2, 3]

class Thread(TypedReferenceCount, Namable):
    DtoolClassDict: ClassVar[dict[str, Any]]
    pipeline_stage: int
    @property
    def sync_name(self) -> str: ...
    @property
    def pstats_index(self) -> int: ...
    @property
    def python_index(self) -> int: ...
    @property
    def unique_id(self) -> str: ...
    @property
    def main_thread(self) -> Thread: ...
    @property
    def external_thread(self) -> Thread: ...
    @property
    def current_thread(self) -> Thread: ...
    @property
    def current_pipeline_stage(self) -> int: ...
    @property
    def threading_supported(self) -> bool: ...
    @property
    def true_threads(self) -> bool: ...
    @property
    def simple_threads(self) -> bool: ...
    @property
    def started(self) -> bool: ...
    @property
    def joinable(self) -> bool: ...
    @property
    def current_task(self) -> TypedReferenceCount: ...
    def upcast_to_TypedReferenceCount(self) -> TypedReferenceCount: ...
    def upcast_to_Namable(self) -> Namable: ...
    @staticmethod
    def bind_thread(name: str, sync_name: str) -> Thread: ...
    def get_sync_name(self) -> str: ...
    def get_pstats_index(self) -> int: ...
    def get_python_index(self) -> int: ...
    def get_unique_id(self) -> str: ...
    def get_pipeline_stage(self) -> int: ...
    def set_pipeline_stage(self, pipeline_stage: int) -> None: ...
    def set_min_pipeline_stage(self, min_pipeline_stage: int) -> None: ...
    @staticmethod
    def get_main_thread() -> Thread: ...
    @staticmethod
    def get_external_thread() -> Thread: ...
    @staticmethod
    def get_current_thread() -> Thread: ...
    @staticmethod
    def get_current_pipeline_stage() -> int: ...
    @staticmethod
    def is_threading_supported() -> bool: ...
    @staticmethod
    def is_true_threads() -> bool: ...
    @staticmethod
    def is_simple_threads() -> bool: ...
    @staticmethod
    def sleep(seconds: float) -> None: ...
    @staticmethod
    def force_yield() -> None: ...
    @staticmethod
    def consider_yield() -> None: ...
    def output(self, out: ostream) -> None: ...
    def output_blocker(self, out: ostream) -> None: ...
    @staticmethod
    def write_status(out: ostream) -> None: ...
    def is_started(self) -> bool: ...
    def is_joinable(self) -> bool: ...
    def start(self, priority: _ThreadPriority, joinable: bool) -> bool: ...
    def join(self) -> None: ...
    def preempt(self) -> None: ...
    def get_current_task(self) -> TypedReferenceCount: ...
    def set_python_index(self, index: int) -> None: ...
    @staticmethod
    def prepare_for_exit() -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    upcastToTypedReferenceCount = upcast_to_TypedReferenceCount
    upcastToNamable = upcast_to_Namable
    bindThread = bind_thread
    getSyncName = get_sync_name
    getPstatsIndex = get_pstats_index
    getPythonIndex = get_python_index
    getUniqueId = get_unique_id
    getPipelineStage = get_pipeline_stage
    setPipelineStage = set_pipeline_stage
    setMinPipelineStage = set_min_pipeline_stage
    getMainThread = get_main_thread
    getExternalThread = get_external_thread
    getCurrentThread = get_current_thread
    getCurrentPipelineStage = get_current_pipeline_stage
    isThreadingSupported = is_threading_supported
    isTrueThreads = is_true_threads
    isSimpleThreads = is_simple_threads
    forceYield = force_yield
    considerYield = consider_yield
    outputBlocker = output_blocker
    writeStatus = write_status
    isStarted = is_started
    isJoinable = is_joinable
    getCurrentTask = get_current_task
    setPythonIndex = set_python_index
    prepareForExit = prepare_for_exit
    getClassType = get_class_type

class MutexDirect:
    DtoolClassDict: ClassVar[dict[str, Any]]
    def acquire(self) -> None: ...
    def try_acquire(self) -> bool: ...
    def release(self) -> None: ...
    def debug_is_locked(self) -> bool: ...
    def set_name(self, name: str) -> None: ...
    def clear_name(self) -> None: ...
    def has_name(self) -> bool: ...
    def get_name(self) -> str: ...
    def output(self, out: ostream) -> None: ...
    tryAcquire = try_acquire
    debugIsLocked = debug_is_locked
    setName = set_name
    clearName = clear_name
    hasName = has_name
    getName = get_name

class Mutex(MutexDirect):
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, name: str) -> None: ...

class ConditionVarDirect:
    DtoolClassDict: ClassVar[dict[str, Any]]
    def get_mutex(self) -> MutexDirect: ...
    @overload
    def wait(self) -> None: ...
    @overload
    def wait(self, timeout: float) -> None: ...
    def notify(self) -> None: ...
    def output(self, out: ostream) -> None: ...
    getMutex = get_mutex

class ConditionVar(ConditionVarDirect):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, mutex: Mutex) -> None: ...
    def get_mutex(self) -> Mutex: ...
    getMutex = get_mutex

class ConditionVarFullDirect:
    DtoolClassDict: ClassVar[dict[str, Any]]
    def get_mutex(self) -> MutexDirect: ...
    @overload
    def wait(self) -> None: ...
    @overload
    def wait(self, timeout: float) -> None: ...
    def notify(self) -> None: ...
    def notify_all(self) -> None: ...
    def output(self, out: ostream) -> None: ...
    getMutex = get_mutex
    notifyAll = notify_all

class ConditionVarFull(ConditionVarFullDirect):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, mutex: Mutex) -> None: ...
    def get_mutex(self) -> Mutex: ...
    getMutex = get_mutex

class ReMutexDirect:
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def acquire(self) -> None: ...
    @overload
    def acquire(self, current_thread: Thread) -> None: ...
    @overload
    def try_acquire(self) -> bool: ...
    @overload
    def try_acquire(self, current_thread: Thread) -> bool: ...
    def elevate_lock(self) -> None: ...
    def release(self) -> None: ...
    def debug_is_locked(self) -> bool: ...
    def set_name(self, name: str) -> None: ...
    def clear_name(self) -> None: ...
    def has_name(self) -> bool: ...
    def get_name(self) -> str: ...
    def output(self, out: ostream) -> None: ...
    tryAcquire = try_acquire
    elevateLock = elevate_lock
    debugIsLocked = debug_is_locked
    setName = set_name
    clearName = clear_name
    hasName = has_name
    getName = get_name

class ReMutex(ReMutexDirect):
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, name: str) -> None: ...

class ExternalThread(Thread):
    DtoolClassDict: ClassVar[dict[str, Any]]
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getClassType = get_class_type

class LightMutexDirect:
    DtoolClassDict: ClassVar[dict[str, Any]]
    def acquire(self) -> None: ...
    def release(self) -> None: ...
    def debug_is_locked(self) -> bool: ...
    def set_name(self, name: str) -> None: ...
    def clear_name(self) -> None: ...
    def has_name(self) -> bool: ...
    def get_name(self) -> str: ...
    def output(self, out: ostream) -> None: ...
    debugIsLocked = debug_is_locked
    setName = set_name
    clearName = clear_name
    hasName = has_name
    getName = get_name

class LightMutex(LightMutexDirect):
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, name: str) -> None: ...

class LightReMutexDirect:
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def acquire(self) -> None: ...
    @overload
    def acquire(self, current_thread: Thread) -> None: ...
    def elevate_lock(self) -> None: ...
    def release(self) -> None: ...
    def debug_is_locked(self) -> bool: ...
    def set_name(self, name: str) -> None: ...
    def clear_name(self) -> None: ...
    def has_name(self) -> bool: ...
    def get_name(self) -> str: ...
    def output(self, out: ostream) -> None: ...
    elevateLock = elevate_lock
    debugIsLocked = debug_is_locked
    setName = set_name
    clearName = clear_name
    hasName = has_name
    getName = get_name

class LightReMutex(LightReMutexDirect):
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, name: str) -> None: ...

class MainThread(Thread):
    DtoolClassDict: ClassVar[dict[str, Any]]
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getClassType = get_class_type

class Semaphore:
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, initial_count: int = ...) -> None: ...
    def acquire(self) -> None: ...
    def try_acquire(self) -> bool: ...
    def release(self) -> int: ...
    def get_count(self) -> int: ...
    def output(self, out: ostream) -> None: ...
    tryAcquire = try_acquire
    getCount = get_count

class PythonThread(Thread):
    DtoolClassDict: ClassVar[dict[str, Any]]
    args: Any
    def __init__(self, function: Any, args: Any, name: str, sync_name: str) -> None: ...
    def join(self) -> Any: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getClassType = get_class_type

TP_low: Literal[0]
TP_normal: Literal[1]
TP_high: Literal[2]
TP_urgent: Literal[3]
TPLow = TP_low
TPNormal = TP_normal
TPHigh = TP_high
TPUrgent = TP_urgent
