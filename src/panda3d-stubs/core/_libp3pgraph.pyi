from collections.abc import Mapping, Sequence
from os import PathLike
from typing import Any, ClassVar, Literal, TypeAlias, final, overload
from panda3d.core import (
    AsyncTask,
    AsyncTaskManager,
    BamEnums,
    BamReader,
    BamWriter,
    BitMask_uint32_t_32,
    BoundingVolume,
    CallbackData,
    ConfigVariableColor,
    ConfigVariableFilename,
    DisplayRegion,
    Filename,
    Geom,
    GeometricBoundingVolume,
    GraphicsStateGuardianBase,
    InternalName,
    LMatrix3f,
    LMatrix4f,
    LPlanef,
    LPoint3f,
    LQuaternionf,
    LVecBase2f,
    LVecBase3f,
    LVecBase4f,
    LVector3f,
    Lens,
    LoaderOptions,
    Material,
    Namable,
    NodeCachedReferenceCount,
    ParamValueBase,
    ReferenceCount,
    SamplerState,
    Shader,
    ShaderBuffer,
    Texture,
    TextureCollection,
    TextureStage,
    Thread,
    TypeHandle,
    TypedObject,
    TypedReferenceCount,
    TypedWritable,
    TypedWritableReferenceCount,
    UnalignedLMatrix4f,
    UnalignedLVecBase4f,
    UpdateSeq,
    istream,
    ostream,
)

_Vec3f: TypeAlias = LVecBase3f | LMatrix3f.Row | LMatrix3f.CRow
_Vec4f: TypeAlias = LVecBase4f | UnalignedLVecBase4f | LMatrix4f.Row | LMatrix4f.CRow | ConfigVariableColor
_Mat4f: TypeAlias = LMatrix4f | UnalignedLMatrix4f
_RenderModeAttrib_Mode: TypeAlias = Literal[0, 1, 2, 3, 4, 5]
_RenderAttrib_PandaCompareFunc: TypeAlias = Literal[0, 1, 2, 3, 4, 5, 6, 7, 8]
_BoundingVolume_BoundsType: TypeAlias = Literal[0, 1, 2, 3, 4]
_TransparencyAttrib_Mode: TypeAlias = Literal[0, 1, 2, 3, 4, 5, 6]
_LogicOpAttrib_Operation: TypeAlias = Literal[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
_NodePath_ErrorType: TypeAlias = Literal[0, 1, 2, 3]
_RenderAttrib_TexGenMode: TypeAlias = Literal[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
_Filename: TypeAlias = Filename | ConfigVariableFilename | str | bytes | PathLike
_BamEnums_BamEndian: TypeAlias = Literal[0, 1, 1]
_ClipPlaneAttrib_Operation: TypeAlias = Literal[0, 1, 2]
_ColorAttrib_Type: TypeAlias = Literal[0, 1, 2]
_ColorBlendAttrib_Mode: TypeAlias = Literal[0, 1, 2, 3, 4, 5]
_ColorBlendAttrib_Operand: TypeAlias = Literal[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]
_CullBinEnums_BinType: TypeAlias = Literal[0, 1, 2, 3, 4, 5]
_CullFaceAttrib_Mode: TypeAlias = Literal[0, 1, 2, 3]
_Fog_Mode: TypeAlias = Literal[0, 1, 2]
_RescaleNormalAttrib_Mode: TypeAlias = Literal[0, 1, 2, 3]
_DepthWriteAttrib_Mode: TypeAlias = Literal[0, 1]
_LightAttrib_Operation: TypeAlias = Literal[0, 1, 2]
_LightRampAttrib_LightRampMode: TypeAlias = Literal[0, 1, 2, 3, 4, 5, 6]
_ModelNode_PreserveTransform: TypeAlias = Literal[0, 1, 2, 3, 4]
_PolylightNode_Attenuation_Type: TypeAlias = Literal[0, 1]
_PolylightNode_Flicker_Type: TypeAlias = Literal[0, 1, 2]
_PolylightEffect_ContribType: TypeAlias = Literal[0, 1]
_ShadeModelAttrib_Mode: TypeAlias = Literal[0, 1]
_StencilAttrib_StencilOperation: TypeAlias = Literal[0, 1, 2, 3, 4, 5, 6, 7]
_StencilAttrib_StencilRenderState: TypeAlias = Literal[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]

@final
class TransformState(NodeCachedReferenceCount):
    """Indicates a coordinate-system transform on vertices.  TransformStates are
    the primary means for storing transformations on the scene graph.
    
    Transforms may be specified in one of two ways: componentwise, with a pos-
    hpr-scale, or with an arbitrary transform matrix.  If you specify a
    transform componentwise, it will remember its original components.
    
    TransformState objects are managed very much like RenderState objects.
    They are immutable and reference-counted automatically.
    
    You should not attempt to create or modify a TransformState object
    directly.  Instead, call one of the make() functions to create one for you.
    And instead of modifying a TransformState object, create a new one.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def pos(self) -> LPoint3f: ...
    @property
    def hpr(self) -> LVecBase3f: ...
    @property
    def quat(self) -> LQuaternionf: ...
    @property
    def norm_quat(self) -> LQuaternionf: ...
    @property
    def scale(self) -> LVecBase3f: ...
    @property
    def shear(self) -> LVecBase3f: ...
    @property
    def mat(self) -> LMatrix4f: ...
    def __ne__(self, __other: object) -> bool: ...
    def __eq__(self, __other: object) -> bool: ...
    @overload
    def compare_to(self, other: TransformState) -> int: ...
    @overload
    def compare_to(self, other: TransformState, uniquify_matrix: bool) -> int: ...
    def get_hash(self) -> int: ...
    @staticmethod
    def make_identity() -> TransformState: ...
    @staticmethod
    def make_invalid() -> TransformState: ...
    @staticmethod
    def make_pos(pos: _Vec3f) -> TransformState: ...
    @staticmethod
    def make_hpr(hpr: _Vec3f) -> TransformState: ...
    @staticmethod
    def make_quat(quat: _Vec4f) -> TransformState: ...
    @staticmethod
    def make_pos_hpr(pos: _Vec3f, hpr: _Vec3f) -> TransformState: ...
    @staticmethod
    def make_scale(scale: _Vec3f | float) -> TransformState: ...
    @staticmethod
    def make_shear(shear: _Vec3f) -> TransformState: ...
    @staticmethod
    def make_pos_hpr_scale(pos: _Vec3f, hpr: _Vec3f, scale: _Vec3f) -> TransformState: ...
    @staticmethod
    def make_pos_quat_scale(pos: _Vec3f, quat: _Vec4f, scale: _Vec3f) -> TransformState: ...
    @staticmethod
    def make_pos_hpr_scale_shear(pos: _Vec3f, hpr: _Vec3f, scale: _Vec3f, shear: _Vec3f) -> TransformState: ...
    @staticmethod
    def make_pos_quat_scale_shear(pos: _Vec3f, quat: _Vec4f, scale: _Vec3f, shear: _Vec3f) -> TransformState: ...
    @staticmethod
    def make_mat(mat: _Mat4f) -> TransformState: ...
    @staticmethod
    def make_pos2d(pos: LVecBase2f) -> TransformState: ...
    @staticmethod
    def make_rotate2d(rotate: float) -> TransformState: ...
    @staticmethod
    def make_pos_rotate2d(pos: LVecBase2f, rotate: float) -> TransformState: ...
    @staticmethod
    def make_scale2d(scale: LVecBase2f | float) -> TransformState: ...
    @staticmethod
    def make_shear2d(shear: float) -> TransformState: ...
    @staticmethod
    def make_pos_rotate_scale2d(pos: LVecBase2f, rotate: float, scale: LVecBase2f) -> TransformState: ...
    @staticmethod
    def make_pos_rotate_scale_shear2d(pos: LVecBase2f, rotate: float, scale: LVecBase2f, shear: float) -> TransformState: ...
    @staticmethod
    def make_mat3(mat: LMatrix3f) -> TransformState: ...
    def is_identity(self) -> bool: ...
    def is_invalid(self) -> bool: ...
    def is_singular(self) -> bool: ...
    def is_2d(self) -> bool: ...
    def has_components(self) -> bool: ...
    def components_given(self) -> bool: ...
    def hpr_given(self) -> bool: ...
    def quat_given(self) -> bool: ...
    def has_pos(self) -> bool: ...
    def has_hpr(self) -> bool: ...
    def has_quat(self) -> bool: ...
    def has_scale(self) -> bool: ...
    def has_identity_scale(self) -> bool: ...
    def has_uniform_scale(self) -> bool: ...
    def has_shear(self) -> bool: ...
    def has_nonzero_shear(self) -> bool: ...
    def has_mat(self) -> bool: ...
    def get_pos(self) -> LPoint3f: ...
    def get_hpr(self) -> LVecBase3f: ...
    def get_quat(self) -> LQuaternionf: ...
    def get_norm_quat(self) -> LQuaternionf: ...
    def get_scale(self) -> LVecBase3f: ...
    def get_uniform_scale(self) -> float: ...
    def get_shear(self) -> LVecBase3f: ...
    def get_mat(self) -> LMatrix4f: ...
    def get_pos2d(self) -> LVecBase2f: ...
    def get_rotate2d(self) -> float: ...
    def get_scale2d(self) -> LVecBase2f: ...
    def get_shear2d(self) -> float: ...
    def get_mat3(self) -> LMatrix3f: ...
    def set_pos(self, pos: _Vec3f) -> TransformState: ...
    def set_hpr(self, hpr: _Vec3f) -> TransformState: ...
    def set_quat(self, quat: _Vec4f) -> TransformState: ...
    def set_scale(self, scale: _Vec3f) -> TransformState: ...
    def set_shear(self, shear: _Vec3f) -> TransformState: ...
    def set_pos2d(self, pos: LVecBase2f) -> TransformState: ...
    def set_rotate2d(self, rotate: float) -> TransformState: ...
    def set_scale2d(self, scale: LVecBase2f) -> TransformState: ...
    def set_shear2d(self, shear: float) -> TransformState: ...
    def compose(self, other: TransformState) -> TransformState: ...
    def invert_compose(self, other: TransformState) -> TransformState: ...
    def get_inverse(self) -> TransformState: ...
    def get_unique(self) -> TransformState: ...
    def get_geom_rendering(self, geom_rendering: int) -> int: ...
    def cache_ref(self) -> None: ...
    def cache_unref(self) -> bool: ...
    def node_ref(self) -> None: ...
    def node_unref(self) -> bool: ...
    def get_composition_cache_num_entries(self) -> int: ...
    def get_invert_composition_cache_num_entries(self) -> int: ...
    def get_composition_cache_size(self) -> int: ...
    def get_composition_cache_source(self, n: int) -> TransformState: ...
    def get_composition_cache_result(self, n: int) -> TransformState: ...
    def get_invert_composition_cache_size(self) -> int: ...
    def get_invert_composition_cache_source(self, n: int) -> TransformState: ...
    def get_invert_composition_cache_result(self, n: int) -> TransformState: ...
    def validate_composition_cache(self) -> bool: ...
    def get_composition_cache(self) -> list[tuple[Any, Any] | tuple[None, None]]: ...
    def get_invert_composition_cache(self) -> list[tuple[Any, Any] | tuple[None, None]]: ...
    def output(self, out: ostream) -> None: ...
    def write(self, out: ostream, indent_level: int) -> None: ...
    def write_composition_cache(self, out: ostream, indent_level: int) -> None: ...
    @staticmethod
    def get_num_states() -> int: ...
    @staticmethod
    def get_num_unused_states() -> int: ...
    @staticmethod
    def clear_cache() -> int: ...
    @staticmethod
    def garbage_collect() -> int: ...
    @staticmethod
    def list_cycles(out: ostream) -> None: ...
    @staticmethod
    def list_states(out: ostream) -> None: ...
    @staticmethod
    def validate_states() -> bool: ...
    @staticmethod
    def get_states() -> list[TransformState]: ...
    @staticmethod
    def get_unused_states() -> list[TransformState]: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    compareTo = compare_to
    getHash = get_hash
    makeIdentity = make_identity
    makeInvalid = make_invalid
    makePos = make_pos
    makeHpr = make_hpr
    makeQuat = make_quat
    makePosHpr = make_pos_hpr
    makeScale = make_scale
    makeShear = make_shear
    makePosHprScale = make_pos_hpr_scale
    makePosQuatScale = make_pos_quat_scale
    makePosHprScaleShear = make_pos_hpr_scale_shear
    makePosQuatScaleShear = make_pos_quat_scale_shear
    makeMat = make_mat
    makePos2d = make_pos2d
    makeRotate2d = make_rotate2d
    makePosRotate2d = make_pos_rotate2d
    makeScale2d = make_scale2d
    makeShear2d = make_shear2d
    makePosRotateScale2d = make_pos_rotate_scale2d
    makePosRotateScaleShear2d = make_pos_rotate_scale_shear2d
    makeMat3 = make_mat3
    isIdentity = is_identity
    isInvalid = is_invalid
    isSingular = is_singular
    is2d = is_2d
    hasComponents = has_components
    componentsGiven = components_given
    hprGiven = hpr_given
    quatGiven = quat_given
    hasPos = has_pos
    hasHpr = has_hpr
    hasQuat = has_quat
    hasScale = has_scale
    hasIdentityScale = has_identity_scale
    hasUniformScale = has_uniform_scale
    hasShear = has_shear
    hasNonzeroShear = has_nonzero_shear
    hasMat = has_mat
    getPos = get_pos
    getHpr = get_hpr
    getQuat = get_quat
    getNormQuat = get_norm_quat
    getScale = get_scale
    getUniformScale = get_uniform_scale
    getShear = get_shear
    getMat = get_mat
    getPos2d = get_pos2d
    getRotate2d = get_rotate2d
    getScale2d = get_scale2d
    getShear2d = get_shear2d
    getMat3 = get_mat3
    setPos = set_pos
    setHpr = set_hpr
    setQuat = set_quat
    setScale = set_scale
    setShear = set_shear
    setPos2d = set_pos2d
    setRotate2d = set_rotate2d
    setScale2d = set_scale2d
    setShear2d = set_shear2d
    invertCompose = invert_compose
    getInverse = get_inverse
    getUnique = get_unique
    getGeomRendering = get_geom_rendering
    cacheRef = cache_ref
    cacheUnref = cache_unref
    nodeRef = node_ref
    nodeUnref = node_unref
    getCompositionCacheNumEntries = get_composition_cache_num_entries
    getInvertCompositionCacheNumEntries = get_invert_composition_cache_num_entries
    getCompositionCacheSize = get_composition_cache_size
    getCompositionCacheSource = get_composition_cache_source
    getCompositionCacheResult = get_composition_cache_result
    getInvertCompositionCacheSize = get_invert_composition_cache_size
    getInvertCompositionCacheSource = get_invert_composition_cache_source
    getInvertCompositionCacheResult = get_invert_composition_cache_result
    validateCompositionCache = validate_composition_cache
    getCompositionCache = get_composition_cache
    getInvertCompositionCache = get_invert_composition_cache
    writeCompositionCache = write_composition_cache
    getNumStates = get_num_states
    getNumUnusedStates = get_num_unused_states
    clearCache = clear_cache
    garbageCollect = garbage_collect
    listCycles = list_cycles
    listStates = list_states
    validateStates = validate_states
    getStates = get_states
    getUnusedStates = get_unused_states
    getClassType = get_class_type

class RenderAttribRegistry:
    """This class is used to associate each RenderAttrib with a different slot
    index at runtime, so we can store a list of RenderAttribs in the
    RenderState object, and very quickly look them up by type.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def get_slot(self, type_handle: TypeHandle) -> int: ...
    @staticmethod
    def get_max_slots() -> int: ...
    def get_num_slots(self) -> int: ...
    def get_slot_type(self, slot: int) -> TypeHandle: ...
    def get_slot_sort(self, slot: int) -> int: ...
    def set_slot_sort(self, slot: int, sort: int) -> None: ...
    def get_slot_default(self, slot: int) -> RenderAttrib: ...
    def get_num_sorted_slots(self) -> int: ...
    def get_sorted_slot(self, n: int) -> int: ...
    @staticmethod
    def get_global_ptr() -> RenderAttribRegistry: ...
    getSlot = get_slot
    getMaxSlots = get_max_slots
    getNumSlots = get_num_slots
    getSlotType = get_slot_type
    getSlotSort = get_slot_sort
    setSlotSort = set_slot_sort
    getSlotDefault = get_slot_default
    getNumSortedSlots = get_num_sorted_slots
    getSortedSlot = get_sorted_slot
    getGlobalPtr = get_global_ptr

class RenderAttrib(TypedWritableReferenceCount):
    """This is the base class for a number of render attributes (other than
    transform) that may be set on scene graph nodes to control the appearance
    of geometry.  This includes TextureAttrib, ColorAttrib, etc.
    
    RenderAttrib represents render attributes that always propagate down to the
    leaves without regard to the particular node they are assigned to.  A
    RenderAttrib will have the same effect on a leaf node whether it is
    assigned to the graph at the leaf or several nodes above.  This is
    different from RenderEffect, which represents a particular render property
    that is applied immediately to the node on which it is encountered, like
    billboarding or decaling.
    
    You should not attempt to create or modify a RenderAttrib directly;
    instead, use the make() method of the appropriate kind of attrib you want.
    This will allocate and return a new RenderAttrib of the appropriate type,
    and it may share pointers if possible.  Do not modify the new RenderAttrib
    if you wish to change its properties; instead, create a new one.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    M_none: ClassVar[Literal[0]]
    M_never: ClassVar[Literal[1]]
    M_less: ClassVar[Literal[2]]
    M_equal: ClassVar[Literal[3]]
    M_less_equal: ClassVar[Literal[4]]
    M_greater: ClassVar[Literal[5]]
    M_not_equal: ClassVar[Literal[6]]
    M_greater_equal: ClassVar[Literal[7]]
    M_always: ClassVar[Literal[8]]
    M_off: ClassVar[Literal[0]]
    M_eye_sphere_map: ClassVar[Literal[1]]
    M_world_cube_map: ClassVar[Literal[2]]
    M_eye_cube_map: ClassVar[Literal[3]]
    M_world_normal: ClassVar[Literal[4]]
    M_eye_normal: ClassVar[Literal[5]]
    M_world_position: ClassVar[Literal[6]]
    M_unused: ClassVar[Literal[7]]
    M_eye_position: ClassVar[Literal[8]]
    M_point_sprite: ClassVar[Literal[9]]
    M_unused2: ClassVar[Literal[10]]
    M_constant: ClassVar[Literal[11]]
    @property
    def slot(self) -> int: ...
    def compose(self, other: RenderAttrib) -> RenderAttrib: ...
    def invert_compose(self, other: RenderAttrib) -> RenderAttrib: ...
    def lower_attrib_can_override(self) -> bool: ...
    def compare_to(self, other: RenderAttrib) -> int: ...
    def get_hash(self) -> int: ...
    def get_unique(self) -> RenderAttrib: ...
    def output(self, out: ostream) -> None: ...
    def write(self, out: ostream, indent_level: int) -> None: ...
    @staticmethod
    def get_num_attribs() -> int: ...
    @staticmethod
    def list_attribs(out: ostream) -> None: ...
    @staticmethod
    def garbage_collect() -> int: ...
    @staticmethod
    def validate_attribs() -> bool: ...
    def get_slot(self) -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    invertCompose = invert_compose
    lowerAttribCanOverride = lower_attrib_can_override
    compareTo = compare_to
    getHash = get_hash
    getUnique = get_unique
    getNumAttribs = get_num_attribs
    listAttribs = list_attribs
    garbageCollect = garbage_collect
    validateAttribs = validate_attribs
    getSlot = get_slot
    getClassType = get_class_type
    MNone = M_none
    MNever = M_never
    MLess = M_less
    MEqual = M_equal
    MLessEqual = M_less_equal
    MGreater = M_greater
    MNotEqual = M_not_equal
    MGreaterEqual = M_greater_equal
    MAlways = M_always
    MOff = M_off
    MEyeSphereMap = M_eye_sphere_map
    MWorldCubeMap = M_world_cube_map
    MEyeCubeMap = M_eye_cube_map
    MWorldNormal = M_world_normal
    MEyeNormal = M_eye_normal
    MWorldPosition = M_world_position
    MUnused = M_unused
    MEyePosition = M_eye_position
    MPointSprite = M_point_sprite
    MUnused2 = M_unused2
    MConstant = M_constant

class RenderModeAttrib(RenderAttrib):
    """Specifies how polygons are to be drawn."""
    DtoolClassDict: ClassVar[dict[str, Any]]
    M_unchanged: ClassVar[Literal[0]]
    M_filled: ClassVar[Literal[1]]
    M_wireframe: ClassVar[Literal[2]]
    M_point: ClassVar[Literal[3]]
    M_filled_flat: ClassVar[Literal[4]]
    M_filled_wireframe: ClassVar[Literal[5]]
    @property
    def mode(self) -> _RenderModeAttrib_Mode: ...
    @property
    def thickness(self) -> float: ...
    @property
    def perspective(self) -> bool: ...
    @property
    def wireframe_color(self) -> LVecBase4f: ...
    @property
    def class_slot(self) -> int: ...
    @staticmethod
    def make(mode: _RenderModeAttrib_Mode, thickness: float = ..., perspective: bool = ..., wireframe_color: _Vec4f = ...) -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def get_mode(self) -> _RenderModeAttrib_Mode: ...
    def get_thickness(self) -> float: ...
    def get_perspective(self) -> bool: ...
    def get_wireframe_color(self) -> LVecBase4f: ...
    def get_geom_rendering(self, geom_rendering: int) -> int: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeDefault = make_default
    getMode = get_mode
    getThickness = get_thickness
    getPerspective = get_perspective
    getWireframeColor = get_wireframe_color
    getGeomRendering = get_geom_rendering
    getClassSlot = get_class_slot
    getClassType = get_class_type
    MUnchanged = M_unchanged
    MFilled = M_filled
    MWireframe = M_wireframe
    MPoint = M_point
    MFilledFlat = M_filled_flat
    MFilledWireframe = M_filled_wireframe

class TexMatrixAttrib(RenderAttrib):
    """Applies a transform matrix to UV's before they are rendered."""
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def class_slot(self) -> int: ...
    @overload
    @staticmethod
    def make() -> RenderAttrib: ...
    @overload
    @staticmethod
    def make(mat: _Mat4f) -> RenderAttrib: ...
    @overload
    @staticmethod
    def make(stage: TextureStage, transform: TransformState) -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def add_stage(self, stage: TextureStage, transform: TransformState, override: int = ...) -> RenderAttrib: ...
    def remove_stage(self, stage: TextureStage) -> RenderAttrib: ...
    def is_empty(self) -> bool: ...
    def has_stage(self, stage: TextureStage) -> bool: ...
    def get_num_stages(self) -> int: ...
    def get_stage(self, n: int) -> TextureStage: ...
    @overload
    def get_mat(self) -> LMatrix4f: ...
    @overload
    def get_mat(self, stage: TextureStage) -> LMatrix4f: ...
    def get_transform(self, stage: TextureStage) -> TransformState: ...
    def get_override(self, stage: TextureStage) -> int: ...
    def get_geom_rendering(self, geom_rendering: int) -> int: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    def get_stages(self) -> tuple[TextureStage, ...]: ...
    makeDefault = make_default
    addStage = add_stage
    removeStage = remove_stage
    isEmpty = is_empty
    hasStage = has_stage
    getNumStages = get_num_stages
    getStage = get_stage
    getMat = get_mat
    getTransform = get_transform
    getOverride = get_override
    getGeomRendering = get_geom_rendering
    getClassSlot = get_class_slot
    getClassType = get_class_type
    getStages = get_stages

class RenderState(NodeCachedReferenceCount):
    """This represents a unique collection of RenderAttrib objects that correspond
    to a particular renderable state.
    
    You should not attempt to create or modify a RenderState object directly.
    Instead, call one of the make() functions to create one for you.  And
    instead of modifying a RenderState object, create a new one.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def attribs(self) -> Mapping[Any, RenderAttrib]: ...
    def compare_to(self, other: RenderState) -> int: ...
    def compare_sort(self, other: RenderState) -> int: ...
    def compare_mask(self, other: RenderState, compare_mask: BitMask_uint32_t_32) -> int: ...
    def get_hash(self) -> int: ...
    def is_empty(self) -> bool: ...
    def has_cull_callback(self) -> bool: ...
    def cull_callback(self, trav: CullTraverser, data: CullTraverserData) -> bool: ...
    @staticmethod
    def make_empty() -> RenderState: ...
    @overload
    @staticmethod
    def make(attrib: RenderAttrib, override: int = ...) -> RenderState: ...
    @overload
    @staticmethod
    def make(attrib1: RenderAttrib, attrib2: RenderAttrib, override: int = ...) -> RenderState: ...
    @overload
    @staticmethod
    def make(attrib1: RenderAttrib, attrib2: RenderAttrib, attrib3: RenderAttrib, override: int = ...) -> RenderState: ...
    @overload
    @staticmethod
    def make(attrib1: RenderAttrib, attrib2: RenderAttrib, attrib3: RenderAttrib, attrib4: RenderAttrib, override: int = ...) -> RenderState: ...
    @overload
    @staticmethod
    def make(attrib1: RenderAttrib, attrib2: RenderAttrib, attrib3: RenderAttrib, attrib4: RenderAttrib, attrib5: RenderAttrib, override: int = ...) -> RenderState: ...
    def compose(self, other: RenderState) -> RenderState: ...
    def invert_compose(self, other: RenderState) -> RenderState: ...
    def add_attrib(self, attrib: RenderAttrib, override: int = ...) -> RenderState: ...
    @overload
    def set_attrib(self, attrib: RenderAttrib) -> RenderState: ...
    @overload
    def set_attrib(self, attrib: RenderAttrib, override: int) -> RenderState: ...
    @overload
    def remove_attrib(self, type: TypeHandle) -> RenderState: ...
    @overload
    def remove_attrib(self, slot: int) -> RenderState: ...
    def adjust_all_priorities(self, adjustment: int) -> RenderState: ...
    @overload
    def has_attrib(self, type: TypeHandle) -> bool: ...
    @overload
    def has_attrib(self, slot: int) -> bool: ...
    @overload
    def get_attrib(self, type: TypeHandle) -> RenderAttrib: ...
    @overload
    def get_attrib(self, slot: int) -> RenderAttrib: ...
    def get_attrib_def(self, slot: int) -> RenderAttrib: ...
    @overload
    def get_override(self, type: TypeHandle) -> int: ...
    @overload
    def get_override(self, slot: int) -> int: ...
    def get_unique(self) -> RenderState: ...
    def cache_ref(self) -> None: ...
    def cache_unref(self) -> bool: ...
    def node_ref(self) -> None: ...
    def node_unref(self) -> bool: ...
    def get_composition_cache_num_entries(self) -> int: ...
    def get_invert_composition_cache_num_entries(self) -> int: ...
    def get_composition_cache_size(self) -> int: ...
    def get_composition_cache_source(self, n: int) -> RenderState: ...
    def get_composition_cache_result(self, n: int) -> RenderState: ...
    def get_invert_composition_cache_size(self) -> int: ...
    def get_invert_composition_cache_source(self, n: int) -> RenderState: ...
    def get_invert_composition_cache_result(self, n: int) -> RenderState: ...
    def get_composition_cache(self) -> list[tuple[Any, Any] | tuple[None, None]]: ...
    def get_invert_composition_cache(self) -> list[tuple[Any, Any] | tuple[None, None]]: ...
    def output(self, out: ostream) -> None: ...
    def write(self, out: ostream, indent_level: int) -> None: ...
    @staticmethod
    def get_max_priority() -> int: ...
    @staticmethod
    def get_num_states() -> int: ...
    @staticmethod
    def get_num_unused_states() -> int: ...
    @staticmethod
    def clear_cache() -> int: ...
    @staticmethod
    def clear_munger_cache() -> None: ...
    @staticmethod
    def garbage_collect() -> int: ...
    @staticmethod
    def list_cycles(out: ostream) -> None: ...
    @staticmethod
    def list_states(out: ostream) -> None: ...
    @staticmethod
    def validate_states() -> bool: ...
    @staticmethod
    def get_states() -> list[RenderState]: ...
    @staticmethod
    def get_unused_states() -> list[RenderState]: ...
    def get_draw_order(self) -> int: ...
    def get_bin_index(self) -> int: ...
    def get_geom_rendering(self, geom_rendering: int) -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    compareTo = compare_to
    compareSort = compare_sort
    compareMask = compare_mask
    getHash = get_hash
    isEmpty = is_empty
    hasCullCallback = has_cull_callback
    cullCallback = cull_callback
    makeEmpty = make_empty
    invertCompose = invert_compose
    addAttrib = add_attrib
    setAttrib = set_attrib
    removeAttrib = remove_attrib
    adjustAllPriorities = adjust_all_priorities
    hasAttrib = has_attrib
    getAttrib = get_attrib
    getAttribDef = get_attrib_def
    getOverride = get_override
    getUnique = get_unique
    cacheRef = cache_ref
    cacheUnref = cache_unref
    nodeRef = node_ref
    nodeUnref = node_unref
    getCompositionCacheNumEntries = get_composition_cache_num_entries
    getInvertCompositionCacheNumEntries = get_invert_composition_cache_num_entries
    getCompositionCacheSize = get_composition_cache_size
    getCompositionCacheSource = get_composition_cache_source
    getCompositionCacheResult = get_composition_cache_result
    getInvertCompositionCacheSize = get_invert_composition_cache_size
    getInvertCompositionCacheSource = get_invert_composition_cache_source
    getInvertCompositionCacheResult = get_invert_composition_cache_result
    getCompositionCache = get_composition_cache
    getInvertCompositionCache = get_invert_composition_cache
    getMaxPriority = get_max_priority
    getNumStates = get_num_states
    getNumUnusedStates = get_num_unused_states
    clearCache = clear_cache
    clearMungerCache = clear_munger_cache
    garbageCollect = garbage_collect
    listCycles = list_cycles
    listStates = list_states
    validateStates = validate_states
    getStates = get_states
    getUnusedStates = get_unused_states
    getDrawOrder = get_draw_order
    getBinIndex = get_bin_index
    getGeomRendering = get_geom_rendering
    getClassType = get_class_type

class AlphaTestAttrib(RenderAttrib):
    """Enables or disables writing of pixel to framebuffer based on its alpha
    value relative to a reference alpha value
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def reference_alpha(self) -> float: ...
    @property
    def mode(self) -> _RenderAttrib_PandaCompareFunc: ...
    @property
    def class_slot(self) -> int: ...
    @staticmethod
    def make(mode: _RenderAttrib_PandaCompareFunc, reference_alpha: float) -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def get_reference_alpha(self) -> float: ...
    def get_mode(self) -> _RenderAttrib_PandaCompareFunc: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeDefault = make_default
    getReferenceAlpha = get_reference_alpha
    getMode = get_mode
    getClassSlot = get_class_slot
    getClassType = get_class_type

class AntialiasAttrib(RenderAttrib):
    """Specifies whether or how to enable antialiasing, if supported by the
    backend renderer.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    M_none: ClassVar[Literal[0]]
    M_point: ClassVar[Literal[1]]
    M_line: ClassVar[Literal[2]]
    M_polygon: ClassVar[Literal[4]]
    M_multisample: ClassVar[Literal[8]]
    M_auto: ClassVar[Literal[31]]
    M_type_mask: ClassVar[Literal[31]]
    M_faster: ClassVar[Literal[32]]
    M_better: ClassVar[Literal[64]]
    M_dont_care: ClassVar[Literal[96]]
    @property
    def mode(self) -> int: ...
    @property
    def mode_type(self) -> int: ...
    @property
    def mode_quality(self) -> int: ...
    @property
    def class_slot(self) -> int: ...
    @staticmethod
    def make(mode: int) -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def get_mode(self) -> int: ...
    def get_mode_type(self) -> int: ...
    def get_mode_quality(self) -> int: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeDefault = make_default
    getMode = get_mode
    getModeType = get_mode_type
    getModeQuality = get_mode_quality
    getClassSlot = get_class_slot
    getClassType = get_class_type
    MNone = M_none
    MPoint = M_point
    MLine = M_line
    MPolygon = M_polygon
    MMultisample = M_multisample
    MAuto = M_auto
    MTypeMask = M_type_mask
    MFaster = M_faster
    MBetter = M_better
    MDontCare = M_dont_care

class RenderEffect(TypedWritableReferenceCount):
    """This is the base class for a number of special render effects that may be
    set on scene graph nodes to change the way they render.  This includes
    BillboardEffect, DecalEffect, etc.
    
    RenderEffect represents render properties that must be applied as soon as
    they are encountered in the scene graph, rather than propagating down to
    the leaves.  This is different from RenderAttrib, which represents
    properties like color and texture that don't do anything until they
    propagate down to a GeomNode.
    
    You should not attempt to create or modify a RenderEffect directly;
    instead, use the make() method of the appropriate kind of effect you want.
    This will allocate and return a new RenderEffect of the appropriate type,
    and it may share pointers if possible.  Do not modify the new RenderEffect
    if you wish to change its properties; instead, create a new one.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def compare_to(self, other: RenderEffect) -> int: ...
    def output(self, out: ostream) -> None: ...
    def write(self, out: ostream, indent_level: int) -> None: ...
    @staticmethod
    def get_num_effects() -> int: ...
    @staticmethod
    def list_effects(out: ostream) -> None: ...
    @staticmethod
    def validate_effects() -> bool: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    compareTo = compare_to
    getNumEffects = get_num_effects
    listEffects = list_effects
    validateEffects = validate_effects
    getClassType = get_class_type

class RenderEffects(TypedWritableReferenceCount):
    """This represents a unique collection of RenderEffect objects that correspond
    to a particular renderable state.
    
    You should not attempt to create or modify a RenderEffects object directly.
    Instead, call one of the make() functions to create one for you.  And
    instead of modifying a RenderEffects object, create a new one.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __lt__(self, other: RenderEffects) -> bool: ...
    def __len__(self) -> int: ...
    @overload
    def __getitem__(self, type: TypeHandle) -> RenderEffect: ...
    @overload
    def __getitem__(self, n: int) -> RenderEffect: ...
    def is_empty(self) -> bool: ...
    def get_num_effects(self) -> int: ...
    @overload
    def get_effect(self, type: TypeHandle) -> RenderEffect: ...
    @overload
    def get_effect(self, n: int) -> RenderEffect: ...
    def find_effect(self, type: TypeHandle) -> int: ...
    @staticmethod
    def make_empty() -> RenderEffects: ...
    @overload
    @staticmethod
    def make(effect: RenderEffect) -> RenderEffects: ...
    @overload
    @staticmethod
    def make(effect1: RenderEffect, effect2: RenderEffect) -> RenderEffects: ...
    @overload
    @staticmethod
    def make(effect1: RenderEffect, effect2: RenderEffect, effect3: RenderEffect) -> RenderEffects: ...
    @overload
    @staticmethod
    def make(effect1: RenderEffect, effect2: RenderEffect, effect3: RenderEffect, effect4: RenderEffect) -> RenderEffects: ...
    def add_effect(self, effect: RenderEffect) -> RenderEffects: ...
    def remove_effect(self, type: TypeHandle) -> RenderEffects: ...
    def output(self, out: ostream) -> None: ...
    def write(self, out: ostream, indent_level: int) -> None: ...
    @staticmethod
    def get_num_states() -> int: ...
    @staticmethod
    def list_states(out: ostream) -> None: ...
    @staticmethod
    def validate_states() -> bool: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    isEmpty = is_empty
    getNumEffects = get_num_effects
    getEffect = get_effect
    findEffect = find_effect
    makeEmpty = make_empty
    addEffect = add_effect
    removeEffect = remove_effect
    getNumStates = get_num_states
    listStates = list_states
    validateStates = validate_states
    getClassType = get_class_type

class PandaNode(TypedWritableReferenceCount, Namable):
    """A basic node of the scene graph or data graph.  This is the base class of
    all specialized nodes, and also serves as a generic node with no special
    properties.
    """
    class Children:
        """This class is returned from get_children().  Use it to walk through the
        list of children.  This is faster, and safer, than walking through the
        children one at a time via get_num_children()/get_child(), since the list
        of children is saved out ahead of time, rather than having to reacquire
        the lock with each iteration, or to keep the lock held for the entire
        pass.
        """
        DtoolClassDict: ClassVar[dict[str, Any]]
        def __getitem__(self, n: int) -> PandaNode: ...
        def __len__(self) -> int: ...
    class Stashed:
        """Similarly for stashed children."""
        DtoolClassDict: ClassVar[dict[str, Any]]
        def __getitem__(self, n: int) -> PandaNode: ...
        def __len__(self) -> int: ...
    class Parents:
        """This class is returned from get_parents()."""
        DtoolClassDict: ClassVar[dict[str, Any]]
        def __getitem__(self, n: int) -> PandaNode: ...
        def __len__(self) -> int: ...
    DtoolClassDict: ClassVar[dict[str, Any]]
    state: RenderState
    effects: RenderEffects
    transform: TransformState
    tags: Mapping[Any, str]
    overall_hidden: bool
    into_collide_mask: BitMask_uint32_t_32
    final: bool
    UC_parents: ClassVar[Literal[1]]
    UC_children: ClassVar[Literal[2]]
    UC_transform: ClassVar[Literal[4]]
    UC_state: ClassVar[Literal[8]]
    UC_draw_mask: ClassVar[Literal[16]]
    FB_transform: ClassVar[Literal[1]]
    FB_state: ClassVar[Literal[2]]
    FB_effects: ClassVar[Literal[4]]
    FB_tag: ClassVar[Literal[16]]
    FB_draw_mask: ClassVar[Literal[32]]
    FB_cull_callback: ClassVar[Literal[64]]
    @property
    def prev_transform(self) -> TransformState: ...
    @property
    def python_tags(self) -> Any: ...
    @property
    def overall_bit(self) -> BitMask_uint32_t_32: ...
    @property
    def all_camera_mask(self) -> BitMask_uint32_t_32: ...
    @property
    def draw_control_mask(self) -> BitMask_uint32_t_32: ...
    @property
    def draw_show_mask(self) -> BitMask_uint32_t_32: ...
    @property
    def legal_collide_mask(self) -> BitMask_uint32_t_32: ...
    @property
    def bounds_type(self) -> _BoundingVolume_BoundsType: ...
    @property
    def nested_vertices(self) -> int: ...
    @property
    def internal_bounds(self) -> BoundingVolume: ...
    @property
    def internal_vertices(self) -> int: ...
    @property
    def bounds_stale(self) -> bool: ...
    @property
    def children(self) -> PandaNode.Children: ...
    @property
    def stashed(self) -> PandaNode.Stashed: ...
    @property
    def parents(self) -> PandaNode.Parents: ...
    def __init__(self, name: str) -> None: ...
    def __copy__(self) -> PandaNode: ...
    def __deepcopy__(self, memo: Any) -> Any: ...
    def upcast_to_TypedWritableReferenceCount(self) -> TypedWritableReferenceCount: ...
    def upcast_to_Namable(self) -> Namable: ...
    def combine_with(self, other: PandaNode) -> PandaNode: ...
    def make_copy(self) -> PandaNode: ...
    def copy_subgraph(self, current_thread: Thread = ...) -> PandaNode: ...
    def get_num_parents(self, current_thread: Thread = ...) -> int: ...
    def get_parent(self, n: int, current_thread: Thread = ...) -> PandaNode: ...
    def find_parent(self, node: PandaNode, current_thread: Thread = ...) -> int: ...
    def get_num_children(self, current_thread: Thread = ...) -> int: ...
    def get_child(self, n: int, current_thread: Thread = ...) -> PandaNode: ...
    def get_child_sort(self, n: int, current_thread: Thread = ...) -> int: ...
    def find_child(self, node: PandaNode, current_thread: Thread = ...) -> int: ...
    def count_num_descendants(self) -> int: ...
    def add_child(self, child_node: PandaNode, sort: int = ..., current_thread: Thread = ...) -> None: ...
    @overload
    def remove_child(self, child_node: PandaNode, current_thread: Thread = ...) -> bool: ...
    @overload
    def remove_child(self, child_index: int, current_thread: Thread = ...) -> None: ...
    def replace_child(self, orig_child: PandaNode, new_child: PandaNode, current_thread: Thread = ...) -> bool: ...
    @overload
    def stash_child(self, child_node: PandaNode, current_thread: Thread = ...) -> bool: ...
    @overload
    def stash_child(self, child_index: int, current_thread: Thread = ...) -> None: ...
    @overload
    def unstash_child(self, child_node: PandaNode, current_thread: Thread = ...) -> bool: ...
    @overload
    def unstash_child(self, stashed_index: int, current_thread: Thread = ...) -> None: ...
    def get_num_stashed(self, current_thread: Thread = ...) -> int: ...
    @overload
    def get_stashed(self, current_thread: Thread = ...) -> PandaNode.Stashed: ...
    @overload
    def get_stashed(self, n: int, current_thread: Thread = ...) -> PandaNode: ...
    def get_stashed_sort(self, n: int, current_thread: Thread = ...) -> int: ...
    def find_stashed(self, node: PandaNode, current_thread: Thread = ...) -> int: ...
    def add_stashed(self, child_node: PandaNode, sort: int = ..., current_thread: Thread = ...) -> None: ...
    def remove_stashed(self, child_index: int, current_thread: Thread = ...) -> None: ...
    def remove_all_children(self, current_thread: Thread = ...) -> None: ...
    def steal_children(self, other: PandaNode, current_thread: Thread = ...) -> None: ...
    def copy_children(self, other: PandaNode, current_thread: Thread = ...) -> None: ...
    def set_attrib(self, attrib: RenderAttrib, override: int = ...) -> None: ...
    @overload
    def get_attrib(self, type: TypeHandle) -> RenderAttrib: ...
    @overload
    def get_attrib(self, slot: int) -> RenderAttrib: ...
    @overload
    def has_attrib(self, type: TypeHandle) -> bool: ...
    @overload
    def has_attrib(self, slot: int) -> bool: ...
    @overload
    def clear_attrib(self, type: TypeHandle) -> None: ...
    @overload
    def clear_attrib(self, slot: int) -> None: ...
    def set_effect(self, effect: RenderEffect) -> None: ...
    def get_effect(self, type: TypeHandle) -> RenderEffect: ...
    def has_effect(self, type: TypeHandle) -> bool: ...
    def clear_effect(self, type: TypeHandle) -> None: ...
    def set_state(self, state: RenderState, current_thread: Thread = ...) -> None: ...
    def get_state(self, current_thread: Thread = ...) -> RenderState: ...
    def clear_state(self, current_thread: Thread = ...) -> None: ...
    def set_effects(self, effects: RenderEffects, current_thread: Thread = ...) -> None: ...
    def get_effects(self, current_thread: Thread = ...) -> RenderEffects: ...
    def clear_effects(self, current_thread: Thread = ...) -> None: ...
    def set_transform(self, transform: TransformState, current_thread: Thread = ...) -> None: ...
    def get_transform(self, current_thread: Thread = ...) -> TransformState: ...
    def clear_transform(self, current_thread: Thread = ...) -> None: ...
    def set_prev_transform(self, transform: TransformState, current_thread: Thread = ...) -> None: ...
    def get_prev_transform(self, current_thread: Thread = ...) -> TransformState: ...
    def reset_prev_transform(self, current_thread: Thread = ...) -> None: ...
    def has_dirty_prev_transform(self) -> bool: ...
    @staticmethod
    def reset_all_prev_transform(current_thread: Thread = ...) -> None: ...
    def set_tag(self, key: str, value: str, current_thread: Thread = ...) -> None: ...
    def get_tag(self, key: str, current_thread: Thread = ...) -> str: ...
    def has_tag(self, key: str, current_thread: Thread = ...) -> bool: ...
    def clear_tag(self, key: str, current_thread: Thread = ...) -> None: ...
    def get_tag_keys(self) -> Any: ...
    def get_python_tags(self) -> dict[Any, Any]: ...
    def set_python_tag(self, key: Any, value: Any) -> None: ...
    def get_python_tag(self, key: Any) -> Any: ...
    def has_python_tag(self, key: Any) -> bool: ...
    def clear_python_tag(self, key: Any) -> None: ...
    def get_python_tag_keys(self) -> Any: ...
    def has_tags(self) -> bool: ...
    def copy_tags(self, other: PandaNode) -> None: ...
    def list_tags(self, out: ostream, separator: str = ...) -> None: ...
    def compare_tags(self, other: PandaNode) -> int: ...
    def copy_all_properties(self, other: PandaNode) -> None: ...
    def replace_node(self, other: PandaNode) -> None: ...
    def set_unexpected_change(self, flags: int) -> None: ...
    def get_unexpected_change(self, flags: int) -> int: ...
    def clear_unexpected_change(self, flags: int) -> None: ...
    @staticmethod
    def get_overall_bit() -> BitMask_uint32_t_32: ...
    @staticmethod
    def get_all_camera_mask() -> BitMask_uint32_t_32: ...
    def is_overall_hidden(self) -> bool: ...
    def set_overall_hidden(self, overall_hidden: bool) -> None: ...
    def adjust_draw_mask(self, show_mask: BitMask_uint32_t_32, hide_mask: BitMask_uint32_t_32, clear_mask: BitMask_uint32_t_32) -> None: ...
    def get_draw_control_mask(self) -> BitMask_uint32_t_32: ...
    def get_draw_show_mask(self) -> BitMask_uint32_t_32: ...
    def get_net_draw_control_mask(self) -> BitMask_uint32_t_32: ...
    def get_net_draw_show_mask(self) -> BitMask_uint32_t_32: ...
    def set_into_collide_mask(self, mask: BitMask_uint32_t_32) -> None: ...
    def get_into_collide_mask(self) -> BitMask_uint32_t_32: ...
    def get_legal_collide_mask(self) -> BitMask_uint32_t_32: ...
    def get_net_collide_mask(self, current_thread: Thread = ...) -> BitMask_uint32_t_32: ...
    def get_off_clip_planes(self, current_thread: Thread = ...) -> RenderAttrib: ...
    def prepare_scene(self, gsg: GraphicsStateGuardianBase, node_state: RenderState) -> None: ...
    def is_scene_root(self) -> bool: ...
    def is_under_scene_root(self) -> bool: ...
    def output(self, out: ostream) -> None: ...
    def write(self, out: ostream, indent_level: int) -> None: ...
    def ls(self, out: ostream, indent_level: int) -> None: ...
    def set_bounds_type(self, bounds_type: _BoundingVolume_BoundsType) -> None: ...
    def get_bounds_type(self) -> _BoundingVolume_BoundsType: ...
    def set_bounds(self, volume: BoundingVolume) -> None: ...
    def set_bound(self, volume: BoundingVolume) -> None: ...
    def clear_bounds(self) -> None: ...
    @overload
    def get_bounds(self, current_thread: Thread = ...) -> BoundingVolume: ...
    @overload
    def get_bounds(self, seq: UpdateSeq, current_thread: Thread = ...) -> BoundingVolume: ...
    def get_nested_vertices(self, current_thread: Thread = ...) -> int: ...
    def get_internal_bounds(self, current_thread: Thread = ...) -> BoundingVolume: ...
    def get_internal_vertices(self, current_thread: Thread = ...) -> int: ...
    def mark_bounds_stale(self, current_thread: Thread = ...) -> None: ...
    def mark_internal_bounds_stale(self, current_thread: Thread = ...) -> None: ...
    def is_bounds_stale(self) -> bool: ...
    def set_final(self, flag: bool) -> None: ...
    def is_final(self, current_thread: Thread = ...) -> bool: ...
    def is_geom_node(self) -> bool: ...
    def is_lod_node(self) -> bool: ...
    def is_collision_node(self) -> bool: ...
    def as_light(self) -> Light: ...
    def is_ambient_light(self) -> bool: ...
    def get_fancy_bits(self, current_thread: Thread = ...) -> int: ...
    @staticmethod
    def decode_from_bam_stream(data: bytes, reader: BamReader = ...) -> PandaNode: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    def get_parents(self) -> tuple[PandaNode, ...]: ...
    def get_children(self) -> tuple[PandaNode, ...]: ...
    def get_stashed(self) -> tuple[PandaNode.Stashed, ...]: ...
    upcastToTypedWritableReferenceCount = upcast_to_TypedWritableReferenceCount
    upcastToNamable = upcast_to_Namable
    combineWith = combine_with
    makeCopy = make_copy
    copySubgraph = copy_subgraph
    getNumParents = get_num_parents
    getParent = get_parent
    findParent = find_parent
    getNumChildren = get_num_children
    getChild = get_child
    getChildSort = get_child_sort
    findChild = find_child
    countNumDescendants = count_num_descendants
    addChild = add_child
    removeChild = remove_child
    replaceChild = replace_child
    stashChild = stash_child
    unstashChild = unstash_child
    getNumStashed = get_num_stashed
    getStashed = get_stashed
    getStashedSort = get_stashed_sort
    findStashed = find_stashed
    addStashed = add_stashed
    removeStashed = remove_stashed
    removeAllChildren = remove_all_children
    stealChildren = steal_children
    copyChildren = copy_children
    setAttrib = set_attrib
    getAttrib = get_attrib
    hasAttrib = has_attrib
    clearAttrib = clear_attrib
    setEffect = set_effect
    getEffect = get_effect
    hasEffect = has_effect
    clearEffect = clear_effect
    setState = set_state
    getState = get_state
    clearState = clear_state
    setEffects = set_effects
    getEffects = get_effects
    clearEffects = clear_effects
    setTransform = set_transform
    getTransform = get_transform
    clearTransform = clear_transform
    setPrevTransform = set_prev_transform
    getPrevTransform = get_prev_transform
    resetPrevTransform = reset_prev_transform
    hasDirtyPrevTransform = has_dirty_prev_transform
    resetAllPrevTransform = reset_all_prev_transform
    setTag = set_tag
    getTag = get_tag
    hasTag = has_tag
    clearTag = clear_tag
    getTagKeys = get_tag_keys
    getPythonTags = get_python_tags
    setPythonTag = set_python_tag
    getPythonTag = get_python_tag
    hasPythonTag = has_python_tag
    clearPythonTag = clear_python_tag
    getPythonTagKeys = get_python_tag_keys
    hasTags = has_tags
    copyTags = copy_tags
    listTags = list_tags
    compareTags = compare_tags
    copyAllProperties = copy_all_properties
    replaceNode = replace_node
    setUnexpectedChange = set_unexpected_change
    getUnexpectedChange = get_unexpected_change
    clearUnexpectedChange = clear_unexpected_change
    getOverallBit = get_overall_bit
    getAllCameraMask = get_all_camera_mask
    isOverallHidden = is_overall_hidden
    setOverallHidden = set_overall_hidden
    adjustDrawMask = adjust_draw_mask
    getDrawControlMask = get_draw_control_mask
    getDrawShowMask = get_draw_show_mask
    getNetDrawControlMask = get_net_draw_control_mask
    getNetDrawShowMask = get_net_draw_show_mask
    setIntoCollideMask = set_into_collide_mask
    getIntoCollideMask = get_into_collide_mask
    getLegalCollideMask = get_legal_collide_mask
    getNetCollideMask = get_net_collide_mask
    getOffClipPlanes = get_off_clip_planes
    prepareScene = prepare_scene
    isSceneRoot = is_scene_root
    isUnderSceneRoot = is_under_scene_root
    setBoundsType = set_bounds_type
    getBoundsType = get_bounds_type
    setBounds = set_bounds
    setBound = set_bound
    clearBounds = clear_bounds
    getBounds = get_bounds
    getNestedVertices = get_nested_vertices
    getInternalBounds = get_internal_bounds
    getInternalVertices = get_internal_vertices
    markBoundsStale = mark_bounds_stale
    markInternalBoundsStale = mark_internal_bounds_stale
    isBoundsStale = is_bounds_stale
    setFinal = set_final
    isFinal = is_final
    isGeomNode = is_geom_node
    isLodNode = is_lod_node
    isCollisionNode = is_collision_node
    asLight = as_light
    isAmbientLight = is_ambient_light
    getFancyBits = get_fancy_bits
    decodeFromBamStream = decode_from_bam_stream
    getClassType = get_class_type
    getParents = get_parents
    getChildren = get_children
    getStashed = get_stashed
    UCParents = UC_parents
    UCChildren = UC_children
    UCTransform = UC_transform
    UCState = UC_state
    UCDrawMask = UC_draw_mask
    FBTransform = FB_transform
    FBState = FB_state
    FBEffects = FB_effects
    FBTag = FB_tag
    FBDrawMask = FB_draw_mask
    FBCullCallback = FB_cull_callback

class TransparencyAttrib(RenderAttrib):
    """This controls the enabling of transparency.  Simply setting an alpha
    component to non-1 does not in itself make an object transparent; you must
    also enable transparency mode with a suitable TransparencyAttrib.
    Similarly, it is wasteful to render an object with a TransparencyAttrib in
    effect unless you actually want it to be at least partially transparent
    (and it has alpha components less than 1).
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    M_none: ClassVar[Literal[0]]
    M_alpha: ClassVar[Literal[1]]
    M_premultiplied_alpha: ClassVar[Literal[2]]
    M_multisample: ClassVar[Literal[3]]
    M_multisample_mask: ClassVar[Literal[4]]
    M_binary: ClassVar[Literal[5]]
    M_dual: ClassVar[Literal[6]]
    @property
    def mode(self) -> _TransparencyAttrib_Mode: ...
    @property
    def class_slot(self) -> int: ...
    @staticmethod
    def make(mode: _TransparencyAttrib_Mode) -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def get_mode(self) -> _TransparencyAttrib_Mode: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeDefault = make_default
    getMode = get_mode
    getClassSlot = get_class_slot
    getClassType = get_class_type
    MNone = M_none
    MAlpha = M_alpha
    MPremultipliedAlpha = M_premultiplied_alpha
    MMultisample = M_multisample
    MMultisampleMask = M_multisample_mask
    MBinary = M_binary
    MDual = M_dual

class LogicOpAttrib(RenderAttrib):
    """If enabled, specifies that a custom logical operation be performed instead
    of any color blending.  Setting it to a value other than M_none will cause
    color blending to be disabled and the given logic operation to be performed.
    
    @since 1.10.0
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    O_none: ClassVar[Literal[0]]
    O_clear: ClassVar[Literal[1]]
    O_and: ClassVar[Literal[2]]
    O_and_reverse: ClassVar[Literal[3]]
    O_copy: ClassVar[Literal[4]]
    O_and_inverted: ClassVar[Literal[5]]
    O_noop: ClassVar[Literal[6]]
    O_xor: ClassVar[Literal[7]]
    O_or: ClassVar[Literal[8]]
    O_nor: ClassVar[Literal[9]]
    O_equivalent: ClassVar[Literal[10]]
    O_invert: ClassVar[Literal[11]]
    O_or_reverse: ClassVar[Literal[12]]
    O_copy_inverted: ClassVar[Literal[13]]
    O_or_inverted: ClassVar[Literal[14]]
    O_nand: ClassVar[Literal[15]]
    O_set: ClassVar[Literal[16]]
    @property
    def operation(self) -> _LogicOpAttrib_Operation: ...
    @property
    def class_slot(self) -> int: ...
    @staticmethod
    def make_off() -> RenderAttrib: ...
    @staticmethod
    def make(op: _LogicOpAttrib_Operation) -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def get_operation(self) -> _LogicOpAttrib_Operation: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeOff = make_off
    makeDefault = make_default
    getOperation = get_operation
    getClassSlot = get_class_slot
    getClassType = get_class_type
    ONone = O_none
    OClear = O_clear
    OAnd = O_and
    OAndReverse = O_and_reverse
    OCopy = O_copy
    OAndInverted = O_and_inverted
    ONoop = O_noop
    OXor = O_xor
    OOr = O_or
    ONor = O_nor
    OEquivalent = O_equivalent
    OInvert = O_invert
    OOrReverse = O_or_reverse
    OCopyInverted = O_copy_inverted
    OOrInverted = O_or_inverted
    ONand = O_nand
    OSet = O_set

class ShaderInput:
    """This is a small container class that can hold any one of the value types
    that can be passed as input to a shader.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    A_read: ClassVar[Literal[1]]
    A_write: ClassVar[Literal[2]]
    A_layered: ClassVar[Literal[4]]
    M_invalid: ClassVar[Literal[0]]
    M_texture: ClassVar[Literal[1]]
    M_nodepath: ClassVar[Literal[2]]
    M_vector: ClassVar[Literal[3]]
    M_numeric: ClassVar[Literal[4]]
    M_texture_sampler: ClassVar[Literal[5]]
    M_param: ClassVar[Literal[6]]
    M_texture_image: ClassVar[Literal[7]]
    M_buffer: ClassVar[Literal[8]]
    @overload
    def __init__(self, __param0: ShaderInput) -> None: ...
    @overload
    def __init__(self, name: InternalName, priority: int = ...) -> None: ...
    @overload
    def __init__(self, name: InternalName, value: Any, priority: int = ...) -> None: ...
    @overload
    def __init__(self, name: InternalName, tex: Texture, sampler: SamplerState, priority: int = ...) -> None: ...
    @overload
    def __init__(self, name: InternalName, tex: Texture, read: bool, write: bool, z: int = ..., n: int = ..., priority: int = ...) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...
    def __lt__(self, other: ShaderInput) -> bool: ...
    def __le__(self, other: ShaderInput) -> bool: ...
    @staticmethod
    def get_blank() -> ShaderInput: ...
    def add_hash(self, hash: int) -> int: ...
    def get_name(self) -> InternalName: ...
    def get_value_type(self) -> int: ...
    def get_priority(self) -> int: ...
    def get_vector(self) -> LVecBase4f: ...
    def get_nodepath(self) -> NodePath: ...
    def get_texture(self) -> Texture: ...
    def get_sampler(self) -> SamplerState: ...
    getBlank = get_blank
    addHash = add_hash
    getName = get_name
    getValueType = get_value_type
    getPriority = get_priority
    getVector = get_vector
    getNodepath = get_nodepath
    getTexture = get_texture
    getSampler = get_sampler
    ARead = A_read
    AWrite = A_write
    ALayered = A_layered
    MInvalid = M_invalid
    MTexture = M_texture
    MNodepath = M_nodepath
    MVector = M_vector
    MNumeric = M_numeric
    MTextureSampler = M_texture_sampler
    MParam = M_param
    MTextureImage = M_texture_image
    MBuffer = M_buffer

class InternalNameCollection:
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, copy: InternalNameCollection) -> None: ...
    def __getitem__(self, index: int) -> InternalName: ...
    def __len__(self) -> int: ...
    def __iadd__(self, other: InternalNameCollection) -> InternalNameCollection: ...
    def __add__(self, other: InternalNameCollection) -> InternalNameCollection: ...
    def assign(self, copy: InternalNameCollection) -> InternalNameCollection: ...
    def add_name(self, name: InternalName) -> None: ...
    def remove_name(self, name: InternalName) -> bool: ...
    def add_names_from(self, other: InternalNameCollection) -> None: ...
    def remove_names_from(self, other: InternalNameCollection) -> None: ...
    def remove_duplicate_names(self) -> None: ...
    def has_name(self, name: InternalName) -> bool: ...
    def clear(self) -> None: ...
    def get_num_names(self) -> int: ...
    def get_name(self, index: int) -> InternalName: ...
    def output(self, out: ostream) -> None: ...
    def write(self, out: ostream, indent_level: int = ...) -> None: ...
    def get_names(self) -> tuple[InternalName, ...]: ...
    addName = add_name
    removeName = remove_name
    addNamesFrom = add_names_from
    removeNamesFrom = remove_names_from
    removeDuplicateNames = remove_duplicate_names
    hasName = has_name
    getNumNames = get_num_names
    getName = get_name
    getNames = get_names

class MaterialCollection:
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, copy: MaterialCollection) -> None: ...
    def __getitem__(self, index: int) -> Material: ...
    def __len__(self) -> int: ...
    def __iadd__(self, other: MaterialCollection) -> MaterialCollection: ...
    def __add__(self, other: MaterialCollection) -> MaterialCollection: ...
    def assign(self, copy: MaterialCollection) -> MaterialCollection: ...
    def add_material(self, node_material: Material) -> None: ...
    def remove_material(self, node_material: Material) -> bool: ...
    def add_materials_from(self, other: MaterialCollection) -> None: ...
    def remove_materials_from(self, other: MaterialCollection) -> None: ...
    def remove_duplicate_materials(self) -> None: ...
    def has_material(self, material: Material) -> bool: ...
    def clear(self) -> None: ...
    def find_material(self, name: str) -> Material: ...
    def get_num_materials(self) -> int: ...
    def get_material(self, index: int) -> Material: ...
    def output(self, out: ostream) -> None: ...
    def write(self, out: ostream, indent_level: int = ...) -> None: ...
    addMaterial = add_material
    removeMaterial = remove_material
    addMaterialsFrom = add_materials_from
    removeMaterialsFrom = remove_materials_from
    removeDuplicateMaterials = remove_duplicate_materials
    hasMaterial = has_material
    findMaterial = find_material
    getNumMaterials = get_num_materials
    getMaterial = get_material

class TextureStageCollection:
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, copy: TextureStageCollection) -> None: ...
    def __getitem__(self, index: int) -> TextureStage: ...
    def __len__(self) -> int: ...
    def __iadd__(self, other: TextureStageCollection) -> TextureStageCollection: ...
    def __add__(self, other: TextureStageCollection) -> TextureStageCollection: ...
    def assign(self, copy: TextureStageCollection) -> TextureStageCollection: ...
    def add_texture_stage(self, node_texture_stage: TextureStage) -> None: ...
    def remove_texture_stage(self, node_texture_stage: TextureStage) -> bool: ...
    def add_texture_stages_from(self, other: TextureStageCollection) -> None: ...
    def remove_texture_stages_from(self, other: TextureStageCollection) -> None: ...
    def remove_duplicate_texture_stages(self) -> None: ...
    def has_texture_stage(self, texture_stage: TextureStage) -> bool: ...
    def clear(self) -> None: ...
    def find_texture_stage(self, name: str) -> TextureStage: ...
    def get_num_texture_stages(self) -> int: ...
    def get_texture_stage(self, index: int) -> TextureStage: ...
    def sort(self) -> None: ...
    def output(self, out: ostream) -> None: ...
    def write(self, out: ostream, indent_level: int = ...) -> None: ...
    def get_texture_stages(self) -> tuple[TextureStage, ...]: ...
    addTextureStage = add_texture_stage
    removeTextureStage = remove_texture_stage
    addTextureStagesFrom = add_texture_stages_from
    removeTextureStagesFrom = remove_texture_stages_from
    removeDuplicateTextureStages = remove_duplicate_texture_stages
    hasTextureStage = has_texture_stage
    findTextureStage = find_texture_stage
    getNumTextureStages = get_num_texture_stages
    getTextureStage = get_texture_stage
    getTextureStages = get_texture_stages

class NodePath:
    """NodePath is the fundamental system for disambiguating instances, and also
    provides a higher-level interface for manipulating the scene graph.
    
    A NodePath is a list of connected nodes from the root of the graph to any
    sub-node.  Each NodePath therefore uniquely describes one instance of a
    node.
    
    NodePaths themselves are lightweight objects that may easily be copied and
    passed by value.  Their data is stored as a series of NodePathComponents
    that are stored on the nodes.  Holding a NodePath will keep a reference
    count to all the nodes in the path.  However, if any node in the path is
    removed or reparented (perhaps through a different NodePath), the NodePath
    will automatically be updated to reflect the changes.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    name: str
    ET_ok: ClassVar[Literal[0]]
    ET_not_found: ClassVar[Literal[1]]
    ET_removed: ClassVar[Literal[2]]
    ET_fail: ClassVar[Literal[3]]
    @property
    def nodes(self) -> Sequence[PandaNode]: ...
    @property
    def ancestors(self) -> Sequence[NodePath]: ...
    @property
    def error_type(self) -> _NodePath_ErrorType: ...
    @property
    def children(self) -> NodePathCollection: ...
    @property
    def stashed_children(self) -> NodePathCollection: ...
    @property
    def parent(self) -> NodePath: ...
    @property
    def sort(self) -> int: ...
    @property
    def net_tags(self) -> Mapping[Any, str]: ...
    @property
    def tags(self) -> Any: ...
    @property
    def python_tags(self) -> Any: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, copy: NodePath) -> None: ...
    @overload
    def __init__(self, node: PandaNode, current_thread: Thread = ...) -> None: ...
    @overload
    def __init__(self, top_node_name: str, current_thread: Thread = ...) -> None: ...
    @overload
    def __init__(self, parent: NodePath, child_node: PandaNode, current_thread: Thread = ...) -> None: ...
    def __bool__(self) -> bool: ...
    def __copy__(self) -> NodePath: ...
    def __deepcopy__(self, memo: Any) -> Any: ...
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...
    def __lt__(self, other: NodePath | WeakNodePath) -> bool: ...
    def __le__(self, other: NodePath | WeakNodePath) -> bool: ...
    @staticmethod
    def any_path(node: PandaNode, current_thread: Thread = ...) -> NodePath: ...
    def assign(self, copy: NodePath) -> NodePath: ...
    def clear(self) -> None: ...
    @staticmethod
    def not_found() -> NodePath: ...
    @staticmethod
    def removed() -> NodePath: ...
    @staticmethod
    def fail() -> NodePath: ...
    @staticmethod
    def set_max_search_depth(max_search_depth: int) -> None: ...
    @staticmethod
    def get_max_search_depth() -> int: ...
    def is_empty(self) -> bool: ...
    def is_singleton(self, current_thread: Thread = ...) -> bool: ...
    def get_num_nodes(self, current_thread: Thread = ...) -> int: ...
    def get_node(self, index: int, current_thread: Thread = ...) -> PandaNode: ...
    def get_ancestor(self, index: int, current_thread: Thread = ...) -> NodePath: ...
    def get_error_type(self) -> _NodePath_ErrorType: ...
    def get_top_node(self, current_thread: Thread = ...) -> PandaNode: ...
    def get_top(self, current_thread: Thread = ...) -> NodePath: ...
    def node(self) -> PandaNode: ...
    def get_key(self) -> int: ...
    def add_hash(self, hash: int) -> int: ...
    def is_same_graph(self, other: NodePath, current_thread: Thread = ...) -> bool: ...
    def is_ancestor_of(self, other: NodePath, current_thread: Thread = ...) -> bool: ...
    def get_common_ancestor(self, other: NodePath, current_thread: Thread = ...) -> NodePath: ...
    def get_children(self, current_thread: Thread = ...) -> NodePathCollection: ...
    def get_num_children(self, current_thread: Thread = ...) -> int: ...
    def get_child(self, n: int, current_thread: Thread = ...) -> NodePath: ...
    def get_stashed_children(self, current_thread: Thread = ...) -> NodePathCollection: ...
    def count_num_descendants(self) -> int: ...
    def has_parent(self, current_thread: Thread = ...) -> bool: ...
    def get_parent(self, current_thread: Thread = ...) -> NodePath: ...
    def get_sort(self, current_thread: Thread = ...) -> int: ...
    def find(self, path: str) -> NodePath: ...
    def find_path_to(self, node: PandaNode) -> NodePath: ...
    def find_all_matches(self, path: str) -> NodePathCollection: ...
    def find_all_paths_to(self, node: PandaNode) -> NodePathCollection: ...
    def reparent_to(self, other: NodePath, sort: int = ..., current_thread: Thread = ...) -> None: ...
    def stash_to(self, other: NodePath, sort: int = ..., current_thread: Thread = ...) -> None: ...
    def wrt_reparent_to(self, other: NodePath, sort: int = ..., current_thread: Thread = ...) -> None: ...
    def instance_to(self, other: NodePath, sort: int = ..., current_thread: Thread = ...) -> NodePath: ...
    def instance_under_node(self, other: NodePath, name: str, sort: int = ..., current_thread: Thread = ...) -> NodePath: ...
    def copy_to(self, other: NodePath, sort: int = ..., current_thread: Thread = ...) -> NodePath: ...
    @overload
    def attach_new_node(self, node: PandaNode, sort: int = ..., current_thread: Thread = ...) -> NodePath: ...
    @overload
    def attach_new_node(self, name: str, sort: int = ..., current_thread: Thread = ...) -> NodePath: ...
    def remove_node(self, current_thread: Thread = ...) -> None: ...
    def detach_node(self, current_thread: Thread = ...) -> None: ...
    def output(self, out: ostream) -> None: ...
    @overload
    def ls(self) -> None: ...
    @overload
    def ls(self, out: ostream, indent_level: int = ...) -> None: ...
    @overload
    def reverse_ls(self) -> None: ...
    @overload
    def reverse_ls(self, out: ostream, indent_level: int = ...) -> int: ...
    @overload
    def get_state(self, current_thread: Thread = ...) -> RenderState: ...
    @overload
    def get_state(self, other: NodePath, current_thread: Thread = ...) -> RenderState: ...
    @overload
    def set_state(self, state: RenderState, current_thread: Thread = ...) -> None: ...
    @overload
    def set_state(self, other: NodePath, state: RenderState, current_thread: Thread = ...) -> None: ...
    def get_net_state(self, current_thread: Thread = ...) -> RenderState: ...
    def set_attrib(self, attrib: RenderAttrib, priority: int = ...) -> None: ...
    def get_attrib(self, type: TypeHandle) -> RenderAttrib: ...
    def has_attrib(self, type: TypeHandle) -> bool: ...
    def clear_attrib(self, type: TypeHandle) -> None: ...
    def set_effect(self, effect: RenderEffect) -> None: ...
    def get_effect(self, type: TypeHandle) -> RenderEffect: ...
    def has_effect(self, type: TypeHandle) -> bool: ...
    def clear_effect(self, type: TypeHandle) -> None: ...
    def set_effects(self, effects: RenderEffects) -> None: ...
    def get_effects(self) -> RenderEffects: ...
    def clear_effects(self) -> None: ...
    @overload
    def get_transform(self, current_thread: Thread = ...) -> TransformState: ...
    @overload
    def get_transform(self, other: NodePath, current_thread: Thread = ...) -> TransformState: ...
    @overload
    def clear_transform(self, current_thread: Thread = ...) -> None: ...
    @overload
    def clear_transform(self, other: NodePath, current_thread: Thread = ...) -> None: ...
    @overload
    def set_transform(self, transform: TransformState, current_thread: Thread = ...) -> None: ...
    @overload
    def set_transform(self, other: NodePath, transform: TransformState, current_thread: Thread = ...) -> None: ...
    def get_net_transform(self, current_thread: Thread = ...) -> TransformState: ...
    @overload
    def get_prev_transform(self, current_thread: Thread = ...) -> TransformState: ...
    @overload
    def get_prev_transform(self, other: NodePath, current_thread: Thread = ...) -> TransformState: ...
    @overload
    def set_prev_transform(self, transform: TransformState, current_thread: Thread = ...) -> None: ...
    @overload
    def set_prev_transform(self, other: NodePath, transform: TransformState, current_thread: Thread = ...) -> None: ...
    def get_net_prev_transform(self, current_thread: Thread = ...) -> TransformState: ...
    @overload
    def set_pos(self, pos: _Vec3f) -> None: ...
    @overload
    def set_pos(self, other: NodePath, pos: _Vec3f) -> None: ...
    @overload
    def set_pos(self, x: float, y: float, z: float) -> None: ...
    @overload
    def set_pos(self, other: NodePath, x: float, y: float, z: float) -> None: ...
    @overload
    def set_x(self, x: float) -> None: ...
    @overload
    def set_x(self, other: NodePath, x: float) -> None: ...
    @overload
    def set_y(self, y: float) -> None: ...
    @overload
    def set_y(self, other: NodePath, y: float) -> None: ...
    @overload
    def set_z(self, z: float) -> None: ...
    @overload
    def set_z(self, other: NodePath, z: float) -> None: ...
    @overload
    def set_fluid_pos(self, pos: _Vec3f) -> None: ...
    @overload
    def set_fluid_pos(self, other: NodePath, pos: _Vec3f) -> None: ...
    @overload
    def set_fluid_pos(self, x: float, y: float, z: float) -> None: ...
    @overload
    def set_fluid_pos(self, other: NodePath, x: float, y: float, z: float) -> None: ...
    @overload
    def set_fluid_x(self, x: float) -> None: ...
    @overload
    def set_fluid_x(self, other: NodePath, x: float) -> None: ...
    @overload
    def set_fluid_y(self, y: float) -> None: ...
    @overload
    def set_fluid_y(self, other: NodePath, y: float) -> None: ...
    @overload
    def set_fluid_z(self, z: float) -> None: ...
    @overload
    def set_fluid_z(self, other: NodePath, z: float) -> None: ...
    @overload
    def get_pos(self) -> LPoint3f: ...
    @overload
    def get_pos(self, other: NodePath) -> LPoint3f: ...
    @overload
    def get_x(self) -> float: ...
    @overload
    def get_x(self, other: NodePath) -> float: ...
    @overload
    def get_y(self) -> float: ...
    @overload
    def get_y(self, other: NodePath) -> float: ...
    @overload
    def get_z(self) -> float: ...
    @overload
    def get_z(self, other: NodePath) -> float: ...
    @overload
    def get_pos_delta(self) -> LVector3f: ...
    @overload
    def get_pos_delta(self, other: NodePath) -> LVector3f: ...
    @overload
    def set_hpr(self, hpr: _Vec3f) -> None: ...
    @overload
    def set_hpr(self, other: NodePath, hpr: _Vec3f) -> None: ...
    @overload
    def set_hpr(self, h: float, p: float, r: float) -> None: ...
    @overload
    def set_hpr(self, other: NodePath, h: float, p: float, r: float) -> None: ...
    @overload
    def set_h(self, h: float) -> None: ...
    @overload
    def set_h(self, other: NodePath, h: float) -> None: ...
    @overload
    def set_p(self, p: float) -> None: ...
    @overload
    def set_p(self, other: NodePath, p: float) -> None: ...
    @overload
    def set_r(self, r: float) -> None: ...
    @overload
    def set_r(self, other: NodePath, r: float) -> None: ...
    @overload
    def get_hpr(self) -> LVecBase3f: ...
    @overload
    def get_hpr(self, other: NodePath) -> LVecBase3f: ...
    @overload
    def get_h(self) -> float: ...
    @overload
    def get_h(self, other: NodePath) -> float: ...
    @overload
    def get_p(self) -> float: ...
    @overload
    def get_p(self, other: NodePath) -> float: ...
    @overload
    def get_r(self) -> float: ...
    @overload
    def get_r(self, other: NodePath) -> float: ...
    @overload
    def set_quat(self, quat: _Vec4f) -> None: ...
    @overload
    def set_quat(self, other: NodePath, quat: _Vec4f) -> None: ...
    @overload
    def get_quat(self) -> LQuaternionf: ...
    @overload
    def get_quat(self, other: NodePath) -> LQuaternionf: ...
    @overload
    def set_scale(self, scale: _Vec3f | float) -> None: ...
    @overload
    def set_scale(self, other: NodePath, scale: _Vec3f | float) -> None: ...
    @overload
    def set_scale(self, sx: float, sy: float, sz: float) -> None: ...
    @overload
    def set_scale(self, other: NodePath, sx: float, sy: float, sz: float) -> None: ...
    @overload
    def set_sx(self, sx: float) -> None: ...
    @overload
    def set_sx(self, other: NodePath, sx: float) -> None: ...
    @overload
    def set_sy(self, sy: float) -> None: ...
    @overload
    def set_sy(self, other: NodePath, sy: float) -> None: ...
    @overload
    def set_sz(self, sz: float) -> None: ...
    @overload
    def set_sz(self, other: NodePath, sz: float) -> None: ...
    @overload
    def get_scale(self) -> LVecBase3f: ...
    @overload
    def get_scale(self, other: NodePath) -> LVecBase3f: ...
    @overload
    def get_sx(self) -> float: ...
    @overload
    def get_sx(self, other: NodePath) -> float: ...
    @overload
    def get_sy(self) -> float: ...
    @overload
    def get_sy(self, other: NodePath) -> float: ...
    @overload
    def get_sz(self) -> float: ...
    @overload
    def get_sz(self, other: NodePath) -> float: ...
    @overload
    def set_shear(self, shear: _Vec3f) -> None: ...
    @overload
    def set_shear(self, other: NodePath, shear: _Vec3f) -> None: ...
    @overload
    def set_shear(self, shxy: float, shxz: float, shyz: float) -> None: ...
    @overload
    def set_shear(self, other: NodePath, shxy: float, shxz: float, shyz: float) -> None: ...
    @overload
    def set_shxy(self, shxy: float) -> None: ...
    @overload
    def set_shxy(self, other: NodePath, shxy: float) -> None: ...
    @overload
    def set_shxz(self, shxz: float) -> None: ...
    @overload
    def set_shxz(self, other: NodePath, shxz: float) -> None: ...
    @overload
    def set_shyz(self, shyz: float) -> None: ...
    @overload
    def set_shyz(self, other: NodePath, shyz: float) -> None: ...
    @overload
    def get_shear(self) -> LVecBase3f: ...
    @overload
    def get_shear(self, other: NodePath) -> LVecBase3f: ...
    @overload
    def get_shxy(self) -> float: ...
    @overload
    def get_shxy(self, other: NodePath) -> float: ...
    @overload
    def get_shxz(self) -> float: ...
    @overload
    def get_shxz(self, other: NodePath) -> float: ...
    @overload
    def get_shyz(self) -> float: ...
    @overload
    def get_shyz(self, other: NodePath) -> float: ...
    @overload
    def set_pos_hpr(self, pos: _Vec3f, hpr: _Vec3f) -> None: ...
    @overload
    def set_pos_hpr(self, other: NodePath, pos: _Vec3f, hpr: _Vec3f) -> None: ...
    @overload
    def set_pos_hpr(self, x: float, y: float, z: float, h: float, p: float, r: float) -> None: ...
    @overload
    def set_pos_hpr(self, other: NodePath, x: float, y: float, z: float, h: float, p: float, r: float) -> None: ...
    @overload
    def set_pos_quat(self, pos: _Vec3f, quat: _Vec4f) -> None: ...
    @overload
    def set_pos_quat(self, other: NodePath, pos: _Vec3f, quat: _Vec4f) -> None: ...
    @overload
    def set_hpr_scale(self, hpr: _Vec3f, scale: _Vec3f) -> None: ...
    @overload
    def set_hpr_scale(self, other: NodePath, hpr: _Vec3f, scale: _Vec3f) -> None: ...
    @overload
    def set_hpr_scale(self, h: float, p: float, r: float, sx: float, sy: float, sz: float) -> None: ...
    @overload
    def set_hpr_scale(self, other: NodePath, h: float, p: float, r: float, sx: float, sy: float, sz: float) -> None: ...
    @overload
    def set_quat_scale(self, quat: _Vec4f, scale: _Vec3f) -> None: ...
    @overload
    def set_quat_scale(self, other: NodePath, quat: _Vec4f, scale: _Vec3f) -> None: ...
    @overload
    def set_pos_hpr_scale(self, pos: _Vec3f, hpr: _Vec3f, scale: _Vec3f) -> None: ...
    @overload
    def set_pos_hpr_scale(self, other: NodePath, pos: _Vec3f, hpr: _Vec3f, scale: _Vec3f) -> None: ...
    @overload
    def set_pos_hpr_scale(self, x: float, y: float, z: float, h: float, p: float, r: float, sx: float, sy: float, sz: float) -> None: ...
    @overload
    def set_pos_hpr_scale(self, other: NodePath, x: float, y: float, z: float, h: float, p: float, r: float, sx: float, sy: float, sz: float) -> None: ...
    @overload
    def set_pos_quat_scale(self, pos: _Vec3f, quat: _Vec4f, scale: _Vec3f) -> None: ...
    @overload
    def set_pos_quat_scale(self, other: NodePath, pos: _Vec3f, quat: _Vec4f, scale: _Vec3f) -> None: ...
    @overload
    def set_pos_hpr_scale_shear(self, pos: _Vec3f, hpr: _Vec3f, scale: _Vec3f, shear: _Vec3f) -> None: ...
    @overload
    def set_pos_hpr_scale_shear(self, other: NodePath, pos: _Vec3f, hpr: _Vec3f, scale: _Vec3f, shear: _Vec3f) -> None: ...
    @overload
    def set_pos_quat_scale_shear(self, pos: _Vec3f, quat: _Vec4f, scale: _Vec3f, shear: _Vec3f) -> None: ...
    @overload
    def set_pos_quat_scale_shear(self, other: NodePath, pos: _Vec3f, quat: _Vec4f, scale: _Vec3f, shear: _Vec3f) -> None: ...
    @overload
    def set_mat(self, mat: _Mat4f) -> None: ...
    @overload
    def set_mat(self, other: NodePath, mat: _Mat4f) -> None: ...
    def clear_mat(self) -> None: ...
    def has_mat(self) -> bool: ...
    @overload
    def get_mat(self) -> LMatrix4f: ...
    @overload
    def get_mat(self, other: NodePath) -> LMatrix4f: ...
    @overload
    def look_at(self, point: _Vec3f, up: _Vec3f = ...) -> None: ...
    @overload
    def look_at(self, other: NodePath, point: _Vec3f = ..., up: _Vec3f = ...) -> None: ...
    @overload
    def look_at(self, x: float, y: float, z: float) -> None: ...
    @overload
    def look_at(self, other: NodePath, x: float, y: float, z: float) -> None: ...
    @overload
    def heads_up(self, point: _Vec3f, up: _Vec3f = ...) -> None: ...
    @overload
    def heads_up(self, other: NodePath, point: _Vec3f = ..., up: _Vec3f = ...) -> None: ...
    @overload
    def heads_up(self, x: float, y: float, z: float) -> None: ...
    @overload
    def heads_up(self, other: NodePath, x: float, y: float, z: float) -> None: ...
    def get_relative_point(self, other: NodePath, point: _Vec3f) -> LPoint3f: ...
    def get_relative_vector(self, other: NodePath, vec: _Vec3f) -> LVector3f: ...
    def get_distance(self, other: NodePath) -> float: ...
    @overload
    def set_color(self, color: _Vec4f, priority: int = ...) -> None: ...
    @overload
    def set_color(self, r: float, g: float, b: float, a: float = ..., priority: int = ...) -> None: ...
    def set_color_off(self, priority: int = ...) -> None: ...
    def clear_color(self) -> None: ...
    def has_color(self) -> bool: ...
    def get_color(self) -> LVecBase4f: ...
    def has_color_scale(self) -> bool: ...
    def clear_color_scale(self) -> None: ...
    @overload
    def set_color_scale(self, scale: _Vec4f, priority: int = ...) -> None: ...
    @overload
    def set_color_scale(self, sx: float, sy: float, sz: float, sa: float, priority: int = ...) -> None: ...
    @overload
    def compose_color_scale(self, scale: _Vec4f, priority: int = ...) -> None: ...
    @overload
    def compose_color_scale(self, sx: float, sy: float, sz: float, sa: float, priority: int = ...) -> None: ...
    def set_color_scale_off(self, priority: int = ...) -> None: ...
    def set_alpha_scale(self, scale: float, priority: int = ...) -> None: ...
    def set_all_color_scale(self, scale: float, priority: int = ...) -> None: ...
    def set_sr(self, sr: float) -> None: ...
    def set_sg(self, sg: float) -> None: ...
    def set_sb(self, sb: float) -> None: ...
    def set_sa(self, sa: float) -> None: ...
    def get_color_scale(self) -> LVecBase4f: ...
    def get_sr(self) -> float: ...
    def get_sg(self) -> float: ...
    def get_sb(self) -> float: ...
    def get_sa(self) -> float: ...
    def set_light(self, light: NodePath, priority: int = ...) -> None: ...
    @overload
    def set_light_off(self, priority: int = ...) -> None: ...
    @overload
    def set_light_off(self, light: NodePath, priority: int = ...) -> None: ...
    @overload
    def clear_light(self) -> None: ...
    @overload
    def clear_light(self, light: NodePath) -> None: ...
    def has_light(self, light: NodePath) -> bool: ...
    @overload
    def has_light_off(self) -> bool: ...
    @overload
    def has_light_off(self, light: NodePath) -> bool: ...
    def set_clip_plane(self, clip_plane: NodePath, priority: int = ...) -> None: ...
    @overload
    def set_clip_plane_off(self, priority: int = ...) -> None: ...
    @overload
    def set_clip_plane_off(self, clip_plane: NodePath, priority: int = ...) -> None: ...
    @overload
    def clear_clip_plane(self) -> None: ...
    @overload
    def clear_clip_plane(self, clip_plane: NodePath) -> None: ...
    def has_clip_plane(self, clip_plane: NodePath) -> bool: ...
    @overload
    def has_clip_plane_off(self) -> bool: ...
    @overload
    def has_clip_plane_off(self, clip_plane: NodePath) -> bool: ...
    @overload
    def set_scissor(self, a: _Vec3f, b: _Vec3f) -> None: ...
    @overload
    def set_scissor(self, other: NodePath, a: _Vec3f, b: _Vec3f) -> None: ...
    @overload
    def set_scissor(self, a: _Vec3f, b: _Vec3f, c: _Vec3f, d: _Vec3f) -> None: ...
    @overload
    def set_scissor(self, left: float, right: float, bottom: float, top: float) -> None: ...
    @overload
    def set_scissor(self, other: NodePath, a: _Vec3f, b: _Vec3f, c: _Vec3f, d: _Vec3f) -> None: ...
    def clear_scissor(self) -> None: ...
    def has_scissor(self) -> bool: ...
    def set_occluder(self, occluder: NodePath) -> None: ...
    @overload
    def clear_occluder(self) -> None: ...
    @overload
    def clear_occluder(self, occluder: NodePath) -> None: ...
    def has_occluder(self, occluder: NodePath) -> bool: ...
    def set_bin(self, bin_name: str, draw_order: int, priority: int = ...) -> None: ...
    def clear_bin(self) -> None: ...
    def has_bin(self) -> bool: ...
    def get_bin_name(self) -> str: ...
    def get_bin_draw_order(self) -> int: ...
    @overload
    def set_texture(self, tex: Texture, priority: int = ...) -> None: ...
    @overload
    def set_texture(self, tex: Texture, sampler: SamplerState, priority: int = ...) -> None: ...
    @overload
    def set_texture(self, stage: TextureStage, tex: Texture, priority: int = ...) -> None: ...
    @overload
    def set_texture(self, stage: TextureStage, tex: Texture, sampler: SamplerState, priority: int = ...) -> None: ...
    @overload
    def set_texture_off(self, priority: int = ...) -> None: ...
    @overload
    def set_texture_off(self, stage: TextureStage, priority: int = ...) -> None: ...
    @overload
    def clear_texture(self) -> None: ...
    @overload
    def clear_texture(self, stage: TextureStage) -> None: ...
    @overload
    def has_texture(self) -> bool: ...
    @overload
    def has_texture(self, stage: TextureStage) -> bool: ...
    @overload
    def has_texture_off(self) -> bool: ...
    @overload
    def has_texture_off(self, stage: TextureStage) -> bool: ...
    @overload
    def get_texture(self) -> Texture: ...
    @overload
    def get_texture(self, stage: TextureStage) -> Texture: ...
    def replace_texture(self, tex: Texture, new_tex: Texture) -> None: ...
    @overload
    def get_texture_sampler(self) -> SamplerState: ...
    @overload
    def get_texture_sampler(self, stage: TextureStage) -> SamplerState: ...
    def set_shader(self, sha: Shader, priority: int = ...) -> None: ...
    def set_shader_off(self, priority: int = ...) -> None: ...
    @overload
    def set_shader_auto(self, priority: int = ...) -> None: ...
    @overload
    def set_shader_auto(self, shader_switch: BitMask_uint32_t_32, priority: int = ...) -> None: ...
    def clear_shader(self) -> None: ...
    @overload
    def set_shader_input(self, input: ShaderInput) -> None: ...
    @overload
    def set_shader_input(self, __param0: InternalName, __param1: Any, priority: int = ...) -> None: ...
    @overload
    def set_shader_input(self, id: InternalName, tex: Texture, sampler: SamplerState, priority: int = ...) -> None: ...
    @overload
    def set_shader_input(self, id: InternalName, n1: float, n2: float, n3: float = ..., n4: float = ..., priority: int = ...) -> None: ...
    @overload
    def set_shader_input(self, id: InternalName, tex: Texture, read: bool, write: bool, z: int = ..., n: int = ..., priority: int = ...) -> None: ...
    def set_shader_inputs(self, args: Any, kwargs: Any) -> None: ...
    def clear_shader_input(self, id: InternalName) -> None: ...
    def set_instance_count(self, instance_count: int) -> None: ...
    def get_shader(self) -> Shader: ...
    def get_shader_input(self, id: InternalName) -> ShaderInput: ...
    def get_instance_count(self) -> int: ...
    @overload
    def set_tex_transform(self, stage: TextureStage, transform: TransformState) -> None: ...
    @overload
    def set_tex_transform(self, other: NodePath, stage: TextureStage, transform: TransformState) -> None: ...
    @overload
    def clear_tex_transform(self) -> None: ...
    @overload
    def clear_tex_transform(self, stage: TextureStage) -> None: ...
    def has_tex_transform(self, stage: TextureStage) -> bool: ...
    @overload
    def get_tex_transform(self, stage: TextureStage) -> TransformState: ...
    @overload
    def get_tex_transform(self, other: NodePath, stage: TextureStage) -> TransformState: ...
    @overload
    def set_tex_offset(self, stage: TextureStage, uv: LVecBase2f) -> None: ...
    @overload
    def set_tex_offset(self, other: NodePath, stage: TextureStage, uv: LVecBase2f) -> None: ...
    @overload
    def set_tex_offset(self, stage: TextureStage, u: float, v: float) -> None: ...
    @overload
    def set_tex_offset(self, other: NodePath, stage: TextureStage, u: float, v: float) -> None: ...
    @overload
    def set_tex_rotate(self, stage: TextureStage, r: float) -> None: ...
    @overload
    def set_tex_rotate(self, other: NodePath, stage: TextureStage, r: float) -> None: ...
    @overload
    def set_tex_scale(self, stage: TextureStage, scale: LVecBase2f | _Vec3f | float) -> None: ...
    @overload
    def set_tex_scale(self, other: NodePath, stage: TextureStage, scale: LVecBase2f | _Vec3f | float) -> None: ...
    @overload
    def set_tex_scale(self, stage: TextureStage, su: float, sv: float) -> None: ...
    @overload
    def set_tex_scale(self, other: NodePath, stage: TextureStage, su: float, sv: float) -> None: ...
    @overload
    def set_tex_scale(self, stage: TextureStage, su: float, sv: float, sw: float) -> None: ...
    @overload
    def set_tex_scale(self, other: NodePath, stage: TextureStage, su: float, sv: float, sw: float) -> None: ...
    @overload
    def get_tex_offset(self, stage: TextureStage) -> LVecBase2f: ...
    @overload
    def get_tex_offset(self, other: NodePath, stage: TextureStage) -> LVecBase2f: ...
    @overload
    def get_tex_rotate(self, stage: TextureStage) -> float: ...
    @overload
    def get_tex_rotate(self, other: NodePath, stage: TextureStage) -> float: ...
    @overload
    def get_tex_scale(self, stage: TextureStage) -> LVecBase2f: ...
    @overload
    def get_tex_scale(self, other: NodePath, stage: TextureStage) -> LVecBase2f: ...
    @overload
    def set_tex_pos(self, stage: TextureStage, uvw: _Vec3f) -> None: ...
    @overload
    def set_tex_pos(self, other: NodePath, stage: TextureStage, uvw: _Vec3f) -> None: ...
    @overload
    def set_tex_pos(self, stage: TextureStage, u: float, v: float, w: float) -> None: ...
    @overload
    def set_tex_pos(self, other: NodePath, stage: TextureStage, u: float, v: float, w: float) -> None: ...
    @overload
    def set_tex_hpr(self, stage: TextureStage, hpr: _Vec3f) -> None: ...
    @overload
    def set_tex_hpr(self, other: NodePath, stage: TextureStage, hpr: _Vec3f) -> None: ...
    @overload
    def set_tex_hpr(self, stage: TextureStage, h: float, p: float, r: float) -> None: ...
    @overload
    def set_tex_hpr(self, other: NodePath, stage: TextureStage, h: float, p: float, r: float) -> None: ...
    @overload
    def get_tex_pos(self, stage: TextureStage) -> LVecBase3f: ...
    @overload
    def get_tex_pos(self, other: NodePath, stage: TextureStage) -> LVecBase3f: ...
    @overload
    def get_tex_hpr(self, stage: TextureStage) -> LVecBase3f: ...
    @overload
    def get_tex_hpr(self, other: NodePath, stage: TextureStage) -> LVecBase3f: ...
    @overload
    def get_tex_scale_3d(self, stage: TextureStage) -> LVecBase3f: ...
    @overload
    def get_tex_scale_3d(self, other: NodePath, stage: TextureStage) -> LVecBase3f: ...
    @overload
    def set_tex_gen(self, stage: TextureStage, mode: _RenderAttrib_TexGenMode, priority: int = ...) -> None: ...
    @overload
    def set_tex_gen(self, stage: TextureStage, mode: _RenderAttrib_TexGenMode, constant_value: _Vec3f, priority: int = ...) -> None: ...
    @overload
    def clear_tex_gen(self) -> None: ...
    @overload
    def clear_tex_gen(self, stage: TextureStage) -> None: ...
    def has_tex_gen(self, stage: TextureStage) -> bool: ...
    def get_tex_gen(self, stage: TextureStage) -> _RenderAttrib_TexGenMode: ...
    def set_tex_projector(self, stage: TextureStage, _from: NodePath, to: NodePath, lens_index: int = ...) -> None: ...
    @overload
    def clear_tex_projector(self) -> None: ...
    @overload
    def clear_tex_projector(self, stage: TextureStage) -> None: ...
    def has_tex_projector(self, stage: TextureStage) -> bool: ...
    def get_tex_projector_from(self, stage: TextureStage) -> NodePath: ...
    def get_tex_projector_to(self, stage: TextureStage) -> NodePath: ...
    def project_texture(self, stage: TextureStage, tex: Texture, projector: NodePath) -> None: ...
    def clear_project_texture(self, stage: TextureStage) -> None: ...
    def has_texcoord(self, texcoord_name: str) -> bool: ...
    def has_vertex_column(self, name: InternalName) -> bool: ...
    @overload
    def find_all_vertex_columns(self) -> InternalNameCollection: ...
    @overload
    def find_all_vertex_columns(self, name: str) -> InternalNameCollection: ...
    @overload
    def find_all_texcoords(self) -> InternalNameCollection: ...
    @overload
    def find_all_texcoords(self, name: str) -> InternalNameCollection: ...
    @overload
    def find_texture(self, stage: TextureStage) -> Texture: ...
    @overload
    def find_texture(self, name: str) -> Texture: ...
    @overload
    def find_all_textures(self) -> TextureCollection: ...
    @overload
    def find_all_textures(self, stage: TextureStage) -> TextureCollection: ...
    @overload
    def find_all_textures(self, name: str) -> TextureCollection: ...
    def find_texture_stage(self, name: str) -> TextureStage: ...
    @overload
    def find_all_texture_stages(self) -> TextureStageCollection: ...
    @overload
    def find_all_texture_stages(self, name: str) -> TextureStageCollection: ...
    def unify_texture_stages(self, stage: TextureStage) -> None: ...
    def find_material(self, name: str) -> Material: ...
    @overload
    def find_all_materials(self) -> MaterialCollection: ...
    @overload
    def find_all_materials(self, name: str) -> MaterialCollection: ...
    def set_material(self, tex: Material, priority: int = ...) -> None: ...
    def set_material_off(self, priority: int = ...) -> None: ...
    def clear_material(self) -> None: ...
    def has_material(self) -> bool: ...
    def get_material(self) -> Material: ...
    def replace_material(self, mat: Material, new_mat: Material) -> None: ...
    def set_fog(self, fog: Fog, priority: int = ...) -> None: ...
    def set_fog_off(self, priority: int = ...) -> None: ...
    def clear_fog(self) -> None: ...
    def has_fog(self) -> bool: ...
    def has_fog_off(self) -> bool: ...
    def get_fog(self) -> Fog: ...
    def set_render_mode_wireframe(self, priority: int = ...) -> None: ...
    def set_render_mode_filled(self, priority: int = ...) -> None: ...
    def set_render_mode_filled_wireframe(self, wireframe_color: _Vec4f, priority: int = ...) -> None: ...
    def set_render_mode_thickness(self, thickness: float, priority: int = ...) -> None: ...
    def set_render_mode_perspective(self, perspective: bool, priority: int = ...) -> None: ...
    def set_render_mode(self, mode: _RenderModeAttrib_Mode, thickness: float, priority: int = ...) -> None: ...
    def clear_render_mode(self) -> None: ...
    def has_render_mode(self) -> bool: ...
    def get_render_mode(self) -> _RenderModeAttrib_Mode: ...
    def get_render_mode_thickness(self) -> float: ...
    def get_render_mode_perspective(self) -> bool: ...
    def set_two_sided(self, two_sided: bool, priority: int = ...) -> None: ...
    def clear_two_sided(self) -> None: ...
    def has_two_sided(self) -> bool: ...
    def get_two_sided(self) -> bool: ...
    def set_depth_test(self, depth_test: bool, priority: int = ...) -> None: ...
    def clear_depth_test(self) -> None: ...
    def has_depth_test(self) -> bool: ...
    def get_depth_test(self) -> bool: ...
    def set_depth_write(self, depth_write: bool, priority: int = ...) -> None: ...
    def clear_depth_write(self) -> None: ...
    def has_depth_write(self) -> bool: ...
    def get_depth_write(self) -> bool: ...
    def set_depth_offset(self, bias: int, priority: int = ...) -> None: ...
    def clear_depth_offset(self) -> None: ...
    def has_depth_offset(self) -> bool: ...
    def get_depth_offset(self) -> int: ...
    def do_billboard_axis(self, camera: NodePath, offset: float) -> None: ...
    def do_billboard_point_eye(self, camera: NodePath, offset: float) -> None: ...
    def do_billboard_point_world(self, camera: NodePath, offset: float) -> None: ...
    @overload
    def set_billboard_axis(self, offset: float = ...) -> None: ...
    @overload
    def set_billboard_axis(self, camera: NodePath, offset: float) -> None: ...
    @overload
    def set_billboard_point_eye(self, offset: float = ..., fixed_depth: bool = ...) -> None: ...
    @overload
    def set_billboard_point_eye(self, camera: NodePath, offset: float, fixed_depth: bool = ...) -> None: ...
    @overload
    def set_billboard_point_world(self, offset: float = ...) -> None: ...
    @overload
    def set_billboard_point_world(self, camera: NodePath, offset: float) -> None: ...
    def clear_billboard(self) -> None: ...
    def has_billboard(self) -> bool: ...
    def set_compass(self, reference: NodePath = ...) -> None: ...
    def clear_compass(self) -> None: ...
    def has_compass(self) -> bool: ...
    def set_transparency(self, mode: _TransparencyAttrib_Mode, priority: int = ...) -> None: ...
    def clear_transparency(self) -> None: ...
    def has_transparency(self) -> bool: ...
    def get_transparency(self) -> _TransparencyAttrib_Mode: ...
    def set_logic_op(self, op: _LogicOpAttrib_Operation, priority: int = ...) -> None: ...
    def clear_logic_op(self) -> None: ...
    def has_logic_op(self) -> bool: ...
    def get_logic_op(self) -> _LogicOpAttrib_Operation: ...
    def set_antialias(self, mode: int, priority: int = ...) -> None: ...
    def clear_antialias(self) -> None: ...
    def has_antialias(self) -> bool: ...
    def get_antialias(self) -> int: ...
    def has_audio_volume(self) -> bool: ...
    def clear_audio_volume(self) -> None: ...
    def set_audio_volume(self, volume: float, priority: int = ...) -> None: ...
    def set_audio_volume_off(self, priority: int = ...) -> None: ...
    def get_audio_volume(self) -> float: ...
    def get_net_audio_volume(self) -> float: ...
    def adjust_all_priorities(self, adjustment: int) -> None: ...
    @overload
    def show(self) -> None: ...
    @overload
    def show(self, camera_mask: BitMask_uint32_t_32) -> None: ...
    @overload
    def show_through(self) -> None: ...
    @overload
    def show_through(self, camera_mask: BitMask_uint32_t_32) -> None: ...
    @overload
    def hide(self) -> None: ...
    @overload
    def hide(self, camera_mask: BitMask_uint32_t_32) -> None: ...
    def is_hidden(self, camera_mask: BitMask_uint32_t_32 = ...) -> bool: ...
    def get_hidden_ancestor(self, camera_mask: BitMask_uint32_t_32 = ..., current_thread: Thread = ...) -> NodePath: ...
    def stash(self, sort: int = ..., current_thread: Thread = ...) -> None: ...
    def unstash(self, sort: int = ..., current_thread: Thread = ...) -> None: ...
    def unstash_all(self, current_thread: Thread = ...) -> None: ...
    def is_stashed(self) -> bool: ...
    def get_stashed_ancestor(self, current_thread: Thread = ...) -> NodePath: ...
    def get_collide_mask(self) -> BitMask_uint32_t_32: ...
    def set_collide_mask(self, new_mask: BitMask_uint32_t_32, bits_to_change: BitMask_uint32_t_32 = ..., node_type: TypeHandle = ...) -> None: ...
    def compare_to(self, other: NodePath | WeakNodePath) -> int: ...
    def verify_complete(self, current_thread: Thread = ...) -> bool: ...
    def premunge_scene(self, gsg: GraphicsStateGuardianBase = ...) -> None: ...
    def prepare_scene(self, gsg: GraphicsStateGuardianBase) -> None: ...
    def show_bounds(self) -> None: ...
    def show_tight_bounds(self) -> None: ...
    def hide_bounds(self) -> None: ...
    def get_bounds(self, current_thread: Thread = ...) -> BoundingVolume: ...
    def force_recompute_bounds(self) -> None: ...
    def write_bounds(self, out: ostream) -> None: ...
    def calc_tight_bounds(self, min_point: _Vec3f, max_point: _Vec3f, other: NodePath = ..., current_thread: Thread = ...) -> bool: ...
    def get_tight_bounds(self, other: NodePath = ...) -> Any: ...
    def flatten_light(self) -> int: ...
    def flatten_medium(self) -> int: ...
    def flatten_strong(self) -> int: ...
    def apply_texture_colors(self) -> None: ...
    def clear_model_nodes(self) -> int: ...
    def set_tag(self, key: str, value: str) -> None: ...
    def get_tag(self, key: str) -> str: ...
    def get_tag_keys(self) -> Any: ...
    def has_tag(self, key: str) -> bool: ...
    def clear_tag(self, key: str) -> None: ...
    def get_net_tag(self, key: str) -> str: ...
    def has_net_tag(self, key: str) -> bool: ...
    def find_net_tag(self, key: str) -> NodePath: ...
    def get_tags(self) -> Any: ...
    def get_python_tags(self) -> dict[Any, Any] | None: ...
    def set_python_tag(self, keys: Any, value: Any) -> None: ...
    def get_python_tag(self, keys: Any) -> Any: ...
    def get_python_tag_keys(self) -> Any: ...
    def has_python_tag(self, keys: Any) -> bool: ...
    def clear_python_tag(self, keys: Any) -> None: ...
    def get_net_python_tag(self, keys: Any) -> Any: ...
    def has_net_python_tag(self, keys: Any) -> bool: ...
    def find_net_python_tag(self, keys: Any) -> NodePath: ...
    def list_tags(self) -> None: ...
    def set_name(self, name: str) -> None: ...
    def get_name(self) -> str: ...
    def write_bam_file(self, filename: _Filename) -> bool: ...
    def write_bam_stream(self, out: ostream) -> bool: ...
    @overload
    def encode_to_bam_stream(self) -> bytes: ...
    @overload
    def encode_to_bam_stream(self, data: bytes, writer: BamWriter = ...) -> bool: ...
    @staticmethod
    def decode_from_bam_stream(data: bytes, reader: BamReader = ...) -> NodePath: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    def get_nodes(self) -> tuple[PandaNode, ...]: ...
    def get_ancestors(self) -> tuple[NodePath, ...]: ...
    anyPath = any_path
    notFound = not_found
    setMaxSearchDepth = set_max_search_depth
    getMaxSearchDepth = get_max_search_depth
    isEmpty = is_empty
    isSingleton = is_singleton
    getNumNodes = get_num_nodes
    getNode = get_node
    getAncestor = get_ancestor
    getErrorType = get_error_type
    getTopNode = get_top_node
    getTop = get_top
    getKey = get_key
    addHash = add_hash
    isSameGraph = is_same_graph
    isAncestorOf = is_ancestor_of
    getCommonAncestor = get_common_ancestor
    getChildren = get_children
    getNumChildren = get_num_children
    getChild = get_child
    getStashedChildren = get_stashed_children
    countNumDescendants = count_num_descendants
    hasParent = has_parent
    getParent = get_parent
    getSort = get_sort
    findPathTo = find_path_to
    findAllMatches = find_all_matches
    findAllPathsTo = find_all_paths_to
    reparentTo = reparent_to
    stashTo = stash_to
    wrtReparentTo = wrt_reparent_to
    instanceTo = instance_to
    instanceUnderNode = instance_under_node
    copyTo = copy_to
    attachNewNode = attach_new_node
    removeNode = remove_node
    detachNode = detach_node
    reverseLs = reverse_ls
    getState = get_state
    setState = set_state
    getNetState = get_net_state
    setAttrib = set_attrib
    getAttrib = get_attrib
    hasAttrib = has_attrib
    clearAttrib = clear_attrib
    setEffect = set_effect
    getEffect = get_effect
    hasEffect = has_effect
    clearEffect = clear_effect
    setEffects = set_effects
    getEffects = get_effects
    clearEffects = clear_effects
    getTransform = get_transform
    clearTransform = clear_transform
    setTransform = set_transform
    getNetTransform = get_net_transform
    getPrevTransform = get_prev_transform
    setPrevTransform = set_prev_transform
    getNetPrevTransform = get_net_prev_transform
    setPos = set_pos
    setX = set_x
    setY = set_y
    setZ = set_z
    setFluidPos = set_fluid_pos
    setFluidX = set_fluid_x
    setFluidY = set_fluid_y
    setFluidZ = set_fluid_z
    getPos = get_pos
    getX = get_x
    getY = get_y
    getZ = get_z
    getPosDelta = get_pos_delta
    setHpr = set_hpr
    setH = set_h
    setP = set_p
    setR = set_r
    getHpr = get_hpr
    getH = get_h
    getP = get_p
    getR = get_r
    setQuat = set_quat
    getQuat = get_quat
    setScale = set_scale
    setSx = set_sx
    setSy = set_sy
    setSz = set_sz
    getScale = get_scale
    getSx = get_sx
    getSy = get_sy
    getSz = get_sz
    setShear = set_shear
    setShxy = set_shxy
    setShxz = set_shxz
    setShyz = set_shyz
    getShear = get_shear
    getShxy = get_shxy
    getShxz = get_shxz
    getShyz = get_shyz
    setPosHpr = set_pos_hpr
    setPosQuat = set_pos_quat
    setHprScale = set_hpr_scale
    setQuatScale = set_quat_scale
    setPosHprScale = set_pos_hpr_scale
    setPosQuatScale = set_pos_quat_scale
    setPosHprScaleShear = set_pos_hpr_scale_shear
    setPosQuatScaleShear = set_pos_quat_scale_shear
    setMat = set_mat
    clearMat = clear_mat
    hasMat = has_mat
    getMat = get_mat
    lookAt = look_at
    headsUp = heads_up
    getRelativePoint = get_relative_point
    getRelativeVector = get_relative_vector
    getDistance = get_distance
    setColor = set_color
    setColorOff = set_color_off
    clearColor = clear_color
    hasColor = has_color
    getColor = get_color
    hasColorScale = has_color_scale
    clearColorScale = clear_color_scale
    setColorScale = set_color_scale
    composeColorScale = compose_color_scale
    setColorScaleOff = set_color_scale_off
    setAlphaScale = set_alpha_scale
    setAllColorScale = set_all_color_scale
    setSr = set_sr
    setSg = set_sg
    setSb = set_sb
    setSa = set_sa
    getColorScale = get_color_scale
    getSr = get_sr
    getSg = get_sg
    getSb = get_sb
    getSa = get_sa
    setLight = set_light
    setLightOff = set_light_off
    clearLight = clear_light
    hasLight = has_light
    hasLightOff = has_light_off
    setClipPlane = set_clip_plane
    setClipPlaneOff = set_clip_plane_off
    clearClipPlane = clear_clip_plane
    hasClipPlane = has_clip_plane
    hasClipPlaneOff = has_clip_plane_off
    setScissor = set_scissor
    clearScissor = clear_scissor
    hasScissor = has_scissor
    setOccluder = set_occluder
    clearOccluder = clear_occluder
    hasOccluder = has_occluder
    setBin = set_bin
    clearBin = clear_bin
    hasBin = has_bin
    getBinName = get_bin_name
    getBinDrawOrder = get_bin_draw_order
    setTexture = set_texture
    setTextureOff = set_texture_off
    clearTexture = clear_texture
    hasTexture = has_texture
    hasTextureOff = has_texture_off
    getTexture = get_texture
    replaceTexture = replace_texture
    getTextureSampler = get_texture_sampler
    setShader = set_shader
    setShaderOff = set_shader_off
    setShaderAuto = set_shader_auto
    clearShader = clear_shader
    setShaderInput = set_shader_input
    setShaderInputs = set_shader_inputs
    clearShaderInput = clear_shader_input
    setInstanceCount = set_instance_count
    getShader = get_shader
    getShaderInput = get_shader_input
    getInstanceCount = get_instance_count
    setTexTransform = set_tex_transform
    clearTexTransform = clear_tex_transform
    hasTexTransform = has_tex_transform
    getTexTransform = get_tex_transform
    setTexOffset = set_tex_offset
    setTexRotate = set_tex_rotate
    setTexScale = set_tex_scale
    getTexOffset = get_tex_offset
    getTexRotate = get_tex_rotate
    getTexScale = get_tex_scale
    setTexPos = set_tex_pos
    setTexHpr = set_tex_hpr
    getTexPos = get_tex_pos
    getTexHpr = get_tex_hpr
    getTexScale3d = get_tex_scale_3d
    setTexGen = set_tex_gen
    clearTexGen = clear_tex_gen
    hasTexGen = has_tex_gen
    getTexGen = get_tex_gen
    setTexProjector = set_tex_projector
    clearTexProjector = clear_tex_projector
    hasTexProjector = has_tex_projector
    getTexProjectorFrom = get_tex_projector_from
    getTexProjectorTo = get_tex_projector_to
    projectTexture = project_texture
    clearProjectTexture = clear_project_texture
    hasTexcoord = has_texcoord
    hasVertexColumn = has_vertex_column
    findAllVertexColumns = find_all_vertex_columns
    findAllTexcoords = find_all_texcoords
    findTexture = find_texture
    findAllTextures = find_all_textures
    findTextureStage = find_texture_stage
    findAllTextureStages = find_all_texture_stages
    unifyTextureStages = unify_texture_stages
    findMaterial = find_material
    findAllMaterials = find_all_materials
    setMaterial = set_material
    setMaterialOff = set_material_off
    clearMaterial = clear_material
    hasMaterial = has_material
    getMaterial = get_material
    replaceMaterial = replace_material
    setFog = set_fog
    setFogOff = set_fog_off
    clearFog = clear_fog
    hasFog = has_fog
    hasFogOff = has_fog_off
    getFog = get_fog
    setRenderModeWireframe = set_render_mode_wireframe
    setRenderModeFilled = set_render_mode_filled
    setRenderModeFilledWireframe = set_render_mode_filled_wireframe
    setRenderModeThickness = set_render_mode_thickness
    setRenderModePerspective = set_render_mode_perspective
    setRenderMode = set_render_mode
    clearRenderMode = clear_render_mode
    hasRenderMode = has_render_mode
    getRenderMode = get_render_mode
    getRenderModeThickness = get_render_mode_thickness
    getRenderModePerspective = get_render_mode_perspective
    setTwoSided = set_two_sided
    clearTwoSided = clear_two_sided
    hasTwoSided = has_two_sided
    getTwoSided = get_two_sided
    setDepthTest = set_depth_test
    clearDepthTest = clear_depth_test
    hasDepthTest = has_depth_test
    getDepthTest = get_depth_test
    setDepthWrite = set_depth_write
    clearDepthWrite = clear_depth_write
    hasDepthWrite = has_depth_write
    getDepthWrite = get_depth_write
    setDepthOffset = set_depth_offset
    clearDepthOffset = clear_depth_offset
    hasDepthOffset = has_depth_offset
    getDepthOffset = get_depth_offset
    doBillboardAxis = do_billboard_axis
    doBillboardPointEye = do_billboard_point_eye
    doBillboardPointWorld = do_billboard_point_world
    setBillboardAxis = set_billboard_axis
    setBillboardPointEye = set_billboard_point_eye
    setBillboardPointWorld = set_billboard_point_world
    clearBillboard = clear_billboard
    hasBillboard = has_billboard
    setCompass = set_compass
    clearCompass = clear_compass
    hasCompass = has_compass
    setTransparency = set_transparency
    clearTransparency = clear_transparency
    hasTransparency = has_transparency
    getTransparency = get_transparency
    setLogicOp = set_logic_op
    clearLogicOp = clear_logic_op
    hasLogicOp = has_logic_op
    getLogicOp = get_logic_op
    setAntialias = set_antialias
    clearAntialias = clear_antialias
    hasAntialias = has_antialias
    getAntialias = get_antialias
    hasAudioVolume = has_audio_volume
    clearAudioVolume = clear_audio_volume
    setAudioVolume = set_audio_volume
    setAudioVolumeOff = set_audio_volume_off
    getAudioVolume = get_audio_volume
    getNetAudioVolume = get_net_audio_volume
    adjustAllPriorities = adjust_all_priorities
    showThrough = show_through
    isHidden = is_hidden
    getHiddenAncestor = get_hidden_ancestor
    unstashAll = unstash_all
    isStashed = is_stashed
    getStashedAncestor = get_stashed_ancestor
    getCollideMask = get_collide_mask
    setCollideMask = set_collide_mask
    compareTo = compare_to
    verifyComplete = verify_complete
    premungeScene = premunge_scene
    prepareScene = prepare_scene
    showBounds = show_bounds
    showTightBounds = show_tight_bounds
    hideBounds = hide_bounds
    getBounds = get_bounds
    forceRecomputeBounds = force_recompute_bounds
    writeBounds = write_bounds
    calcTightBounds = calc_tight_bounds
    getTightBounds = get_tight_bounds
    flattenLight = flatten_light
    flattenMedium = flatten_medium
    flattenStrong = flatten_strong
    applyTextureColors = apply_texture_colors
    clearModelNodes = clear_model_nodes
    setTag = set_tag
    getTag = get_tag
    getTagKeys = get_tag_keys
    hasTag = has_tag
    clearTag = clear_tag
    getNetTag = get_net_tag
    hasNetTag = has_net_tag
    findNetTag = find_net_tag
    getTags = get_tags
    getPythonTags = get_python_tags
    setPythonTag = set_python_tag
    getPythonTag = get_python_tag
    getPythonTagKeys = get_python_tag_keys
    hasPythonTag = has_python_tag
    clearPythonTag = clear_python_tag
    getNetPythonTag = get_net_python_tag
    hasNetPythonTag = has_net_python_tag
    findNetPythonTag = find_net_python_tag
    listTags = list_tags
    setName = set_name
    getName = get_name
    writeBamFile = write_bam_file
    writeBamStream = write_bam_stream
    encodeToBamStream = encode_to_bam_stream
    decodeFromBamStream = decode_from_bam_stream
    getClassType = get_class_type
    getNodes = get_nodes
    getAncestors = get_ancestors
    ETOk = ET_ok
    ETNotFound = ET_not_found
    ETRemoved = ET_removed
    ETFail = ET_fail

class NodePathCollection:
    """This is a set of zero or more NodePaths.  It's handy for returning from
    functions that need to return multiple NodePaths (for instance,
    NodePaths::get_children).
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, __param0: NodePathCollection) -> None: ...
    @overload
    def __init__(self, sequence: Any) -> None: ...
    def __getitem__(self, index: int) -> NodePath: ...
    def __len__(self) -> int: ...
    def __iadd__(self, other: NodePathCollection) -> NodePathCollection: ...
    def __add__(self, other: NodePathCollection) -> NodePathCollection: ...
    def add_path(self, node_path: NodePath) -> None: ...
    def remove_path(self, node_path: NodePath) -> bool: ...
    def add_paths_from(self, other: NodePathCollection) -> None: ...
    def remove_paths_from(self, other: NodePathCollection) -> None: ...
    def remove_duplicate_paths(self) -> None: ...
    def has_path(self, path: NodePath) -> bool: ...
    def clear(self) -> None: ...
    def reserve(self, num: int) -> None: ...
    def is_empty(self) -> bool: ...
    def get_num_paths(self) -> int: ...
    def get_path(self, index: int) -> NodePath: ...
    def append(self, node_path: NodePath) -> None: ...
    def extend(self, other: NodePathCollection) -> None: ...
    @overload
    def ls(self) -> None: ...
    @overload
    def ls(self, out: ostream, indent_level: int = ...) -> None: ...
    def find_all_matches(self, path: str) -> NodePathCollection: ...
    def reparent_to(self, other: NodePath) -> None: ...
    def wrt_reparent_to(self, other: NodePath) -> None: ...
    def show(self) -> None: ...
    def hide(self) -> None: ...
    def stash(self) -> None: ...
    def unstash(self) -> None: ...
    def detach(self) -> None: ...
    def get_collide_mask(self) -> BitMask_uint32_t_32: ...
    def set_collide_mask(self, new_mask: BitMask_uint32_t_32, bits_to_change: BitMask_uint32_t_32 = ..., node_type: TypeHandle = ...) -> None: ...
    def calc_tight_bounds(self, min_point: _Vec3f, max_point: _Vec3f) -> bool: ...
    def get_tight_bounds(self) -> Any: ...
    @overload
    def set_texture(self, tex: Texture, priority: int = ...) -> None: ...
    @overload
    def set_texture(self, stage: TextureStage, tex: Texture, priority: int = ...) -> None: ...
    @overload
    def set_texture_off(self, priority: int = ...) -> None: ...
    @overload
    def set_texture_off(self, stage: TextureStage, priority: int = ...) -> None: ...
    @overload
    def set_color(self, color: _Vec4f, priority: int = ...) -> None: ...
    @overload
    def set_color(self, r: float, g: float, b: float, a: float = ..., priority: int = ...) -> None: ...
    @overload
    def set_color_scale(self, scale: _Vec4f, priority: int = ...) -> None: ...
    @overload
    def set_color_scale(self, r: float, g: float, b: float, a: float = ..., priority: int = ...) -> None: ...
    @overload
    def compose_color_scale(self, scale: _Vec4f, priority: int = ...) -> None: ...
    @overload
    def compose_color_scale(self, r: float, g: float, b: float, a: float = ..., priority: int = ...) -> None: ...
    def set_attrib(self, attrib: RenderAttrib, priority: int = ...) -> None: ...
    def output(self, out: ostream) -> None: ...
    def write(self, out: ostream, indent_level: int = ...) -> None: ...
    def get_paths(self) -> tuple[NodePath, ...]: ...
    addPath = add_path
    removePath = remove_path
    addPathsFrom = add_paths_from
    removePathsFrom = remove_paths_from
    removeDuplicatePaths = remove_duplicate_paths
    hasPath = has_path
    isEmpty = is_empty
    getNumPaths = get_num_paths
    getPath = get_path
    findAllMatches = find_all_matches
    reparentTo = reparent_to
    wrtReparentTo = wrt_reparent_to
    getCollideMask = get_collide_mask
    setCollideMask = set_collide_mask
    calcTightBounds = calc_tight_bounds
    getTightBounds = get_tight_bounds
    setTexture = set_texture
    setTextureOff = set_texture_off
    setColor = set_color
    setColorScale = set_color_scale
    composeColorScale = compose_color_scale
    setAttrib = set_attrib
    getPaths = get_paths

class AttribNodeRegistry:
    """This global object records NodePaths that are referenced by scene graph
    attribs, such as ClipPlaneAttribs and LightAttribs.
    
    Its primary purpose is to unify attribs that are loaded in from bam files.
    Attrib nodes are identified by name and type; when a bam file that contains
    references to some attrib nodes is loaded, those nodes are first looked up
    here in the AttribNodeRegistry.  If there is a match (by name and node
    type), the identified node is used instead of the node referenced within
    the bam file itself.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def add_node(self, attrib_node: NodePath) -> None: ...
    @overload
    def remove_node(self, attrib_node: NodePath) -> bool: ...
    @overload
    def remove_node(self, n: int) -> None: ...
    def lookup_node(self, orig_node: NodePath) -> NodePath: ...
    def get_num_nodes(self) -> int: ...
    def get_node(self, n: int) -> NodePath: ...
    def get_node_type(self, n: int) -> TypeHandle: ...
    def get_node_name(self, n: int) -> str: ...
    @overload
    def find_node(self, attrib_node: NodePath) -> int: ...
    @overload
    def find_node(self, type: TypeHandle, name: str) -> int: ...
    def clear(self) -> None: ...
    def output(self, out: ostream) -> None: ...
    def write(self, out: ostream) -> None: ...
    @staticmethod
    def get_global_ptr() -> AttribNodeRegistry: ...
    def get_nodes(self) -> tuple[NodePath, ...]: ...
    addNode = add_node
    removeNode = remove_node
    lookupNode = lookup_node
    getNumNodes = get_num_nodes
    getNode = get_node
    getNodeType = get_node_type
    getNodeName = get_node_name
    findNode = find_node
    getGlobalPtr = get_global_ptr
    getNodes = get_nodes

class AudioVolumeAttrib(RenderAttrib):
    """Applies a scale to audio volume for positional sounds in the scene graph."""
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def volume(self) -> float: ...
    @property
    def class_slot(self) -> int: ...
    @staticmethod
    def make_identity() -> RenderAttrib: ...
    @staticmethod
    def make(volume: float) -> RenderAttrib: ...
    @staticmethod
    def make_off() -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def is_off(self) -> bool: ...
    def has_volume(self) -> bool: ...
    def get_volume(self) -> float: ...
    def set_volume(self, volume: float) -> RenderAttrib: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeIdentity = make_identity
    makeOff = make_off
    makeDefault = make_default
    isOff = is_off
    hasVolume = has_volume
    getVolume = get_volume
    setVolume = set_volume
    getClassSlot = get_class_slot
    getClassType = get_class_type

class AuxBitplaneAttrib(RenderAttrib):
    """Modern frame buffers can have 'aux' bitplanes, which are additional
    bitplanes above and beyond the standard depth and color.  This attrib
    controls what gets rendered into those additional bitplanes.  It can also
    affect what goes into the alpha channel of the primary color buffer.
    
    ABO_glow: copy the glow map into the alpha channel of the primary frame
    buffer.  If there is no glow map, set it to zero.  Caveat: it is not
    possible to write glow or depth values to the framebuffer alpha channel at
    the same time as using alpha blending or alpha testing.  Any attempt to use
    transparency, blending, or alpha testing will cause this flag to be
    overridden.
    
    ABO_aux_normal: put the camera-space normal into the into the R,G
    components of the first auxiliary bitplane.
    
    ABO_aux_modelz: put the clip-space Z coordinate of the center of the model
    (after perspective divide) into the B channel of the first auxiliary
    bitplane.
    
    ABO_aux_glow: put a copy of the glow map into the alpha channel of the
    first auxiliary bitplane.  If there is no glow map, set it to zero.
    
    AuxBitplaneAttrib is relevant only when shader generation is enabled.
    Otherwise, it has no effect.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    ABO_glow: ClassVar[Literal[1]]
    ABO_aux_normal: ClassVar[Literal[2]]
    ABO_aux_glow: ClassVar[Literal[4]]
    @property
    def outputs(self) -> int: ...
    @property
    def class_slot(self) -> int: ...
    @overload
    @staticmethod
    def make() -> RenderAttrib: ...
    @overload
    @staticmethod
    def make(outputs: int) -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def get_outputs(self) -> int: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeDefault = make_default
    getOutputs = get_outputs
    getClassSlot = get_class_slot
    getClassType = get_class_type
    ABOGlow = ABO_glow
    ABOAuxNormal = ABO_aux_normal
    ABOAuxGlow = ABO_aux_glow

class AuxSceneData(TypedReferenceCount):
    """This is a base class for a generic data structure that can be attached per-
    instance to the camera, to store per-instance data that must be preserved
    over multiple frames.
    
    In particular, this is used to implement the FadeLODNode, which must
    remember during traversal at what point it is in the fade, separately for
    each instance and for each camera.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, __param0: AuxSceneData) -> None: ...
    def set_duration(self, duration: float) -> None: ...
    def get_duration(self) -> float: ...
    def set_last_render_time(self, render_time: float) -> None: ...
    def get_last_render_time(self) -> float: ...
    def get_expiration_time(self) -> float: ...
    def output(self, out: ostream) -> None: ...
    def write(self, out: ostream, indent_level: int = ...) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    setDuration = set_duration
    getDuration = get_duration
    setLastRenderTime = set_last_render_time
    getLastRenderTime = get_last_render_time
    getExpirationTime = get_expiration_time
    getClassType = get_class_type

class BamFile(BamEnums):
    """The principle public interface to reading and writing Bam disk files.  See
    also BamReader and BamWriter, the more general implementation of this
    class.
    
    Bam files are most often used to store scene graphs or subgraphs, and by
    convention they are given filenames ending in the extension ".bam" when
    they are used for this purpose.  However, a Bam file may store any
    arbitrary list of TypedWritable objects; in this more general usage, they
    are given filenames ending in ".boo" to differentiate them from the more
    common scene graph files.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def file_endian(self) -> _BamEnums_BamEndian: ...
    @property
    def file_stdfloat_double(self) -> bool: ...
    @property
    def reader(self) -> BamReader: ...
    @property
    def writer(self) -> BamWriter: ...
    def __init__(self) -> None: ...
    @overload
    def open_read(self, bam_filename: _Filename, report_errors: bool = ...) -> bool: ...
    @overload
    def open_read(self, _in: istream, bam_filename: str = ..., report_errors: bool = ...) -> bool: ...
    def read_object(self) -> TypedWritable: ...
    def is_eof(self) -> bool: ...
    def resolve(self) -> bool: ...
    def read_node(self, report_errors: bool = ...) -> PandaNode: ...
    @overload
    def open_write(self, bam_filename: _Filename, report_errors: bool = ...) -> bool: ...
    @overload
    def open_write(self, out: ostream, bam_filename: str = ..., report_errors: bool = ...) -> bool: ...
    def write_object(self, object: TypedWritable) -> bool: ...
    def close(self) -> None: ...
    def is_valid_read(self) -> bool: ...
    def is_valid_write(self) -> bool: ...
    def get_file_major_ver(self) -> int: ...
    def get_file_minor_ver(self) -> int: ...
    def get_file_endian(self) -> _BamEnums_BamEndian: ...
    def get_file_stdfloat_double(self) -> bool: ...
    def get_current_major_ver(self) -> int: ...
    def get_current_minor_ver(self) -> int: ...
    def get_reader(self) -> BamReader: ...
    def get_writer(self) -> BamWriter: ...
    openRead = open_read
    readObject = read_object
    isEof = is_eof
    readNode = read_node
    openWrite = open_write
    writeObject = write_object
    isValidRead = is_valid_read
    isValidWrite = is_valid_write
    getFileMajorVer = get_file_major_ver
    getFileMinorVer = get_file_minor_ver
    getFileEndian = get_file_endian
    getFileStdfloatDouble = get_file_stdfloat_double
    getCurrentMajorVer = get_current_major_ver
    getCurrentMinorVer = get_current_minor_ver
    getReader = get_reader
    getWriter = get_writer

class BillboardEffect(RenderEffect):
    """Indicates that geometry at this node should automatically rotate to face
    the camera, or any other arbitrary node.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @staticmethod
    def make(up_vector: _Vec3f, eye_relative: bool, axial_rotate: bool, offset: float, look_at: NodePath, look_at_point: _Vec3f, fixed_depth: bool = ...) -> RenderEffect: ...
    @staticmethod
    def make_axis() -> RenderEffect: ...
    @staticmethod
    def make_point_eye() -> RenderEffect: ...
    @staticmethod
    def make_point_world() -> RenderEffect: ...
    def is_off(self) -> bool: ...
    def get_up_vector(self) -> LVector3f: ...
    def get_eye_relative(self) -> bool: ...
    def get_axial_rotate(self) -> bool: ...
    def get_fixed_depth(self) -> bool: ...
    def get_offset(self) -> float: ...
    def get_look_at(self) -> NodePath: ...
    def get_look_at_point(self) -> LPoint3f: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeAxis = make_axis
    makePointEye = make_point_eye
    makePointWorld = make_point_world
    isOff = is_off
    getUpVector = get_up_vector
    getEyeRelative = get_eye_relative
    getAxialRotate = get_axial_rotate
    getFixedDepth = get_fixed_depth
    getOffset = get_offset
    getLookAt = get_look_at
    getLookAtPoint = get_look_at_point
    getClassType = get_class_type

class LensNode(PandaNode):
    """A node that contains a Lens.  The most important example of this kind of
    node is a Camera, but other kinds of nodes also contain a lens (for
    instance, a Spotlight).
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, name: str, lens: Lens = ...) -> None: ...
    @overload
    def copy_lens(self, lens: Lens) -> None: ...
    @overload
    def copy_lens(self, index: int, lens: Lens) -> None: ...
    @overload
    def set_lens(self, lens: Lens) -> None: ...
    @overload
    def set_lens(self, index: int, lens: Lens) -> None: ...
    def get_lens(self, index: int = ...) -> Lens: ...
    def set_lens_active(self, index: int, active: bool) -> bool: ...
    def get_lens_active(self, index: int) -> bool: ...
    def activate_lens(self, index: int) -> bool: ...
    def deactivate_lens(self, index: int) -> bool: ...
    @overload
    def is_in_view(self, pos: _Vec3f) -> bool: ...
    @overload
    def is_in_view(self, index: int, pos: _Vec3f) -> bool: ...
    def show_frustum(self) -> None: ...
    def hide_frustum(self) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    copyLens = copy_lens
    setLens = set_lens
    getLens = get_lens
    setLensActive = set_lens_active
    getLensActive = get_lens_active
    activateLens = activate_lens
    deactivateLens = deactivate_lens
    isInView = is_in_view
    showFrustum = show_frustum
    hideFrustum = hide_frustum
    getClassType = get_class_type

class WeakNodePath:
    """This class is a wrapper around a NodePath that, unlike the actual NodePath
    class, doesn't hold a reference count to the node.  Thus the node may be
    detached from the scene graph and destructed at any time.
    
    You can call is_valid() or was_deleted() at any time to determine whether
    the node is still around; if it is, get_node_path() will return the
    associated NodePath.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self, node_path: NodePath) -> None: ...
    @overload
    def __init__(self, copy: WeakNodePath) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...
    def __lt__(self, other: NodePath | WeakNodePath) -> bool: ...
    def __le__(self, other: NodePath | WeakNodePath) -> bool: ...
    @overload
    def assign(self, node_path: NodePath) -> WeakNodePath: ...
    @overload
    def assign(self, copy: WeakNodePath) -> WeakNodePath: ...
    def clear(self) -> None: ...
    def is_empty(self) -> bool: ...
    def was_deleted(self) -> bool: ...
    def get_node_path(self) -> NodePath: ...
    def node(self) -> PandaNode: ...
    def compare_to(self, other: NodePath | WeakNodePath) -> int: ...
    def get_key(self) -> int: ...
    def output(self, out: ostream) -> None: ...
    isEmpty = is_empty
    wasDeleted = was_deleted
    getNodePath = get_node_path
    compareTo = compare_to
    getKey = get_key

class Camera(LensNode):
    """A node that can be positioned around in the scene graph to represent a
    point of view for rendering a scene.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    active: bool
    scene: NodePath
    camera_mask: BitMask_uint32_t_32
    cull_center: NodePath
    cull_bounds: BoundingVolume
    lod_center: NodePath
    initial_state: RenderState
    tag_state_key: str
    lod_scale: float
    tag_states: Mapping[Any, RenderState]
    aux_scene_data: Mapping[Any, AuxSceneData]
    @property
    def display_regions(self) -> Sequence[DisplayRegion]: ...
    @overload
    def __init__(self, copy: Camera) -> None: ...
    @overload
    def __init__(self, name: str, lens: Lens = ...) -> None: ...
    def set_active(self, active: bool) -> None: ...
    def is_active(self) -> bool: ...
    def set_scene(self, scene: NodePath) -> None: ...
    def get_scene(self) -> NodePath: ...
    def get_num_display_regions(self) -> int: ...
    def get_display_region(self, n: int) -> DisplayRegion: ...
    def set_camera_mask(self, mask: BitMask_uint32_t_32) -> None: ...
    def get_camera_mask(self) -> BitMask_uint32_t_32: ...
    def set_cull_center(self, cull_center: NodePath) -> None: ...
    def get_cull_center(self) -> NodePath: ...
    def set_cull_bounds(self, cull_bounds: BoundingVolume) -> None: ...
    def get_cull_bounds(self) -> BoundingVolume: ...
    def set_lod_center(self, lod_center: NodePath) -> None: ...
    def get_lod_center(self) -> NodePath: ...
    def set_initial_state(self, state: RenderState) -> None: ...
    def get_initial_state(self) -> RenderState: ...
    def set_tag_state_key(self, tag_state_key: str) -> None: ...
    def get_tag_state_key(self) -> str: ...
    def set_lod_scale(self, value: float) -> None: ...
    def get_lod_scale(self) -> float: ...
    def set_tag_state(self, tag_state: str, state: RenderState) -> None: ...
    def clear_tag_state(self, tag_state: str) -> None: ...
    def clear_tag_states(self) -> None: ...
    def has_tag_state(self, tag_state: str) -> bool: ...
    def get_tag_state(self, tag_state: str) -> RenderState: ...
    def set_aux_scene_data(self, node_path: NodePath, data: AuxSceneData) -> None: ...
    def clear_aux_scene_data(self, node_path: NodePath) -> bool: ...
    def get_aux_scene_data(self, node_path: NodePath) -> AuxSceneData: ...
    def list_aux_scene_data(self, out: ostream) -> None: ...
    def cleanup_aux_scene_data(self, current_thread: Thread = ...) -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    def get_display_regions(self) -> tuple[DisplayRegion, ...]: ...
    setActive = set_active
    isActive = is_active
    setScene = set_scene
    getScene = get_scene
    getNumDisplayRegions = get_num_display_regions
    getDisplayRegion = get_display_region
    setCameraMask = set_camera_mask
    getCameraMask = get_camera_mask
    setCullCenter = set_cull_center
    getCullCenter = get_cull_center
    setCullBounds = set_cull_bounds
    getCullBounds = get_cull_bounds
    setLodCenter = set_lod_center
    getLodCenter = get_lod_center
    setInitialState = set_initial_state
    getInitialState = get_initial_state
    setTagStateKey = set_tag_state_key
    getTagStateKey = get_tag_state_key
    setLodScale = set_lod_scale
    getLodScale = get_lod_scale
    setTagState = set_tag_state
    clearTagState = clear_tag_state
    clearTagStates = clear_tag_states
    hasTagState = has_tag_state
    getTagState = get_tag_state
    setAuxSceneData = set_aux_scene_data
    clearAuxSceneData = clear_aux_scene_data
    getAuxSceneData = get_aux_scene_data
    listAuxSceneData = list_aux_scene_data
    cleanupAuxSceneData = cleanup_aux_scene_data
    getClassType = get_class_type
    getDisplayRegions = get_display_regions

class PlaneNode(PandaNode):
    """A node that contains a plane.  This is most often used as a clipping plane,
    but it can serve other purposes as well; whenever a plane is needed to be
    defined in some coordinate space in the world.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    plane: LPlanef
    viz_scale: float
    priority: int
    clip_effect: int
    CE_visible: ClassVar[Literal[1]]
    CE_collision: ClassVar[Literal[2]]
    def __init__(self, name: str, plane: _Vec4f = ...) -> None: ...
    def set_plane(self, plane: _Vec4f) -> None: ...
    def get_plane(self) -> LPlanef: ...
    def set_viz_scale(self, viz_scale: float) -> None: ...
    def get_viz_scale(self) -> float: ...
    def set_priority(self, priority: int) -> None: ...
    def get_priority(self) -> int: ...
    def set_clip_effect(self, clip_effect: int) -> None: ...
    def get_clip_effect(self) -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    setPlane = set_plane
    getPlane = get_plane
    setVizScale = set_viz_scale
    getVizScale = get_viz_scale
    setPriority = set_priority
    getPriority = get_priority
    setClipEffect = set_clip_effect
    getClipEffect = get_clip_effect
    getClassType = get_class_type
    CEVisible = CE_visible
    CECollision = CE_collision

class ClipPlaneAttrib(RenderAttrib):
    """This functions similarly to a LightAttrib.  It indicates the set of
    clipping planes that modify the geometry at this level and below.  A
    ClipPlaneAttrib can either add planes or remove planes from the total set
    of clipping planes in effect.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    O_set: ClassVar[Literal[0]]
    O_add: ClassVar[Literal[1]]
    O_remove: ClassVar[Literal[2]]
    @property
    def class_slot(self) -> int: ...
    @overload
    @staticmethod
    def make() -> RenderAttrib: ...
    @overload
    @staticmethod
    def make(op: _ClipPlaneAttrib_Operation, plane: PlaneNode) -> RenderAttrib: ...
    @overload
    @staticmethod
    def make(op: _ClipPlaneAttrib_Operation, plane1: PlaneNode, plane2: PlaneNode) -> RenderAttrib: ...
    @overload
    @staticmethod
    def make(op: _ClipPlaneAttrib_Operation, plane1: PlaneNode, plane2: PlaneNode, plane3: PlaneNode) -> RenderAttrib: ...
    @overload
    @staticmethod
    def make(op: _ClipPlaneAttrib_Operation, plane1: PlaneNode, plane2: PlaneNode, plane3: PlaneNode, plane4: PlaneNode) -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def get_operation(self) -> _ClipPlaneAttrib_Operation: ...
    def get_num_planes(self) -> int: ...
    def get_plane(self, n: int) -> PlaneNode: ...
    def has_plane(self, plane: PlaneNode) -> bool: ...
    def add_plane(self, plane: PlaneNode) -> RenderAttrib: ...
    def remove_plane(self, plane: PlaneNode) -> RenderAttrib: ...
    @staticmethod
    def make_all_off() -> RenderAttrib: ...
    def get_num_on_planes(self) -> int: ...
    def get_on_plane(self, n: int) -> NodePath: ...
    def has_on_plane(self, plane: NodePath) -> bool: ...
    def get_num_off_planes(self) -> int: ...
    def get_off_plane(self, n: int) -> NodePath: ...
    def has_off_plane(self, plane: NodePath) -> bool: ...
    def has_all_off(self) -> bool: ...
    def is_identity(self) -> bool: ...
    def add_on_plane(self, plane: NodePath) -> RenderAttrib: ...
    def remove_on_plane(self, plane: NodePath) -> RenderAttrib: ...
    def add_off_plane(self, plane: NodePath) -> RenderAttrib: ...
    def remove_off_plane(self, plane: NodePath) -> RenderAttrib: ...
    def filter_to_max(self, max_clip_planes: int) -> ClipPlaneAttrib: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    def get_on_planes(self) -> tuple[NodePath, ...]: ...
    def get_off_planes(self) -> tuple[NodePath, ...]: ...
    makeDefault = make_default
    getOperation = get_operation
    getNumPlanes = get_num_planes
    getPlane = get_plane
    hasPlane = has_plane
    addPlane = add_plane
    removePlane = remove_plane
    makeAllOff = make_all_off
    getNumOnPlanes = get_num_on_planes
    getOnPlane = get_on_plane
    hasOnPlane = has_on_plane
    getNumOffPlanes = get_num_off_planes
    getOffPlane = get_off_plane
    hasOffPlane = has_off_plane
    hasAllOff = has_all_off
    isIdentity = is_identity
    addOnPlane = add_on_plane
    removeOnPlane = remove_on_plane
    addOffPlane = add_off_plane
    removeOffPlane = remove_off_plane
    filterToMax = filter_to_max
    getClassSlot = get_class_slot
    getClassType = get_class_type
    getOnPlanes = get_on_planes
    getOffPlanes = get_off_planes
    OSet = O_set
    OAdd = O_add
    ORemove = O_remove

class ColorAttrib(RenderAttrib):
    """Indicates what color should be applied to renderable geometry."""
    DtoolClassDict: ClassVar[dict[str, Any]]
    T_vertex: ClassVar[Literal[0]]
    T_flat: ClassVar[Literal[1]]
    T_off: ClassVar[Literal[2]]
    @property
    def color_type(self) -> _ColorAttrib_Type: ...
    @property
    def color(self) -> LVecBase4f: ...
    @property
    def class_slot(self) -> int: ...
    @staticmethod
    def make_vertex() -> RenderAttrib: ...
    @staticmethod
    def make_flat(color: _Vec4f) -> RenderAttrib: ...
    @staticmethod
    def make_off() -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def get_color_type(self) -> _ColorAttrib_Type: ...
    def get_color(self) -> LVecBase4f: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeVertex = make_vertex
    makeFlat = make_flat
    makeOff = make_off
    makeDefault = make_default
    getColorType = get_color_type
    getColor = get_color
    getClassSlot = get_class_slot
    getClassType = get_class_type
    TVertex = T_vertex
    TFlat = T_flat
    TOff = T_off

class ColorBlendAttrib(RenderAttrib):
    """This specifies how colors are blended into the frame buffer, for special
    effects.  This overrides transparency if transparency is also specified.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    M_none: ClassVar[Literal[0]]
    M_add: ClassVar[Literal[1]]
    M_subtract: ClassVar[Literal[2]]
    M_inv_subtract: ClassVar[Literal[3]]
    M_min: ClassVar[Literal[4]]
    M_max: ClassVar[Literal[5]]
    O_zero: ClassVar[Literal[0]]
    O_one: ClassVar[Literal[1]]
    O_incoming_color: ClassVar[Literal[2]]
    O_one_minus_incoming_color: ClassVar[Literal[3]]
    O_fbuffer_color: ClassVar[Literal[4]]
    O_one_minus_fbuffer_color: ClassVar[Literal[5]]
    O_incoming_alpha: ClassVar[Literal[6]]
    O_one_minus_incoming_alpha: ClassVar[Literal[7]]
    O_fbuffer_alpha: ClassVar[Literal[8]]
    O_one_minus_fbuffer_alpha: ClassVar[Literal[9]]
    O_constant_color: ClassVar[Literal[10]]
    O_one_minus_constant_color: ClassVar[Literal[11]]
    O_constant_alpha: ClassVar[Literal[12]]
    O_one_minus_constant_alpha: ClassVar[Literal[13]]
    O_incoming_color_saturate: ClassVar[Literal[14]]
    O_incoming1_color: ClassVar[Literal[15]]
    O_one_minus_incoming1_color: ClassVar[Literal[16]]
    O_incoming1_alpha: ClassVar[Literal[17]]
    O_one_minus_incoming1_alpha: ClassVar[Literal[18]]
    O_color_scale: ClassVar[Literal[19]]
    O_one_minus_color_scale: ClassVar[Literal[20]]
    O_alpha_scale: ClassVar[Literal[21]]
    O_one_minus_alpha_scale: ClassVar[Literal[22]]
    @property
    def rgb_mode(self) -> _ColorBlendAttrib_Mode: ...
    @property
    def rgb_operand_a(self) -> _ColorBlendAttrib_Operand: ...
    @property
    def rgb_operand_b(self) -> _ColorBlendAttrib_Operand: ...
    @property
    def alpha_mode(self) -> _ColorBlendAttrib_Mode: ...
    @property
    def alpha_operand_a(self) -> _ColorBlendAttrib_Operand: ...
    @property
    def alpha_operand_b(self) -> _ColorBlendAttrib_Operand: ...
    @property
    def color(self) -> LVecBase4f: ...
    @property
    def class_slot(self) -> int: ...
    @staticmethod
    def make_off() -> RenderAttrib: ...
    @overload
    @staticmethod
    def make(mode: _ColorBlendAttrib_Mode) -> RenderAttrib: ...
    @overload
    @staticmethod
    def make(mode: _ColorBlendAttrib_Mode, a: _ColorBlendAttrib_Operand, b: _ColorBlendAttrib_Operand, color: _Vec4f = ...) -> RenderAttrib: ...
    @overload
    @staticmethod
    def make(rgb_mode: _ColorBlendAttrib_Mode, rgb_a: _ColorBlendAttrib_Operand, rgb_b: _ColorBlendAttrib_Operand, alpha_mode: _ColorBlendAttrib_Mode, alpha_a: _ColorBlendAttrib_Operand, alpha_b: _ColorBlendAttrib_Operand, color: _Vec4f = ...) -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def get_mode(self) -> _ColorBlendAttrib_Mode: ...
    def get_operand_a(self) -> _ColorBlendAttrib_Operand: ...
    def get_operand_b(self) -> _ColorBlendAttrib_Operand: ...
    def get_alpha_mode(self) -> _ColorBlendAttrib_Mode: ...
    def get_alpha_operand_a(self) -> _ColorBlendAttrib_Operand: ...
    def get_alpha_operand_b(self) -> _ColorBlendAttrib_Operand: ...
    def get_color(self) -> LVecBase4f: ...
    @overload
    def involves_constant_color(self) -> bool: ...
    @overload
    def involves_constant_color(self, operand: _ColorBlendAttrib_Operand) -> bool: ...
    @overload
    def involves_color_scale(self) -> bool: ...
    @overload
    def involves_color_scale(self, operand: _ColorBlendAttrib_Operand) -> bool: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeOff = make_off
    makeDefault = make_default
    getMode = get_mode
    getOperandA = get_operand_a
    getOperandB = get_operand_b
    getAlphaMode = get_alpha_mode
    getAlphaOperandA = get_alpha_operand_a
    getAlphaOperandB = get_alpha_operand_b
    getColor = get_color
    involvesConstantColor = involves_constant_color
    involvesColorScale = involves_color_scale
    getClassSlot = get_class_slot
    getClassType = get_class_type
    MNone = M_none
    MAdd = M_add
    MSubtract = M_subtract
    MInvSubtract = M_inv_subtract
    MMin = M_min
    MMax = M_max
    OZero = O_zero
    OOne = O_one
    OIncomingColor = O_incoming_color
    OOneMinusIncomingColor = O_one_minus_incoming_color
    OFbufferColor = O_fbuffer_color
    OOneMinusFbufferColor = O_one_minus_fbuffer_color
    OIncomingAlpha = O_incoming_alpha
    OOneMinusIncomingAlpha = O_one_minus_incoming_alpha
    OFbufferAlpha = O_fbuffer_alpha
    OOneMinusFbufferAlpha = O_one_minus_fbuffer_alpha
    OConstantColor = O_constant_color
    OOneMinusConstantColor = O_one_minus_constant_color
    OConstantAlpha = O_constant_alpha
    OOneMinusConstantAlpha = O_one_minus_constant_alpha
    OIncomingColorSaturate = O_incoming_color_saturate
    OIncoming1Color = O_incoming1_color
    OOneMinusIncoming1Color = O_one_minus_incoming1_color
    OIncoming1Alpha = O_incoming1_alpha
    OOneMinusIncoming1Alpha = O_one_minus_incoming1_alpha
    OColorScale = O_color_scale
    OOneMinusColorScale = O_one_minus_color_scale
    OAlphaScale = O_alpha_scale
    OOneMinusAlphaScale = O_one_minus_alpha_scale

class ColorScaleAttrib(RenderAttrib):
    """Applies a scale to colors in the scene graph and on vertices."""
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def scale(self) -> LVecBase4f: ...
    @property
    def class_slot(self) -> int: ...
    @staticmethod
    def make_identity() -> RenderAttrib: ...
    @staticmethod
    def make(scale: _Vec4f) -> RenderAttrib: ...
    @staticmethod
    def make_off() -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def is_off(self) -> bool: ...
    def is_identity(self) -> bool: ...
    def has_scale(self) -> bool: ...
    def has_rgb_scale(self) -> bool: ...
    def has_alpha_scale(self) -> bool: ...
    def get_scale(self) -> LVecBase4f: ...
    def set_scale(self, scale: _Vec4f) -> RenderAttrib: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeIdentity = make_identity
    makeOff = make_off
    makeDefault = make_default
    isOff = is_off
    isIdentity = is_identity
    hasScale = has_scale
    hasRgbScale = has_rgb_scale
    hasAlphaScale = has_alpha_scale
    getScale = get_scale
    setScale = set_scale
    getClassSlot = get_class_slot
    getClassType = get_class_type

class ColorWriteAttrib(RenderAttrib):
    """Enables or disables writing to the color buffer.  This is primarily useful
    for certain special effects in which it is important to write to the depth
    buffer without affecting the color buffer.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    C_off: ClassVar[Literal[0]]
    C_red: ClassVar[Literal[1]]
    C_green: ClassVar[Literal[2]]
    C_blue: ClassVar[Literal[4]]
    C_rgb: ClassVar[Literal[7]]
    C_alpha: ClassVar[Literal[8]]
    C_all: ClassVar[Literal[15]]
    @property
    def channels(self) -> int: ...
    @property
    def class_slot(self) -> int: ...
    @staticmethod
    def make(channels: int) -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def get_channels(self) -> int: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeDefault = make_default
    getChannels = get_channels
    getClassSlot = get_class_slot
    getClassType = get_class_type
    COff = C_off
    CRed = C_red
    CGreen = C_green
    CBlue = C_blue
    CRgb = C_rgb
    CAlpha = C_alpha
    CAll = C_all

class CompassEffect(RenderEffect):
    """A CompassEffect causes a node to inherit its rotation (or pos or scale, if
    specified) from some other reference node in the graph, or more often from
    the root.
    
    In its purest form, a CompassEffect is used to keep the node's rotation
    fixed relative to the top of the scene graph, despite other transforms that
    may exist above the node.  Hence the name: the node behaves like a magnetic
    compass, always pointing in the same direction.
    
    As an couple of generalizing extensions, the CompassEffect may also be set
    up to always orient its node according to some other reference node than
    the root of the scene graph.  Furthermore, it may optionally adjust any of
    pos, rotation, or scale, instead of necessarily rotation; and it may adjust
    individual pos and scale components.  (Rotation may not be adjusted on an
    individual component basis; that's just asking for trouble.)
    
    Be careful when using the pos and scale modes.  In these modes, it's
    possible for the CompassEffect to move its node far from its normal
    bounding volume, causing culling to fail.  If this is an issue, you may
    need to explicitly set a large (or infinite) bounding volume on the effect
    node.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    P_x: ClassVar[Literal[1]]
    P_y: ClassVar[Literal[2]]
    P_z: ClassVar[Literal[4]]
    P_pos: ClassVar[Literal[7]]
    P_rot: ClassVar[Literal[8]]
    P_sx: ClassVar[Literal[16]]
    P_sy: ClassVar[Literal[32]]
    P_sz: ClassVar[Literal[64]]
    P_scale: ClassVar[Literal[112]]
    P_all: ClassVar[Literal[127]]
    @staticmethod
    def make(reference: NodePath, properties: int = ...) -> RenderEffect: ...
    def get_reference(self) -> NodePath: ...
    def get_properties(self) -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getReference = get_reference
    getProperties = get_properties
    getClassType = get_class_type
    PX = P_x
    PY = P_y
    PZ = P_z
    PPos = P_pos
    PRot = P_rot
    PSx = P_sx
    PSy = P_sy
    PSz = P_sz
    PScale = P_scale
    PAll = P_all

class CullBinEnums:
    """Provides scoping for the enumerated type shared by CullBin and
    CullBinManager.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    BT_invalid: ClassVar[Literal[0]]
    BT_unsorted: ClassVar[Literal[1]]
    BT_state_sorted: ClassVar[Literal[2]]
    BT_back_to_front: ClassVar[Literal[3]]
    BT_front_to_back: ClassVar[Literal[4]]
    BT_fixed: ClassVar[Literal[5]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, __param0: CullBinEnums) -> None: ...
    BTInvalid = BT_invalid
    BTUnsorted = BT_unsorted
    BTStateSorted = BT_state_sorted
    BTBackToFront = BT_back_to_front
    BTFrontToBack = BT_front_to_back
    BTFixed = BT_fixed

class GeomNode(PandaNode):
    """A node that holds Geom objects, renderable pieces of geometry.  This is the
    primary kind of leaf node in the scene graph; almost all visible objects
    will be contained in a GeomNode somewhere.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def default_collide_mask(self) -> BitMask_uint32_t_32: ...
    def __init__(self, name: str) -> None: ...
    def set_preserved(self, value: bool) -> None: ...
    def get_preserved(self) -> bool: ...
    def get_num_geoms(self) -> int: ...
    def get_geom(self, n: int) -> Geom: ...
    def modify_geom(self, n: int) -> Geom: ...
    def get_geom_state(self, n: int) -> RenderState: ...
    def set_geom_state(self, n: int, state: RenderState) -> None: ...
    def add_geom(self, geom: Geom, state: RenderState = ...) -> None: ...
    def add_geoms_from(self, other: GeomNode) -> None: ...
    def set_geom(self, n: int, geom: Geom) -> None: ...
    def remove_geom(self, n: int) -> None: ...
    def remove_all_geoms(self) -> None: ...
    def check_valid(self) -> bool: ...
    def decompose(self) -> None: ...
    def unify(self, max_indices: int, preserve_order: bool) -> None: ...
    def write_geoms(self, out: ostream, indent_level: int) -> None: ...
    def write_verbose(self, out: ostream, indent_level: int) -> None: ...
    @staticmethod
    def get_default_collide_mask() -> BitMask_uint32_t_32: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    def get_geoms(self) -> tuple[Geom, ...]: ...
    def modify_geoms(self) -> tuple[Geom, ...]: ...
    def get_geom_states(self) -> tuple[RenderState, ...]: ...
    setPreserved = set_preserved
    getPreserved = get_preserved
    getNumGeoms = get_num_geoms
    getGeom = get_geom
    modifyGeom = modify_geom
    getGeomState = get_geom_state
    setGeomState = set_geom_state
    addGeom = add_geom
    addGeomsFrom = add_geoms_from
    setGeom = set_geom
    removeGeom = remove_geom
    removeAllGeoms = remove_all_geoms
    checkValid = check_valid
    writeGeoms = write_geoms
    writeVerbose = write_verbose
    getDefaultCollideMask = get_default_collide_mask
    getClassType = get_class_type
    getGeoms = get_geoms
    modifyGeoms = modify_geoms
    getGeomStates = get_geom_states

class CullBinAttrib(RenderAttrib):
    """Assigns geometry to a particular bin by name.  The bins must be created
    separately via the CullBinManager interface.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def bin_name(self) -> str: ...
    @property
    def draw_order(self) -> int: ...
    @property
    def class_slot(self) -> int: ...
    @staticmethod
    def make(bin_name: str, draw_order: int) -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def get_bin_name(self) -> str: ...
    def get_draw_order(self) -> int: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeDefault = make_default
    getBinName = get_bin_name
    getDrawOrder = get_draw_order
    getClassSlot = get_class_slot
    getClassType = get_class_type

class CullBinManager(CullBinEnums):
    """This is a global object that maintains the collection of named CullBins in
    the world.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def add_bin(self, name: str, type: _CullBinEnums_BinType, sort: int) -> int: ...
    def remove_bin(self, bin_index: int) -> None: ...
    def get_num_bins(self) -> int: ...
    def get_bin(self, n: int) -> int: ...
    def find_bin(self, name: str) -> int: ...
    def get_bin_name(self, bin_index: int) -> str: ...
    @overload
    def get_bin_type(self, bin_index: int) -> _CullBinEnums_BinType: ...
    @overload
    def get_bin_type(self, name: str) -> _CullBinEnums_BinType: ...
    @overload
    def set_bin_type(self, bin_index: int, type: _CullBinEnums_BinType) -> None: ...
    @overload
    def set_bin_type(self, name: str, type: _CullBinEnums_BinType) -> None: ...
    @overload
    def get_bin_sort(self, bin_index: int) -> int: ...
    @overload
    def get_bin_sort(self, name: str) -> int: ...
    @overload
    def set_bin_sort(self, bin_index: int, sort: int) -> None: ...
    @overload
    def set_bin_sort(self, name: str, sort: int) -> None: ...
    @overload
    def get_bin_active(self, bin_index: int) -> bool: ...
    @overload
    def get_bin_active(self, name: str) -> bool: ...
    @overload
    def set_bin_active(self, bin_index: int, active: bool) -> None: ...
    @overload
    def set_bin_active(self, name: str, active: bool) -> None: ...
    def get_bin_flash_active(self, bin_index: int) -> bool: ...
    def get_bin_flash_color(self, bin_index: int) -> LVecBase4f: ...
    def set_bin_flash_active(self, bin_index: int, active: bool) -> None: ...
    def set_bin_flash_color(self, bin_index: int, color: _Vec4f) -> None: ...
    def write(self, out: ostream) -> None: ...
    @staticmethod
    def get_global_ptr() -> CullBinManager: ...
    def get_bins(self) -> tuple[int, ...]: ...
    addBin = add_bin
    removeBin = remove_bin
    getNumBins = get_num_bins
    getBin = get_bin
    findBin = find_bin
    getBinName = get_bin_name
    getBinType = get_bin_type
    setBinType = set_bin_type
    getBinSort = get_bin_sort
    setBinSort = set_bin_sort
    getBinActive = get_bin_active
    setBinActive = set_bin_active
    getBinFlashActive = get_bin_flash_active
    getBinFlashColor = get_bin_flash_color
    setBinFlashActive = set_bin_flash_active
    setBinFlashColor = set_bin_flash_color
    getGlobalPtr = get_global_ptr
    getBins = get_bins

class CullFaceAttrib(RenderAttrib):
    """Indicates which faces should be culled based on their vertex ordering."""
    DtoolClassDict: ClassVar[dict[str, Any]]
    M_cull_none: ClassVar[Literal[0]]
    M_cull_clockwise: ClassVar[Literal[1]]
    M_cull_counter_clockwise: ClassVar[Literal[2]]
    M_cull_unchanged: ClassVar[Literal[3]]
    @property
    def mode(self) -> _CullFaceAttrib_Mode: ...
    @property
    def reverse(self) -> bool: ...
    @property
    def effective_mode(self) -> _CullFaceAttrib_Mode: ...
    @property
    def class_slot(self) -> int: ...
    @staticmethod
    def make(mode: _CullFaceAttrib_Mode = ...) -> RenderAttrib: ...
    @staticmethod
    def make_reverse() -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def get_actual_mode(self) -> _CullFaceAttrib_Mode: ...
    def get_reverse(self) -> bool: ...
    def get_effective_mode(self) -> _CullFaceAttrib_Mode: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeReverse = make_reverse
    makeDefault = make_default
    getActualMode = get_actual_mode
    getReverse = get_reverse
    getEffectiveMode = get_effective_mode
    getClassSlot = get_class_slot
    getClassType = get_class_type
    MCullNone = M_cull_none
    MCullClockwise = M_cull_clockwise
    MCullCounterClockwise = M_cull_counter_clockwise
    MCullUnchanged = M_cull_unchanged

class WorkingNodePath:
    """This is a class designed to support low-overhead traversals of the complete
    scene graph, with a memory of the complete path through the graph at any
    given point.
    
    You could just use a regular NodePath to do this, but since the NodePath
    requires storing NodePathComponents on each node as it is constructed, and
    then removing them when it destructs, there is considerable overhead in
    that approach.
    
    The WorkingNodePath eliminates this overhead (but does not guarantee
    consistency if the scene graph changes while the path is held).
    
    At any given point, you may ask the WorkingNodePath for its actual
    NodePath, and it will construct and return a new NodePath representing the
    complete generated chain.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def valid(self) -> bool: ...
    @property
    def node_path(self) -> NodePath: ...

class CullTraverserData:
    """This collects together the pieces of data that are accumulated for each
    node while walking the scene graph during the cull traversal.
    
    Having this as a separate object simplifies the parameter list to
    CullTraverser::r_traverse(), as well as to other functions like
    PandaNode::cull_callback().  It also makes it easier to add cull
    parameters, and provides a place to abstract out some of the cull behavior
    (like view-frustum culling).
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def node_path(self) -> NodePath: ...
    def __init__(self, __param0: CullTraverserData) -> None: ...
    def node(self) -> PandaNode: ...
    def get_modelview_transform(self, trav: CullTraverser) -> TransformState: ...
    def get_internal_transform(self, trav: CullTraverser) -> TransformState: ...
    def get_net_transform(self, trav: CullTraverser) -> TransformState: ...
    def is_in_view(self, camera_mask: BitMask_uint32_t_32) -> bool: ...
    def is_this_node_hidden(self, camera_mask: BitMask_uint32_t_32) -> bool: ...
    def apply_transform_and_state(self, trav: CullTraverser) -> None: ...
    def apply_transform(self, node_transform: TransformState) -> None: ...
    getModelviewTransform = get_modelview_transform
    getInternalTransform = get_internal_transform
    getNetTransform = get_net_transform
    isInView = is_in_view
    isThisNodeHidden = is_this_node_hidden
    applyTransformAndState = apply_transform_and_state
    applyTransform = apply_transform

class SceneSetup(TypedReferenceCount):
    """This object holds the camera position, etc., and other general setup
    information for rendering a particular scene.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, __param0: SceneSetup) -> None: ...
    def set_display_region(self, display_region: DisplayRegion) -> None: ...
    def get_display_region(self) -> DisplayRegion: ...
    def set_viewport_size(self, width: int, height: int) -> None: ...
    def get_viewport_width(self) -> int: ...
    def get_viewport_height(self) -> int: ...
    def set_scene_root(self, scene_root: NodePath) -> None: ...
    def get_scene_root(self) -> NodePath: ...
    def set_camera_path(self, camera_path: NodePath) -> None: ...
    def get_camera_path(self) -> NodePath: ...
    def set_camera_node(self, camera_node: Camera) -> None: ...
    def get_camera_node(self) -> Camera: ...
    def set_lens(self, lens: Lens) -> None: ...
    def get_lens(self) -> Lens: ...
    def set_inverted(self, inverted: bool) -> None: ...
    def get_inverted(self) -> bool: ...
    def get_cull_center(self) -> NodePath: ...
    def get_cull_bounds(self) -> BoundingVolume: ...
    def set_initial_state(self, initial_state: RenderState) -> None: ...
    def get_initial_state(self) -> RenderState: ...
    def set_camera_transform(self, camera_transform: TransformState) -> None: ...
    def get_camera_transform(self) -> TransformState: ...
    def set_world_transform(self, world_transform: TransformState) -> None: ...
    def get_world_transform(self) -> TransformState: ...
    def set_cs_transform(self, cs_transform: TransformState) -> None: ...
    def get_cs_transform(self) -> TransformState: ...
    def set_cs_world_transform(self, cs_world_transform: TransformState) -> None: ...
    def get_cs_world_transform(self) -> TransformState: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    setDisplayRegion = set_display_region
    getDisplayRegion = get_display_region
    setViewportSize = set_viewport_size
    getViewportWidth = get_viewport_width
    getViewportHeight = get_viewport_height
    setSceneRoot = set_scene_root
    getSceneRoot = get_scene_root
    setCameraPath = set_camera_path
    getCameraPath = get_camera_path
    setCameraNode = set_camera_node
    getCameraNode = get_camera_node
    setLens = set_lens
    getLens = get_lens
    setInverted = set_inverted
    getInverted = get_inverted
    getCullCenter = get_cull_center
    getCullBounds = get_cull_bounds
    setInitialState = set_initial_state
    getInitialState = get_initial_state
    setCameraTransform = set_camera_transform
    getCameraTransform = get_camera_transform
    setWorldTransform = set_world_transform
    getWorldTransform = get_world_transform
    setCsTransform = set_cs_transform
    getCsTransform = get_cs_transform
    setCsWorldTransform = set_cs_world_transform
    getCsWorldTransform = get_cs_world_transform
    getClassType = get_class_type

class Fog(PandaNode):
    """Specifies how atmospheric fog effects are applied to geometry.  The Fog
    object is now a PandaNode, which means it can be used similarly to a Light
    to define effects relative to a particular coordinate system within the
    scene graph.
    
    In exponential mode, the fog effects are always camera-relative, and it
    does not matter where the Fog node is parented.  However, in linear mode,
    the onset and opaque distances are defined as offsets along the local
    forward axis (e.g.  the Y axis).  This allows the fog effect to be
    localized to a particular region in space, rather than always camera-
    relative.  If the fog object is not parented to any node, it is used to
    generate traditonal camera-relative fog, as if it were parented to the
    camera.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    mode: _Fog_Mode
    color: LVecBase4f
    linear_onset_point: LPoint3f
    linear_opaque_point: LPoint3f
    exp_density: float
    M_linear: ClassVar[Literal[0]]
    M_exponential: ClassVar[Literal[1]]
    M_exponential_squared: ClassVar[Literal[2]]
    def __init__(self, name: str) -> None: ...
    def get_mode(self) -> _Fog_Mode: ...
    def set_mode(self, mode: _Fog_Mode) -> None: ...
    def get_color(self) -> LVecBase4f: ...
    @overload
    def set_color(self, color: _Vec4f) -> None: ...
    @overload
    def set_color(self, r: float, g: float, b: float) -> None: ...
    def set_linear_range(self, onset: float, opaque: float) -> None: ...
    def get_linear_onset_point(self) -> LPoint3f: ...
    @overload
    def set_linear_onset_point(self, linear_onset_point: _Vec3f) -> None: ...
    @overload
    def set_linear_onset_point(self, x: float, y: float, z: float) -> None: ...
    def get_linear_opaque_point(self) -> LPoint3f: ...
    @overload
    def set_linear_opaque_point(self, linear_opaque_point: _Vec3f) -> None: ...
    @overload
    def set_linear_opaque_point(self, x: float, y: float, z: float) -> None: ...
    def set_linear_fallback(self, angle: float, onset: float, opaque: float) -> None: ...
    def get_exp_density(self) -> float: ...
    def set_exp_density(self, exp_density: float) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getMode = get_mode
    setMode = set_mode
    getColor = get_color
    setColor = set_color
    setLinearRange = set_linear_range
    getLinearOnsetPoint = get_linear_onset_point
    setLinearOnsetPoint = set_linear_onset_point
    getLinearOpaquePoint = get_linear_opaque_point
    setLinearOpaquePoint = set_linear_opaque_point
    setLinearFallback = set_linear_fallback
    getExpDensity = get_exp_density
    setExpDensity = set_exp_density
    getClassType = get_class_type
    MLinear = M_linear
    MExponential = M_exponential
    MExponentialSquared = M_exponential_squared

class FogAttrib(RenderAttrib):
    """Applies a Fog to the geometry at and below this node."""
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def fog(self) -> Fog: ...
    @property
    def class_slot(self) -> int: ...
    @staticmethod
    def make(fog: Fog) -> RenderAttrib: ...
    @staticmethod
    def make_off() -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def is_off(self) -> bool: ...
    def get_fog(self) -> Fog: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeOff = make_off
    makeDefault = make_default
    isOff = is_off
    getFog = get_fog
    getClassSlot = get_class_slot
    getClassType = get_class_type

class CullTraverser(TypedReferenceCount):
    """This object performs a depth-first traversal of the scene graph, with
    optional view-frustum culling, collecting CullState and searching for
    GeomNodes.  Each renderable Geom encountered is passed along with its
    associated RenderState to the CullHandler object.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, copy: CullTraverser) -> None: ...
    def get_gsg(self) -> GraphicsStateGuardianBase: ...
    def get_current_thread(self) -> Thread: ...
    def set_scene(self, scene_setup: SceneSetup, gsg: GraphicsStateGuardianBase, dr_incomplete_render: bool) -> None: ...
    def get_scene(self) -> SceneSetup: ...
    def has_tag_state_key(self) -> bool: ...
    def get_tag_state_key(self) -> str: ...
    def set_camera_mask(self, camera_mask: BitMask_uint32_t_32) -> None: ...
    def get_camera_mask(self) -> BitMask_uint32_t_32: ...
    def get_camera_transform(self) -> TransformState: ...
    def get_world_transform(self) -> TransformState: ...
    def get_initial_state(self) -> RenderState: ...
    def get_depth_offset_decals(self) -> bool: ...
    def set_view_frustum(self, view_frustum: GeometricBoundingVolume) -> None: ...
    def get_view_frustum(self) -> GeometricBoundingVolume: ...
    def get_effective_incomplete_render(self) -> bool: ...
    @overload
    def traverse(self, data: CullTraverserData) -> None: ...
    @overload
    def traverse(self, root: NodePath) -> None: ...
    def traverse_below(self, data: CullTraverserData) -> None: ...
    def end_traverse(self) -> None: ...
    @staticmethod
    def flush_level() -> None: ...
    def draw_bounding_volume(self, vol: BoundingVolume, internal_transform: TransformState) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getGsg = get_gsg
    getCurrentThread = get_current_thread
    setScene = set_scene
    getScene = get_scene
    hasTagStateKey = has_tag_state_key
    getTagStateKey = get_tag_state_key
    setCameraMask = set_camera_mask
    getCameraMask = get_camera_mask
    getCameraTransform = get_camera_transform
    getWorldTransform = get_world_transform
    getInitialState = get_initial_state
    getDepthOffsetDecals = get_depth_offset_decals
    setViewFrustum = set_view_frustum
    getViewFrustum = get_view_frustum
    getEffectiveIncompleteRender = get_effective_incomplete_render
    traverseBelow = traverse_below
    endTraverse = end_traverse
    flushLevel = flush_level
    drawBoundingVolume = draw_bounding_volume
    getClassType = get_class_type

class GeomDrawCallbackData(CallbackData):
    """This specialization on CallbackData is passed when the callback is
    initiated from deep within the draw traversal, for a particular Geom.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def get_gsg(self) -> GraphicsStateGuardianBase: ...
    def get_force(self) -> bool: ...
    def set_lost_state(self, lost_state: bool) -> None: ...
    def get_lost_state(self) -> bool: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getGsg = get_gsg
    getForce = get_force
    setLostState = set_lost_state
    getLostState = get_lost_state
    getClassType = get_class_type

class RescaleNormalAttrib(RenderAttrib):
    """Specifies how polygons are to be drawn."""
    DtoolClassDict: ClassVar[dict[str, Any]]
    M_none: ClassVar[Literal[0]]
    M_rescale: ClassVar[Literal[1]]
    M_normalize: ClassVar[Literal[2]]
    M_auto: ClassVar[Literal[3]]
    @property
    def mode(self) -> _RescaleNormalAttrib_Mode: ...
    @property
    def class_slot(self) -> int: ...
    @staticmethod
    def make(mode: _RescaleNormalAttrib_Mode) -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def get_mode(self) -> _RescaleNormalAttrib_Mode: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeDefault = make_default
    getMode = get_mode
    getClassSlot = get_class_slot
    getClassType = get_class_type
    MNone = M_none
    MRescale = M_rescale
    MNormalize = M_normalize
    MAuto = M_auto

class CullResult(ReferenceCount):
    """This stores the result of a BinCullHandler traversal: an ordered collection
    of CullBins, each of which holds a number of Geoms and RenderStates to be
    rendered in some defined order.
    
    This is also used to keep the results of last frame's cull traversal around
    to make next frame's traversal of the same scene a little easier.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, __param0: CullResult) -> None: ...
    def make_next(self) -> CullResult: ...
    def finish_cull(self, scene_setup: SceneSetup, current_thread: Thread) -> None: ...
    def draw(self, current_thread: Thread) -> None: ...
    def make_result_graph(self) -> PandaNode: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeNext = make_next
    finishCull = finish_cull
    makeResultGraph = make_result_graph
    getClassType = get_class_type

class DecalEffect(RenderEffect):
    """Applied to a GeomNode to indicate that the children of this GeomNode are
    coplanar and should be drawn as decals (eliminating Z-fighting).
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @staticmethod
    def make() -> RenderEffect: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getClassType = get_class_type

class DepthOffsetAttrib(RenderAttrib):
    """This is a special kind of attribute that instructs the graphics driver to
    apply an offset or bias to the generated depth values for rendered
    polygons, before they are written to the depth buffer.
    
    This can be used to shift polygons forward slightly, to resolve depth
    conflicts.  The cull traverser may optionally use this, for instance, to
    implement decals.  However, driver support for this feature seems to be
    spotty, so use with caution.
    
    The bias is always an integer number, and each integer increment represents
    the smallest possible increment in Z that is sufficient to completely
    resolve two coplanar polygons.  Positive numbers are closer towards the
    camera.
    
    Nested DepthOffsetAttrib values accumulate; that is, a DepthOffsetAttrib
    with a value of 1 beneath another DepthOffsetAttrib with a value of 2
    presents a net offset of 3.  (A DepthOffsetAttrib will not, however,
    combine with any other DepthOffsetAttribs with a lower override parameter.)
    The net value should probably not exceed 16 or drop below 0 for maximum
    portability.
    
    Also, and only tangentially related, the DepthOffsetAttrib can be used to
    constrain the Z output value to a subset of the usual [0, 1] range (or
    reversing its direction) by specifying a new min_value and max_value.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def offset(self) -> int: ...
    @property
    def min_value(self) -> float: ...
    @property
    def max_value(self) -> float: ...
    @property
    def class_slot(self) -> int: ...
    @overload
    @staticmethod
    def make(offset: int = ...) -> RenderAttrib: ...
    @overload
    @staticmethod
    def make(offset: int, min_value: float, max_value: float) -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def get_offset(self) -> int: ...
    def get_min_value(self) -> float: ...
    def get_max_value(self) -> float: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeDefault = make_default
    getOffset = get_offset
    getMinValue = get_min_value
    getMaxValue = get_max_value
    getClassSlot = get_class_slot
    getClassType = get_class_type

class DepthTestAttrib(RenderAttrib):
    """Enables or disables writing to the depth buffer."""
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def mode(self) -> _RenderAttrib_PandaCompareFunc: ...
    @property
    def class_slot(self) -> int: ...
    @staticmethod
    def make(mode: _RenderAttrib_PandaCompareFunc) -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def get_mode(self) -> _RenderAttrib_PandaCompareFunc: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeDefault = make_default
    getMode = get_mode
    getClassSlot = get_class_slot
    getClassType = get_class_type

class DepthWriteAttrib(RenderAttrib):
    """Enables or disables writing to the depth buffer."""
    DtoolClassDict: ClassVar[dict[str, Any]]
    M_off: ClassVar[Literal[0]]
    M_on: ClassVar[Literal[1]]
    @property
    def mode(self) -> _DepthWriteAttrib_Mode: ...
    @property
    def class_slot(self) -> int: ...
    @staticmethod
    def make(mode: _DepthWriteAttrib_Mode) -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def get_mode(self) -> _DepthWriteAttrib_Mode: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeDefault = make_default
    getMode = get_mode
    getClassSlot = get_class_slot
    getClassType = get_class_type
    MOff = M_off
    MOn = M_on

class Light:
    """The abstract interface to all kinds of lights.  The actual light objects
    also inherit from PandaNode, and can therefore be added to the scene graph
    at some arbitrary point to define the coordinate system of effect.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    color: LVecBase4f
    color_temperature: float
    priority: int
    def as_node(self) -> PandaNode: ...
    def is_ambient_light(self) -> bool: ...
    def get_color(self) -> LVecBase4f: ...
    def set_color(self, color: _Vec4f) -> None: ...
    def has_color_temperature(self) -> bool: ...
    def get_color_temperature(self) -> float: ...
    def set_color_temperature(self, temperature: float) -> None: ...
    def get_exponent(self) -> float: ...
    def get_specular_color(self) -> LVecBase4f: ...
    def get_attenuation(self) -> LVecBase3f: ...
    def set_priority(self, priority: int) -> None: ...
    def get_priority(self) -> int: ...
    def get_class_priority(self) -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    asNode = as_node
    isAmbientLight = is_ambient_light
    getColor = get_color
    setColor = set_color
    hasColorTemperature = has_color_temperature
    getColorTemperature = get_color_temperature
    setColorTemperature = set_color_temperature
    getExponent = get_exponent
    getSpecularColor = get_specular_color
    getAttenuation = get_attenuation
    setPriority = set_priority
    getPriority = get_priority
    getClassPriority = get_class_priority
    getClassType = get_class_type

class LightAttrib(RenderAttrib):
    """Indicates which set of lights should be considered "on" to illuminate
    geometry at this level and below.  A LightAttrib can either add lights or
    remove lights from the total set of "on" lights.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    O_set: ClassVar[Literal[0]]
    O_add: ClassVar[Literal[1]]
    O_remove: ClassVar[Literal[2]]
    @property
    def on_lights(self) -> Sequence[NodePath]: ...
    @property
    def off_lights(self) -> Sequence[NodePath]: ...
    @property
    def class_slot(self) -> int: ...
    @overload
    @staticmethod
    def make() -> RenderAttrib: ...
    @overload
    @staticmethod
    def make(op: _LightAttrib_Operation, light: Light) -> RenderAttrib: ...
    @overload
    @staticmethod
    def make(op: _LightAttrib_Operation, light1: Light, light2: Light) -> RenderAttrib: ...
    @overload
    @staticmethod
    def make(op: _LightAttrib_Operation, light1: Light, light2: Light, light3: Light) -> RenderAttrib: ...
    @overload
    @staticmethod
    def make(op: _LightAttrib_Operation, light1: Light, light2: Light, light3: Light, light4: Light) -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def get_operation(self) -> _LightAttrib_Operation: ...
    def get_num_lights(self) -> int: ...
    def get_light(self, n: int) -> Light: ...
    def has_light(self, light: Light) -> bool: ...
    def add_light(self, light: Light) -> RenderAttrib: ...
    def remove_light(self, light: Light) -> RenderAttrib: ...
    @staticmethod
    def make_all_off() -> RenderAttrib: ...
    def get_num_on_lights(self) -> int: ...
    def get_num_non_ambient_lights(self) -> int: ...
    def get_on_light(self, n: int) -> NodePath: ...
    def has_on_light(self, light: NodePath) -> bool: ...
    def has_any_on_light(self) -> bool: ...
    def get_num_off_lights(self) -> int: ...
    def get_off_light(self, n: int) -> NodePath: ...
    def has_off_light(self, light: NodePath) -> bool: ...
    def has_all_off(self) -> bool: ...
    def is_identity(self) -> bool: ...
    def add_on_light(self, light: NodePath) -> RenderAttrib: ...
    def remove_on_light(self, light: NodePath) -> RenderAttrib: ...
    def replace_on_light(self, source: NodePath, dest: NodePath) -> RenderAttrib: ...
    def add_off_light(self, light: NodePath) -> RenderAttrib: ...
    def remove_off_light(self, light: NodePath) -> RenderAttrib: ...
    def replace_off_light(self, source: NodePath, dest: NodePath) -> RenderAttrib: ...
    def get_most_important_light(self) -> NodePath: ...
    def get_ambient_contribution(self) -> LVecBase4f: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    def get_on_lights(self) -> tuple[NodePath, ...]: ...
    def get_off_lights(self) -> tuple[NodePath, ...]: ...
    makeDefault = make_default
    getOperation = get_operation
    getNumLights = get_num_lights
    getLight = get_light
    hasLight = has_light
    addLight = add_light
    removeLight = remove_light
    makeAllOff = make_all_off
    getNumOnLights = get_num_on_lights
    getNumNonAmbientLights = get_num_non_ambient_lights
    getOnLight = get_on_light
    hasOnLight = has_on_light
    hasAnyOnLight = has_any_on_light
    getNumOffLights = get_num_off_lights
    getOffLight = get_off_light
    hasOffLight = has_off_light
    hasAllOff = has_all_off
    isIdentity = is_identity
    addOnLight = add_on_light
    removeOnLight = remove_on_light
    replaceOnLight = replace_on_light
    addOffLight = add_off_light
    removeOffLight = remove_off_light
    replaceOffLight = replace_off_light
    getMostImportantLight = get_most_important_light
    getAmbientContribution = get_ambient_contribution
    getClassSlot = get_class_slot
    getClassType = get_class_type
    getOnLights = get_on_lights
    getOffLights = get_off_lights
    OSet = O_set
    OAdd = O_add
    ORemove = O_remove

class LightRampAttrib(RenderAttrib):
    """A Light Ramp is any unary operator that takes a rendered pixel as input,
    and adjusts the brightness of that pixel.  For example, gamma correction is
    a kind of light ramp.  So is HDR tone mapping.  So is cartoon shading.  See
    the constructors for an explanation of each kind of ramp.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    LRT_default: ClassVar[Literal[0]]
    LRT_identity: ClassVar[Literal[1]]
    LRT_single_threshold: ClassVar[Literal[2]]
    LRT_double_threshold: ClassVar[Literal[3]]
    LRT_hdr0: ClassVar[Literal[4]]
    LRT_hdr1: ClassVar[Literal[5]]
    LRT_hdr2: ClassVar[Literal[6]]
    @property
    def mode(self) -> _LightRampAttrib_LightRampMode: ...
    @property
    def class_slot(self) -> int: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    @staticmethod
    def make_identity() -> RenderAttrib: ...
    @staticmethod
    def make_single_threshold(thresh0: float, lev0: float) -> RenderAttrib: ...
    @staticmethod
    def make_double_threshold(thresh0: float, lev0: float, thresh1: float, lev1: float) -> RenderAttrib: ...
    @staticmethod
    def make_hdr0() -> RenderAttrib: ...
    @staticmethod
    def make_hdr1() -> RenderAttrib: ...
    @staticmethod
    def make_hdr2() -> RenderAttrib: ...
    def get_mode(self) -> _LightRampAttrib_LightRampMode: ...
    def get_level(self, n: int) -> float: ...
    def get_threshold(self, n: int) -> float: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeDefault = make_default
    makeIdentity = make_identity
    makeSingleThreshold = make_single_threshold
    makeDoubleThreshold = make_double_threshold
    makeHdr0 = make_hdr0
    makeHdr1 = make_hdr1
    makeHdr2 = make_hdr2
    getMode = get_mode
    getLevel = get_level
    getThreshold = get_threshold
    getClassSlot = get_class_slot
    getClassType = get_class_type
    LRTDefault = LRT_default
    LRTIdentity = LRT_identity
    LRTSingleThreshold = LRT_single_threshold
    LRTDoubleThreshold = LRT_double_threshold
    LRTHdr0 = LRT_hdr0
    LRTHdr1 = LRT_hdr1
    LRTHdr2 = LRT_hdr2

class Loader(TypedReferenceCount, Namable):
    """A convenient class for loading models from disk, in bam or egg format (or
    any of a number of other formats implemented by a LoaderFileType, such as
    ptloader).
    
    This class supports synchronous as well as asynchronous loading.  In
    asynchronous loading, the model is loaded in the background by a thread,
    and an event will be generated when the model is available.  If threading
    is not available, the asynchronous loading interface may be used, but it
    loads synchronously.
    """
    class Results:
        DtoolClassDict: ClassVar[dict[str, Any]]
        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, copy: Loader.Results) -> None: ...
        def assign(self, copy: Loader.Results) -> Loader.Results: ...
        def clear(self) -> None: ...
        def get_num_files(self) -> int: ...
        def get_file(self, n: int) -> Filename: ...
        def get_file_type(self, n: int) -> LoaderFileType: ...
        def get_files(self) -> tuple[Filename, ...]: ...
        def get_file_types(self) -> tuple[LoaderFileType, ...]: ...
        getNumFiles = get_num_files
        getFile = get_file
        getFileType = get_file_type
        getFiles = get_files
        getFileTypes = get_file_types
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self, name: str = ...) -> None: ...
    @overload
    def __init__(self, __param0: Loader) -> None: ...
    def upcast_to_TypedReferenceCount(self) -> TypedReferenceCount: ...
    def upcast_to_Namable(self) -> Namable: ...
    def set_task_manager(self, task_manager: AsyncTaskManager) -> None: ...
    def get_task_manager(self) -> AsyncTaskManager: ...
    def set_task_chain(self, task_chain: str) -> None: ...
    def get_task_chain(self) -> str: ...
    def stop_threads(self) -> None: ...
    def remove(self, task: AsyncTask) -> bool: ...
    def load_sync(self, filename: _Filename, options: LoaderOptions = ...) -> PandaNode: ...
    def make_async_request(self, filename: _Filename, options: LoaderOptions = ...) -> AsyncTask: ...
    def load_async(self, request: AsyncTask) -> None: ...
    def save_sync(self, filename: _Filename, options: LoaderOptions, node: PandaNode) -> bool: ...
    def make_async_save_request(self, filename: _Filename, options: LoaderOptions, node: PandaNode) -> AsyncTask: ...
    def save_async(self, request: AsyncTask) -> None: ...
    def load_bam_stream(self, _in: istream) -> PandaNode: ...
    def output(self, out: ostream) -> None: ...
    @staticmethod
    def get_global_ptr() -> Loader: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    upcastToTypedReferenceCount = upcast_to_TypedReferenceCount
    upcastToNamable = upcast_to_Namable
    setTaskManager = set_task_manager
    getTaskManager = get_task_manager
    setTaskChain = set_task_chain
    getTaskChain = get_task_chain
    stopThreads = stop_threads
    loadSync = load_sync
    makeAsyncRequest = make_async_request
    loadAsync = load_async
    saveSync = save_sync
    makeAsyncSaveRequest = make_async_save_request
    saveAsync = save_async
    loadBamStream = load_bam_stream
    getGlobalPtr = get_global_ptr
    getClassType = get_class_type

class LoaderFileType(TypedObject):
    """This is the base class for a family of scene-graph file types that the
    Loader supports.  Each kind of loader that's available should define a
    corresponding LoaderFileType object and register itself.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def get_name(self) -> str: ...
    def get_extension(self) -> str: ...
    def get_additional_extensions(self) -> str: ...
    def supports_compressed(self) -> bool: ...
    def get_allow_disk_cache(self, options: LoaderOptions) -> bool: ...
    def get_allow_ram_cache(self, options: LoaderOptions) -> bool: ...
    def supports_load(self) -> bool: ...
    def supports_save(self) -> bool: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getName = get_name
    getExtension = get_extension
    getAdditionalExtensions = get_additional_extensions
    supportsCompressed = supports_compressed
    getAllowDiskCache = get_allow_disk_cache
    getAllowRamCache = get_allow_ram_cache
    supportsLoad = supports_load
    supportsSave = supports_save
    getClassType = get_class_type

class LoaderFileTypeRegistry:
    """This class maintains the set of all known LoaderFileTypes in the universe."""
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def types(self) -> Sequence[LoaderFileType]: ...
    def __init__(self, __param0: LoaderFileTypeRegistry) -> None: ...
    def register_type(self, type: Any) -> None: ...
    def register_deferred_type(self, entry_point: Any) -> None: ...
    def unregister_type(self, type: Any) -> None: ...
    def get_num_types(self) -> int: ...
    def get_type(self, n: int) -> LoaderFileType: ...
    def get_type_from_extension(self, extension: str) -> LoaderFileType: ...
    def write(self, out: ostream, indent_level: int = ...) -> None: ...
    @staticmethod
    def get_global_ptr() -> LoaderFileTypeRegistry: ...
    def get_types(self) -> tuple[LoaderFileType, ...]: ...
    registerType = register_type
    registerDeferredType = register_deferred_type
    unregisterType = unregister_type
    getNumTypes = get_num_types
    getType = get_type
    getTypeFromExtension = get_type_from_extension
    getGlobalPtr = get_global_ptr
    getTypes = get_types

class MaterialAttrib(RenderAttrib):
    """Indicates which, if any, material should be applied to geometry.  The
    material is used primarily to control lighting effects, and isn't necessary
    (or useful) in the absence of lighting.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def material(self) -> Material: ...
    @property
    def class_slot(self) -> int: ...
    @staticmethod
    def make(material: Material) -> RenderAttrib: ...
    @staticmethod
    def make_off() -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def is_off(self) -> bool: ...
    def get_material(self) -> Material: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeOff = make_off
    makeDefault = make_default
    isOff = is_off
    getMaterial = get_material
    getClassSlot = get_class_slot
    getClassType = get_class_type

class ModelFlattenRequest(AsyncTask):
    """This class object manages a single asynchronous request to flatten a model.
    The model will be duplicated and flattened in a sub-thread (if threading is
    available), without affecting the original model; and when the result is
    done it may be retrieved from this object.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def orig(self) -> PandaNode: ...
    @overload
    def __init__(self, __param0: ModelFlattenRequest) -> None: ...
    @overload
    def __init__(self, orig: PandaNode) -> None: ...
    def get_orig(self) -> PandaNode: ...
    def is_ready(self) -> bool: ...
    def get_model(self) -> PandaNode: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getOrig = get_orig
    isReady = is_ready
    getModel = get_model
    getClassType = get_class_type

class ModelLoadRequest(AsyncTask):
    """A class object that manages a single asynchronous model load request.
    Create a new ModelLoadRequest, and add it to the loader via load_async(),
    to begin an asynchronous load.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def filename(self) -> Filename: ...
    @property
    def options(self) -> LoaderOptions: ...
    @property
    def loader(self) -> Loader: ...
    @overload
    def __init__(self, __param0: ModelLoadRequest) -> None: ...
    @overload
    def __init__(self, name: str, filename: _Filename, options: LoaderOptions, loader: Loader) -> None: ...
    def get_filename(self) -> Filename: ...
    def get_options(self) -> LoaderOptions: ...
    def get_loader(self) -> Loader: ...
    def is_ready(self) -> bool: ...
    def get_model(self) -> PandaNode: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getFilename = get_filename
    getOptions = get_options
    getLoader = get_loader
    isReady = is_ready
    getModel = get_model
    getClassType = get_class_type

class ModelNode(PandaNode):
    """This node is placed at key points within the scene graph to indicate the
    roots of "models": subtrees that are conceptually to be treated as a single
    unit, like a car or a room, for instance.  It doesn't affect rendering or
    any other operations; it's primarily useful as a high-level model
    indication.
    
    ModelNodes are created in response to a <Model> { 1 } flag within an egg
    file.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    PT_none: ClassVar[Literal[0]]
    PT_local: ClassVar[Literal[1]]
    PT_net: ClassVar[Literal[2]]
    PT_drop_node: ClassVar[Literal[3]]
    PT_no_touch: ClassVar[Literal[4]]
    def __init__(self, name: str) -> None: ...
    def set_preserve_transform(self, preserve_transform: _ModelNode_PreserveTransform) -> None: ...
    def get_preserve_transform(self) -> _ModelNode_PreserveTransform: ...
    def set_preserve_attributes(self, attrib_mask: int) -> None: ...
    def get_preserve_attributes(self) -> int: ...
    def set_transform_limit(self, limit: float) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    setPreserveTransform = set_preserve_transform
    getPreserveTransform = get_preserve_transform
    setPreserveAttributes = set_preserve_attributes
    getPreserveAttributes = get_preserve_attributes
    setTransformLimit = set_transform_limit
    getClassType = get_class_type
    PTNone = PT_none
    PTLocal = PT_local
    PTNet = PT_net
    PTDropNode = PT_drop_node
    PTNoTouch = PT_no_touch

class ModelRoot(ModelNode):
    """A node of this type is created automatically at the root of each model file
    that is loaded.  It may eventually contain some information about the
    contents of the model; at the moment, it contains no special information,
    but can be used as a flag to indicate the presence of a loaded model file.
    """
    class ModelReference(ReferenceCount):
        """This class is used to unify references to the same model."""
        DtoolClassDict: ClassVar[dict[str, Any]]
        @overload
        def __init__(self) -> None: ...
        @overload
        def __init__(self, __param0: ModelRoot.ModelReference) -> None: ...
    DtoolClassDict: ClassVar[dict[str, Any]]
    fullpath: Filename
    timestamp: int
    reference: ModelRoot.ModelReference
    @property
    def model_ref_count(self) -> int: ...
    @overload
    def __init__(self, name: str) -> None: ...
    @overload
    def __init__(self, fullpath: _Filename, timestamp: int) -> None: ...
    def get_model_ref_count(self) -> int: ...
    def get_fullpath(self) -> Filename: ...
    def set_fullpath(self, fullpath: _Filename) -> None: ...
    def get_timestamp(self) -> int: ...
    def set_timestamp(self, timestamp: int) -> None: ...
    def get_reference(self) -> ModelRoot.ModelReference: ...
    def set_reference(self, ref: ModelRoot.ModelReference) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getModelRefCount = get_model_ref_count
    getFullpath = get_fullpath
    setFullpath = set_fullpath
    getTimestamp = get_timestamp
    setTimestamp = set_timestamp
    getReference = get_reference
    setReference = set_reference
    getClassType = get_class_type

class ModelPool:
    """This class unifies all references to the same filename, so that multiple
    attempts to load the same model will return the same pointer.  Note that
    the default behavior is thus to make instances: use with caution.  Use the
    copy_subgraph() method on Node (or use NodePath::copy_to) to make
    modifiable copies of the node.
    
    Unlike TexturePool, this class does not automatically resolve the model
    filenames before loading, so a relative path and an absolute path to the
    same model will appear to be different filenames.
    
    However, see the Loader class, which is now the preferred interface for
    loading models.  The Loader class can resolve filenames, supports threaded
    loading, and can automatically consult the ModelPool, according to the
    supplied LoaderOptions.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @staticmethod
    def has_model(filename: _Filename) -> bool: ...
    @staticmethod
    def verify_model(filename: _Filename) -> bool: ...
    @staticmethod
    def get_model(filename: _Filename, verify: bool) -> ModelRoot: ...
    @staticmethod
    def load_model(filename: _Filename, options: LoaderOptions = ...) -> ModelRoot: ...
    @overload
    @staticmethod
    def add_model(model: ModelRoot) -> None: ...
    @overload
    @staticmethod
    def add_model(filename: _Filename, model: ModelRoot) -> None: ...
    @overload
    @staticmethod
    def release_model(filename: _Filename) -> None: ...
    @overload
    @staticmethod
    def release_model(model: ModelRoot) -> None: ...
    @staticmethod
    def release_all_models() -> None: ...
    @staticmethod
    def garbage_collect() -> int: ...
    @overload
    @staticmethod
    def list_contents() -> None: ...
    @overload
    @staticmethod
    def list_contents(out: ostream) -> None: ...
    @staticmethod
    def write(out: ostream) -> None: ...
    hasModel = has_model
    verifyModel = verify_model
    getModel = get_model
    loadModel = load_model
    addModel = add_model
    releaseModel = release_model
    releaseAllModels = release_all_models
    garbageCollect = garbage_collect
    listContents = list_contents

class ModelSaveRequest(AsyncTask):
    """A class object that manages a single asynchronous model save request.
    Create a new ModelSaveRequest, and add it to the loader via save_async(),
    to begin an asynchronous save.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def filename(self) -> Filename: ...
    @property
    def options(self) -> LoaderOptions: ...
    @property
    def node(self) -> PandaNode: ...
    @property
    def loader(self) -> Loader: ...
    @overload
    def __init__(self, __param0: ModelSaveRequest) -> None: ...
    @overload
    def __init__(self, name: str, filename: _Filename, options: LoaderOptions, node: PandaNode, loader: Loader) -> None: ...
    def get_filename(self) -> Filename: ...
    def get_options(self) -> LoaderOptions: ...
    def get_node(self) -> PandaNode: ...
    def get_loader(self) -> Loader: ...
    def is_ready(self) -> bool: ...
    def get_success(self) -> bool: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getFilename = get_filename
    getOptions = get_options
    getNode = get_node
    getLoader = get_loader
    isReady = is_ready
    getSuccess = get_success
    getClassType = get_class_type

class TextureAttrib(RenderAttrib):
    """Indicates the set of TextureStages and their associated Textures that
    should be applied to (or removed from) a node.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def on_stages(self) -> Sequence[TextureStage]: ...
    @property
    def textures(self) -> Mapping[Any, Texture]: ...
    @property
    def samplers(self) -> Mapping[Any, SamplerState]: ...
    @property
    def off_stages(self) -> Sequence[TextureStage]: ...
    @property
    def class_slot(self) -> int: ...
    @overload
    @staticmethod
    def make() -> RenderAttrib: ...
    @overload
    @staticmethod
    def make(tex: Texture) -> RenderAttrib: ...
    @staticmethod
    def make_off() -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def is_off(self) -> bool: ...
    def get_texture(self) -> Texture: ...
    @staticmethod
    def make_all_off() -> RenderAttrib: ...
    def get_num_on_stages(self) -> int: ...
    def get_on_stage(self, n: int) -> TextureStage: ...
    def get_num_on_ff_stages(self) -> int: ...
    def get_on_ff_stage(self, n: int) -> TextureStage: ...
    def get_ff_tc_index(self, n: int) -> int: ...
    def has_on_stage(self, stage: TextureStage) -> bool: ...
    def get_on_texture(self, stage: TextureStage) -> Texture: ...
    def get_on_sampler(self, stage: TextureStage) -> SamplerState: ...
    def get_on_stage_override(self, stage: TextureStage) -> int: ...
    def find_on_stage(self, stage: TextureStage) -> int: ...
    def get_num_off_stages(self) -> int: ...
    def get_off_stage(self, n: int) -> TextureStage: ...
    def has_off_stage(self, stage: TextureStage) -> bool: ...
    def has_all_off(self) -> bool: ...
    def is_identity(self) -> bool: ...
    @overload
    def add_on_stage(self, stage: TextureStage, tex: Texture, override: int = ...) -> RenderAttrib: ...
    @overload
    def add_on_stage(self, stage: TextureStage, tex: Texture, sampler: SamplerState, override: int = ...) -> RenderAttrib: ...
    def remove_on_stage(self, stage: TextureStage) -> RenderAttrib: ...
    def add_off_stage(self, stage: TextureStage, override: int = ...) -> RenderAttrib: ...
    def remove_off_stage(self, stage: TextureStage) -> RenderAttrib: ...
    def unify_texture_stages(self, stage: TextureStage) -> RenderAttrib: ...
    def replace_texture(self, tex: Texture, new_tex: Texture) -> RenderAttrib: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    def get_on_stages(self) -> tuple[TextureStage, ...]: ...
    def get_on_ff_stages(self) -> tuple[TextureStage, ...]: ...
    def get_off_stages(self) -> tuple[TextureStage, ...]: ...
    makeOff = make_off
    makeDefault = make_default
    isOff = is_off
    getTexture = get_texture
    makeAllOff = make_all_off
    getNumOnStages = get_num_on_stages
    getOnStage = get_on_stage
    getNumOnFfStages = get_num_on_ff_stages
    getOnFfStage = get_on_ff_stage
    getFfTcIndex = get_ff_tc_index
    hasOnStage = has_on_stage
    getOnTexture = get_on_texture
    getOnSampler = get_on_sampler
    getOnStageOverride = get_on_stage_override
    findOnStage = find_on_stage
    getNumOffStages = get_num_off_stages
    getOffStage = get_off_stage
    hasOffStage = has_off_stage
    hasAllOff = has_all_off
    isIdentity = is_identity
    addOnStage = add_on_stage
    removeOnStage = remove_on_stage
    addOffStage = add_off_stage
    removeOffStage = remove_off_stage
    unifyTextureStages = unify_texture_stages
    replaceTexture = replace_texture
    getClassSlot = get_class_slot
    getClassType = get_class_type
    getOnStages = get_on_stages
    getOnFfStages = get_on_ff_stages
    getOffStages = get_off_stages

class TexGenAttrib(RenderAttrib):
    """Computes texture coordinates for geometry automatically based on vertex
    position and/or normal.  This can be used to implement reflection and/or
    refraction maps, for instance to make shiny surfaces, as well as other
    special effects such as projective texturing.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def class_slot(self) -> int: ...
    @overload
    @staticmethod
    def make() -> RenderAttrib: ...
    @overload
    @staticmethod
    def make(stage: TextureStage, mode: _RenderAttrib_TexGenMode) -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    @overload
    def add_stage(self, stage: TextureStage, mode: _RenderAttrib_TexGenMode) -> RenderAttrib: ...
    @overload
    def add_stage(self, stage: TextureStage, mode: _RenderAttrib_TexGenMode, constant_value: _Vec3f) -> RenderAttrib: ...
    def remove_stage(self, stage: TextureStage) -> RenderAttrib: ...
    def is_empty(self) -> bool: ...
    def has_stage(self, stage: TextureStage) -> bool: ...
    def get_mode(self, stage: TextureStage) -> _RenderAttrib_TexGenMode: ...
    def has_gen_texcoord_stage(self, stage: TextureStage) -> bool: ...
    def get_constant_value(self, stage: TextureStage) -> LPoint3f: ...
    def get_geom_rendering(self, geom_rendering: int) -> int: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeDefault = make_default
    addStage = add_stage
    removeStage = remove_stage
    isEmpty = is_empty
    hasStage = has_stage
    getMode = get_mode
    hasGenTexcoordStage = has_gen_texcoord_stage
    getConstantValue = get_constant_value
    getGeomRendering = get_geom_rendering
    getClassSlot = get_class_slot
    getClassType = get_class_type

class OccluderNode(PandaNode):
    """A node in the scene graph that can hold an occluder polygon, which must be
    a rectangle.  When the occluder is activated with something like
    render.set_occluder(), then objects whose bouding volume lies entirely
    behind the occluder will not be rendered.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    double_sided: bool
    min_coverage: float
    vertices: Sequence[LPoint3f]
    def __init__(self, name: str) -> None: ...
    def set_double_sided(self, value: bool) -> None: ...
    def is_double_sided(self) -> bool: ...
    def set_min_coverage(self, value: float) -> None: ...
    def get_min_coverage(self) -> float: ...
    def set_vertices(self, v0: _Vec3f, v1: _Vec3f, v2: _Vec3f, v3: _Vec3f) -> None: ...
    def get_num_vertices(self) -> int: ...
    def get_vertex(self, n: int) -> LPoint3f: ...
    def set_vertex(self, n: int, v: _Vec3f) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    def get_vertices(self) -> tuple[LPoint3f, ...]: ...
    setDoubleSided = set_double_sided
    isDoubleSided = is_double_sided
    setMinCoverage = set_min_coverage
    getMinCoverage = get_min_coverage
    setVertices = set_vertices
    getNumVertices = get_num_vertices
    getVertex = get_vertex
    setVertex = set_vertex
    getClassType = get_class_type
    getVertices = get_vertices

class OccluderEffect(RenderEffect):
    """This functions similarly to a LightAttrib or ClipPlaneAttrib.  It indicates
    the set of occluders that modify the geometry at this level and below.
    Unlike a ClipPlaneAttrib, an OccluderEffect takes effect immediately when
    it is encountered during traversal, and thus can only add occluders; it may
    not remove them.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @staticmethod
    def make() -> RenderEffect: ...
    def get_num_on_occluders(self) -> int: ...
    def get_on_occluder(self, n: int) -> NodePath: ...
    def has_on_occluder(self, occluder: NodePath) -> bool: ...
    def is_identity(self) -> bool: ...
    def add_on_occluder(self, occluder: NodePath) -> RenderEffect: ...
    def remove_on_occluder(self, occluder: NodePath) -> RenderEffect: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    def get_on_occluders(self) -> tuple[NodePath, ...]: ...
    getNumOnOccluders = get_num_on_occluders
    getOnOccluder = get_on_occluder
    hasOnOccluder = has_on_occluder
    isIdentity = is_identity
    addOnOccluder = add_on_occluder
    removeOnOccluder = remove_on_occluder
    getClassType = get_class_type
    getOnOccluders = get_on_occluders

class PolylightNode(PandaNode):
    """A PolylightNode"""
    DtoolClassDict: ClassVar[dict[str, Any]]
    FRANDOM: ClassVar[Literal[0]]
    FSIN: ClassVar[Literal[1]]
    FCUSTOM: ClassVar[Literal[2]]
    ALINEAR: ClassVar[Literal[0]]
    AQUADRATIC: ClassVar[Literal[1]]
    @overload
    def __init__(self, __param0: PolylightNode) -> None: ...
    @overload
    def __init__(self, name: str) -> None: ...
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...
    def __lt__(self, other: PolylightNode) -> bool: ...
    def __le__(self, other: PolylightNode) -> bool: ...
    def enable(self) -> None: ...
    def disable(self) -> None: ...
    @overload
    def set_pos(self, position: _Vec3f) -> None: ...
    @overload
    def set_pos(self, x: float, y: float, z: float) -> None: ...
    def get_pos(self) -> LPoint3f: ...
    @overload
    def set_color(self, color: _Vec4f) -> None: ...
    @overload
    def set_color(self, r: float, g: float, b: float) -> None: ...
    def get_color(self) -> LVecBase4f: ...
    def get_color_scenegraph(self) -> LVecBase4f: ...
    def set_radius(self, r: float) -> None: ...
    def get_radius(self) -> float: ...
    def set_attenuation(self, type: _PolylightNode_Attenuation_Type) -> bool: ...
    def get_attenuation(self) -> _PolylightNode_Attenuation_Type: ...
    def set_a0(self, a0: float) -> None: ...
    def set_a1(self, a1: float) -> None: ...
    def set_a2(self, a2: float) -> None: ...
    def get_a0(self) -> float: ...
    def get_a1(self) -> float: ...
    def get_a2(self) -> float: ...
    def flicker_on(self) -> None: ...
    def flicker_off(self) -> None: ...
    def is_flickering(self) -> bool: ...
    def set_flicker_type(self, type: _PolylightNode_Flicker_Type) -> bool: ...
    def get_flicker_type(self) -> _PolylightNode_Flicker_Type: ...
    def set_offset(self, offset: float) -> None: ...
    def get_offset(self) -> float: ...
    def set_scale(self, scale: float) -> None: ...
    def get_scale(self) -> float: ...
    def set_step_size(self, step: float) -> None: ...
    def get_step_size(self) -> float: ...
    def set_freq(self, f: float) -> None: ...
    def get_freq(self) -> float: ...
    def compare_to(self, other: PolylightNode) -> int: ...
    def is_enabled(self) -> bool: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    setPos = set_pos
    getPos = get_pos
    setColor = set_color
    getColor = get_color
    getColorScenegraph = get_color_scenegraph
    setRadius = set_radius
    getRadius = get_radius
    setAttenuation = set_attenuation
    getAttenuation = get_attenuation
    setA0 = set_a0
    setA1 = set_a1
    setA2 = set_a2
    getA0 = get_a0
    getA1 = get_a1
    getA2 = get_a2
    flickerOn = flicker_on
    flickerOff = flicker_off
    isFlickering = is_flickering
    setFlickerType = set_flicker_type
    getFlickerType = get_flicker_type
    setOffset = set_offset
    getOffset = get_offset
    setScale = set_scale
    getScale = get_scale
    setStepSize = set_step_size
    getStepSize = get_step_size
    setFreq = set_freq
    getFreq = get_freq
    compareTo = compare_to
    isEnabled = is_enabled
    getClassType = get_class_type

class PolylightEffect(RenderEffect):
    """A PolylightEffect can be used on a node to define a LightGroup  for that
    node.  A LightGroup contains PolylightNodes which are essentially nodes
    that add color to the polygons of a model based on distance.  PolylightNode
    is a cheap way to get lighting effects specially for night scenes
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    CT_proximal: ClassVar[Literal[0]]
    CT_all: ClassVar[Literal[1]]
    @overload
    @staticmethod
    def make() -> RenderEffect: ...
    @overload
    @staticmethod
    def make(weight: float, contrib: _PolylightEffect_ContribType, effect_center: _Vec3f) -> RenderEffect: ...
    def add_light(self, newlight: NodePath) -> RenderEffect: ...
    def remove_light(self, newlight: NodePath) -> RenderEffect: ...
    def set_weight(self, w: float) -> RenderEffect: ...
    def set_contrib(self, c: _PolylightEffect_ContribType) -> RenderEffect: ...
    def set_effect_center(self, ec: _Vec3f) -> RenderEffect: ...
    def get_weight(self) -> float: ...
    def get_contrib(self) -> _PolylightEffect_ContribType: ...
    def get_effect_center(self) -> LPoint3f: ...
    def has_light(self, light: NodePath) -> bool: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    addLight = add_light
    removeLight = remove_light
    setWeight = set_weight
    setContrib = set_contrib
    setEffectCenter = set_effect_center
    getWeight = get_weight
    getContrib = get_contrib
    getEffectCenter = get_effect_center
    hasLight = has_light
    getClassType = get_class_type
    CTProximal = CT_proximal
    CTAll = CT_all

class ShaderAttrib(RenderAttrib):
    DtoolClassDict: ClassVar[dict[str, Any]]
    F_disable_alpha_write: ClassVar[Literal[0]]
    F_subsume_alpha_test: ClassVar[Literal[1]]
    F_hardware_skinning: ClassVar[Literal[2]]
    F_shader_point_size: ClassVar[Literal[3]]
    @property
    def shader(self) -> Shader: ...
    @property
    def instance_count(self) -> int: ...
    @property
    def class_slot(self) -> int: ...
    @staticmethod
    def make(shader: Shader = ..., priority: int = ...) -> RenderAttrib: ...
    @staticmethod
    def make_off() -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def has_shader(self) -> bool: ...
    def auto_shader(self) -> bool: ...
    def get_shader_priority(self) -> int: ...
    def get_instance_count(self) -> int: ...
    def auto_normal_on(self) -> bool: ...
    def auto_glow_on(self) -> bool: ...
    def auto_gloss_on(self) -> bool: ...
    def auto_ramp_on(self) -> bool: ...
    def auto_shadow_on(self) -> bool: ...
    def set_shader(self, s: Shader, priority: int = ...) -> RenderAttrib: ...
    def set_shader_off(self, priority: int = ...) -> RenderAttrib: ...
    @overload
    def set_shader_auto(self, priority: int = ...) -> RenderAttrib: ...
    @overload
    def set_shader_auto(self, shader_switch: BitMask_uint32_t_32, priority: int = ...) -> RenderAttrib: ...
    def clear_shader(self) -> RenderAttrib: ...
    @overload
    def set_shader_input(self, input: ShaderInput) -> RenderAttrib: ...
    @overload
    def set_shader_input(self, __param0: InternalName, __param1: Any, priority: int = ...) -> RenderAttrib: ...
    def set_shader_inputs(self, args: Any, kwargs: Any) -> RenderAttrib: ...
    def set_instance_count(self, instance_count: int) -> RenderAttrib: ...
    def set_flag(self, flag: int, value: bool) -> RenderAttrib: ...
    def clear_flag(self, flag: int) -> RenderAttrib: ...
    def clear_shader_input(self, id: InternalName | str) -> RenderAttrib: ...
    def clear_all_shader_inputs(self) -> RenderAttrib: ...
    def get_flag(self, flag: int) -> bool: ...
    def has_shader_input(self, id: InternalName) -> bool: ...
    def get_shader(self) -> Shader: ...
    def get_shader_input(self, id: InternalName | str) -> ShaderInput: ...
    def get_shader_input_nodepath(self, id: InternalName) -> NodePath: ...
    def get_shader_input_vector(self, id: InternalName) -> LVecBase4f: ...
    def get_shader_input_texture(self, id: InternalName, sampler: SamplerState = ...) -> Texture: ...
    def get_shader_input_matrix(self, id: InternalName, matrix: _Mat4f) -> LMatrix4f: ...
    def get_shader_input_buffer(self, id: InternalName) -> ShaderBuffer: ...
    @staticmethod
    def register_with_read_factory() -> None: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeOff = make_off
    makeDefault = make_default
    hasShader = has_shader
    autoShader = auto_shader
    getShaderPriority = get_shader_priority
    getInstanceCount = get_instance_count
    autoNormalOn = auto_normal_on
    autoGlowOn = auto_glow_on
    autoGlossOn = auto_gloss_on
    autoRampOn = auto_ramp_on
    autoShadowOn = auto_shadow_on
    setShader = set_shader
    setShaderOff = set_shader_off
    setShaderAuto = set_shader_auto
    clearShader = clear_shader
    setShaderInput = set_shader_input
    setShaderInputs = set_shader_inputs
    setInstanceCount = set_instance_count
    setFlag = set_flag
    clearFlag = clear_flag
    clearShaderInput = clear_shader_input
    clearAllShaderInputs = clear_all_shader_inputs
    getFlag = get_flag
    hasShaderInput = has_shader_input
    getShader = get_shader
    getShaderInput = get_shader_input
    getShaderInputNodepath = get_shader_input_nodepath
    getShaderInputVector = get_shader_input_vector
    getShaderInputTexture = get_shader_input_texture
    getShaderInputMatrix = get_shader_input_matrix
    getShaderInputBuffer = get_shader_input_buffer
    registerWithReadFactory = register_with_read_factory
    getClassSlot = get_class_slot
    getClassType = get_class_type

class ShowBoundsEffect(RenderEffect):
    """Applied to a GeomNode to cause a visible bounding volume to be drawn for
    this node.  This is generally used only during development to help identify
    bounding volume issues.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @staticmethod
    def make(tight: bool = ...) -> RenderEffect: ...
    def get_tight(self) -> bool: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getTight = get_tight
    getClassType = get_class_type

class TexProjectorEffect(RenderEffect):
    """This effect automatically applies a computed texture matrix to the
    specified texture stage, according to the relative position of two
    specified nodes.
    
    The relative transform from the "from" node to the "to" node is applied
    directly to the texture matrix each frame.  If the "to" node happens to be
    a LensNode, its lens projection matrix is applied as well.
    
    This can be used to apply a number of special effects.  Fundamentally, it
    may simply be used to provide a separate PandaNode that may be adjusted
    (e.g.  via a LerpInterval) in order to easily apply a linear transformation
    to an object's texture coordinates (rather than having to explicitly call
    NodePath.set_tex_transform() each frame).
    
    In a more sophisticated case, the TexProjectorEffect is particularly useful
    in conjunction with a TexGenAttrib that specifies a mode of
    M_world_position (which copies the world position of each vertex to the
    texture coordinates).  Then the TexProjector can be used to convert these
    world coordinates to the relative coordinates of a particular node, causing
    (for instance) a texture to appear to follow a node around as it moves
    through the world.  With a LensNode, you can project a texture onto the
    walls, for instance to apply a flashlight effect or an image-based shadow.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @staticmethod
    def make() -> RenderEffect: ...
    def add_stage(self, stage: TextureStage, _from: NodePath, to: NodePath, lens_index: int = ...) -> RenderEffect: ...
    def remove_stage(self, stage: TextureStage) -> RenderEffect: ...
    def is_empty(self) -> bool: ...
    def has_stage(self, stage: TextureStage) -> bool: ...
    def get_from(self, stage: TextureStage) -> NodePath: ...
    def get_to(self, stage: TextureStage) -> NodePath: ...
    def get_lens_index(self, stage: TextureStage) -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    addStage = add_stage
    removeStage = remove_stage
    isEmpty = is_empty
    hasStage = has_stage
    getFrom = get_from
    getTo = get_to
    getLensIndex = get_lens_index
    getClassType = get_class_type

class ScissorEffect(RenderEffect):
    """This provides a higher-level wrapper around ScissorAttrib.  It allows for
    the scissor region to be defined via points relative to the current node,
    and also performs culling based on the scissor region.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @staticmethod
    def make_screen(frame: _Vec4f, clip: bool = ...) -> RenderEffect: ...
    @overload
    @staticmethod
    def make_node(clip: bool = ...) -> RenderEffect: ...
    @overload
    @staticmethod
    def make_node(a: _Vec3f, b: _Vec3f, node: NodePath = ...) -> RenderEffect: ...
    @overload
    @staticmethod
    def make_node(a: _Vec3f, b: _Vec3f, c: _Vec3f, d: _Vec3f, node: NodePath = ...) -> RenderEffect: ...
    def add_point(self, point: _Vec3f, node: NodePath = ...) -> RenderEffect: ...
    def is_screen(self) -> bool: ...
    def get_frame(self) -> LVecBase4f: ...
    def get_num_points(self) -> int: ...
    def get_point(self, n: int) -> LPoint3f: ...
    def get_node(self, n: int) -> NodePath: ...
    def get_clip(self) -> bool: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    def get_points(self) -> tuple[LPoint3f, ...]: ...
    def get_nodes(self) -> tuple[NodePath, ...]: ...
    makeScreen = make_screen
    makeNode = make_node
    addPoint = add_point
    isScreen = is_screen
    getFrame = get_frame
    getNumPoints = get_num_points
    getPoint = get_point
    getNode = get_node
    getClip = get_clip
    getClassType = get_class_type
    getPoints = get_points
    getNodes = get_nodes

class SceneGraphReducer:
    """An interface for simplifying ("flattening") scene graphs by eliminating
    unneeded nodes and collapsing out unneeded state changes and transforms.
    
    This class is designed so that it may be inherited from and specialized, if
    needed, to fine-tune the flattening behavior, but normally the default
    behavior is sufficient.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    TT_transform: ClassVar[Literal[1]]
    TT_color: ClassVar[Literal[2]]
    TT_color_scale: ClassVar[Literal[4]]
    TT_tex_matrix: ClassVar[Literal[8]]
    TT_clip_plane: ClassVar[Literal[16]]
    TT_cull_face: ClassVar[Literal[32]]
    TT_apply_texture_color: ClassVar[Literal[64]]
    TT_other: ClassVar[Literal[128]]
    CS_geom_node: ClassVar[Literal[1]]
    CS_within_radius: ClassVar[Literal[2]]
    CS_other: ClassVar[Literal[4]]
    CS_recurse: ClassVar[Literal[8]]
    CVD_name: ClassVar[Literal[1]]
    CVD_model: ClassVar[Literal[2]]
    CVD_transform: ClassVar[Literal[4]]
    CVD_avoid_dynamic: ClassVar[Literal[8]]
    CVD_one_node_only: ClassVar[Literal[16]]
    CVD_format: ClassVar[Literal[32]]
    CVD_usage_hint: ClassVar[Literal[64]]
    CVD_animation_type: ClassVar[Literal[128]]
    MN_composite_only: ClassVar[Literal[1]]
    MN_avoid_animated: ClassVar[Literal[2]]
    MN_avoid_dynamic: ClassVar[Literal[4]]
    @overload
    def __init__(self, gsg: GraphicsStateGuardianBase = ...) -> None: ...
    @overload
    def __init__(self, __param0: SceneGraphReducer) -> None: ...
    def set_gsg(self, gsg: GraphicsStateGuardianBase) -> None: ...
    def clear_gsg(self) -> None: ...
    def get_gsg(self) -> GraphicsStateGuardianBase: ...
    def set_combine_radius(self, combine_radius: float) -> None: ...
    def get_combine_radius(self) -> float: ...
    def apply_attribs(self, node: PandaNode, attrib_types: int = ...) -> None: ...
    def flatten(self, root: PandaNode, combine_siblings_bits: int) -> int: ...
    def remove_column(self, root: PandaNode, column: InternalName) -> int: ...
    def make_compatible_state(self, root: PandaNode) -> int: ...
    def make_compatible_format(self, root: PandaNode, collect_bits: int = ...) -> int: ...
    def decompose(self, root: PandaNode) -> None: ...
    def collect_vertex_data(self, root: PandaNode, collect_bits: int = ...) -> int: ...
    def make_nonindexed(self, root: PandaNode, nonindexed_bits: int = ...) -> int: ...
    def unify(self, root: PandaNode, preserve_order: bool) -> None: ...
    def remove_unused_vertices(self, root: PandaNode) -> None: ...
    def premunge(self, root: PandaNode, initial_state: RenderState) -> None: ...
    def check_live_flatten(self, node: PandaNode) -> bool: ...
    setGsg = set_gsg
    clearGsg = clear_gsg
    getGsg = get_gsg
    setCombineRadius = set_combine_radius
    getCombineRadius = get_combine_radius
    applyAttribs = apply_attribs
    removeColumn = remove_column
    makeCompatibleState = make_compatible_state
    makeCompatibleFormat = make_compatible_format
    collectVertexData = collect_vertex_data
    makeNonindexed = make_nonindexed
    removeUnusedVertices = remove_unused_vertices
    checkLiveFlatten = check_live_flatten
    TTTransform = TT_transform
    TTColor = TT_color
    TTColorScale = TT_color_scale
    TTTexMatrix = TT_tex_matrix
    TTClipPlane = TT_clip_plane
    TTCullFace = TT_cull_face
    TTApplyTextureColor = TT_apply_texture_color
    TTOther = TT_other
    CSGeomNode = CS_geom_node
    CSWithinRadius = CS_within_radius
    CSOther = CS_other
    CSRecurse = CS_recurse
    CVDName = CVD_name
    CVDModel = CVD_model
    CVDTransform = CVD_transform
    CVDAvoidDynamic = CVD_avoid_dynamic
    CVDOneNodeOnly = CVD_one_node_only
    CVDFormat = CVD_format
    CVDUsageHint = CVD_usage_hint
    CVDAnimationType = CVD_animation_type
    MNCompositeOnly = MN_composite_only
    MNAvoidAnimated = MN_avoid_animated
    MNAvoidDynamic = MN_avoid_dynamic

class ParamNodePath(ParamValueBase):
    """A class object for storing a NodePath as a parameter."""
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, node_path: NodePath) -> None: ...
    def get_value(self) -> NodePath: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getValue = get_value
    getClassType = get_class_type

class PortalNode(PandaNode):
    """A node in the scene graph that can hold a Portal Polygon, which is a
    rectangle.  Other types of polygons are not supported for now.  It also
    holds a PT(PandaNode) Cell that this portal is connected to
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    into_portal_mask: BitMask_uint32_t_32
    from_portal_mask: BitMask_uint32_t_32
    portal_geom: bool
    cell_in: NodePath
    cell_out: NodePath
    clip_plane: bool
    visible: bool
    max_depth: int
    open: bool
    @property
    def vertices(self) -> Sequence[LPoint3f]: ...
    @overload
    def __init__(self, name: str) -> None: ...
    @overload
    def __init__(self, name: str, pos: _Vec3f, scale: float = ...) -> None: ...
    def set_portal_mask(self, mask: BitMask_uint32_t_32) -> None: ...
    def set_from_portal_mask(self, mask: BitMask_uint32_t_32) -> None: ...
    def set_into_portal_mask(self, mask: BitMask_uint32_t_32) -> None: ...
    def get_from_portal_mask(self) -> BitMask_uint32_t_32: ...
    def get_into_portal_mask(self) -> BitMask_uint32_t_32: ...
    def set_portal_geom(self, flag: bool) -> None: ...
    def get_portal_geom(self) -> bool: ...
    def clear_vertices(self) -> None: ...
    def add_vertex(self, vertex: _Vec3f) -> None: ...
    def get_num_vertices(self) -> int: ...
    def get_vertex(self, n: int) -> LPoint3f: ...
    def set_cell_in(self, cell: NodePath) -> None: ...
    def get_cell_in(self) -> NodePath: ...
    def set_cell_out(self, cell: NodePath) -> None: ...
    def get_cell_out(self) -> NodePath: ...
    def set_clip_plane(self, value: bool) -> None: ...
    def is_clip_plane(self) -> bool: ...
    def set_visible(self, value: bool) -> None: ...
    def is_visible(self) -> bool: ...
    def set_max_depth(self, value: int) -> None: ...
    def get_max_depth(self) -> int: ...
    def set_open(self, value: bool) -> None: ...
    def is_open(self) -> bool: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    def get_vertices(self) -> tuple[LPoint3f, ...]: ...
    setPortalMask = set_portal_mask
    setFromPortalMask = set_from_portal_mask
    setIntoPortalMask = set_into_portal_mask
    getFromPortalMask = get_from_portal_mask
    getIntoPortalMask = get_into_portal_mask
    setPortalGeom = set_portal_geom
    getPortalGeom = get_portal_geom
    clearVertices = clear_vertices
    addVertex = add_vertex
    getNumVertices = get_num_vertices
    getVertex = get_vertex
    setCellIn = set_cell_in
    getCellIn = get_cell_in
    setCellOut = set_cell_out
    getCellOut = get_cell_out
    setClipPlane = set_clip_plane
    isClipPlane = is_clip_plane
    setVisible = set_visible
    isVisible = is_visible
    setMaxDepth = set_max_depth
    getMaxDepth = get_max_depth
    setOpen = set_open
    isOpen = is_open
    getClassType = get_class_type
    getVertices = get_vertices

class ScissorAttrib(RenderAttrib):
    """This restricts rendering to within a rectangular region of the scene,
    without otherwise affecting the viewport or lens properties.  Geometry that
    falls outside the scissor region is not rendered.  It is akin to the OpenGL
    glScissor() function.
    
    The ScissorAttrib always specifies its region relative to its enclosing
    DisplayRegion, in screen space, and performs no culling.
    
    See ScissorEffect if you wish to define a region relative to 2-D or 3-D
    coordinates in the scene graph, with culling.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def frame(self) -> LVecBase4f: ...
    @property
    def class_slot(self) -> int: ...
    @staticmethod
    def make_off() -> RenderAttrib: ...
    @overload
    @staticmethod
    def make(frame: _Vec4f) -> RenderAttrib: ...
    @overload
    @staticmethod
    def make(left: float, right: float, bottom: float, top: float) -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def is_off(self) -> bool: ...
    def get_frame(self) -> LVecBase4f: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeOff = make_off
    makeDefault = make_default
    isOff = is_off
    getFrame = get_frame
    getClassSlot = get_class_slot
    getClassType = get_class_type

class ShadeModelAttrib(RenderAttrib):
    """Specifies whether flat shading (per-polygon) or smooth shading (per-vertex)
    is in effect.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    M_flat: ClassVar[Literal[0]]
    M_smooth: ClassVar[Literal[1]]
    @property
    def mode(self) -> _ShadeModelAttrib_Mode: ...
    @property
    def class_slot(self) -> int: ...
    @staticmethod
    def make(mode: _ShadeModelAttrib_Mode) -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    def get_mode(self) -> _ShadeModelAttrib_Mode: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeDefault = make_default
    getMode = get_mode
    getClassSlot = get_class_slot
    getClassType = get_class_type
    MFlat = M_flat
    MSmooth = M_smooth

class StencilAttrib(RenderAttrib):
    """A StencilAttrib is a collection of all stencil render states.  The render
    states in a StencilAttrib are read-only.  A StencilAttrib is created with
    make or make_2_sided.  To determine if two sided stencil is supported, call
    the function GraphicsStateGuardian:: get_supports_two_sided_stencil.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    SRS_front_comparison_function: ClassVar[Literal[0]]
    SRS_front_stencil_fail_operation: ClassVar[Literal[1]]
    SRS_front_stencil_pass_z_fail_operation: ClassVar[Literal[2]]
    SRS_front_stencil_pass_z_pass_operation: ClassVar[Literal[3]]
    SRS_reference: ClassVar[Literal[4]]
    SRS_read_mask: ClassVar[Literal[5]]
    SRS_write_mask: ClassVar[Literal[6]]
    SRS_back_comparison_function: ClassVar[Literal[7]]
    SRS_back_stencil_fail_operation: ClassVar[Literal[8]]
    SRS_back_stencil_pass_z_fail_operation: ClassVar[Literal[9]]
    SRS_back_stencil_pass_z_pass_operation: ClassVar[Literal[10]]
    SRS_clear: ClassVar[Literal[11]]
    SRS_clear_value: ClassVar[Literal[12]]
    SRS_total: ClassVar[Literal[13]]
    SCF_never: ClassVar[Literal[1]]
    SCF_less_than: ClassVar[Literal[2]]
    SCF_equal: ClassVar[Literal[3]]
    SCF_less_than_or_equal: ClassVar[Literal[4]]
    SCF_greater_than: ClassVar[Literal[5]]
    SCF_not_equal: ClassVar[Literal[6]]
    SCF_greater_than_or_equal: ClassVar[Literal[7]]
    SCF_always: ClassVar[Literal[8]]
    SO_keep: ClassVar[Literal[0]]
    SO_zero: ClassVar[Literal[1]]
    SO_replace: ClassVar[Literal[2]]
    SO_increment: ClassVar[Literal[3]]
    SO_decrement: ClassVar[Literal[4]]
    SO_invert: ClassVar[Literal[5]]
    SO_increment_saturate: ClassVar[Literal[6]]
    SO_decrement_saturate: ClassVar[Literal[7]]
    @property
    def class_slot(self) -> int: ...
    @staticmethod
    def make_off() -> RenderAttrib: ...
    @staticmethod
    def make_default() -> RenderAttrib: ...
    @staticmethod
    def make(front_enable: bool, front_comparison_function: _RenderAttrib_PandaCompareFunc, stencil_fail_operation: _StencilAttrib_StencilOperation, stencil_pass_z_fail_operation: _StencilAttrib_StencilOperation, front_stencil_pass_z_pass_operation: _StencilAttrib_StencilOperation, reference: int, read_mask: int, write_mask: int = ...) -> RenderAttrib: ...
    @staticmethod
    def make_2_sided(front_enable: bool, back_enable: bool, front_comparison_function: _RenderAttrib_PandaCompareFunc, stencil_fail_operation: _StencilAttrib_StencilOperation, stencil_pass_z_fail_operation: _StencilAttrib_StencilOperation, front_stencil_pass_z_pass_operation: _StencilAttrib_StencilOperation, reference: int, read_mask: int, write_mask: int, back_comparison_function: _RenderAttrib_PandaCompareFunc, back_stencil_fail_operation: _StencilAttrib_StencilOperation, back_stencil_pass_z_fail_operation: _StencilAttrib_StencilOperation, back_stencil_pass_z_pass_operation: _StencilAttrib_StencilOperation) -> RenderAttrib: ...
    @staticmethod
    def make_with_clear(front_enable: bool, front_comparison_function: _RenderAttrib_PandaCompareFunc, stencil_fail_operation: _StencilAttrib_StencilOperation, stencil_pass_z_fail_operation: _StencilAttrib_StencilOperation, front_stencil_pass_z_pass_operation: _StencilAttrib_StencilOperation, reference: int, read_mask: int, write_mask: int, clear: bool, clear_value: int) -> RenderAttrib: ...
    @staticmethod
    def make_2_sided_with_clear(front_enable: bool, back_enable: bool, front_comparison_function: _RenderAttrib_PandaCompareFunc, stencil_fail_operation: _StencilAttrib_StencilOperation, stencil_pass_z_fail_operation: _StencilAttrib_StencilOperation, front_stencil_pass_z_pass_operation: _StencilAttrib_StencilOperation, reference: int, read_mask: int, write_mask: int, back_comparison_function: _RenderAttrib_PandaCompareFunc, back_stencil_fail_operation: _StencilAttrib_StencilOperation, back_stencil_pass_z_fail_operation: _StencilAttrib_StencilOperation, back_stencil_pass_z_pass_operation: _StencilAttrib_StencilOperation, clear: bool, clear_value: int) -> RenderAttrib: ...
    def get_render_state(self, render_state_identifier: _StencilAttrib_StencilRenderState) -> int: ...
    @staticmethod
    def get_class_slot() -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    makeOff = make_off
    makeDefault = make_default
    make2Sided = make_2_sided
    makeWithClear = make_with_clear
    make2SidedWithClear = make_2_sided_with_clear
    getRenderState = get_render_state
    getClassSlot = get_class_slot
    getClassType = get_class_type
    SRSFrontComparisonFunction = SRS_front_comparison_function
    SRSFrontStencilFailOperation = SRS_front_stencil_fail_operation
    SRSFrontStencilPassZFailOperation = SRS_front_stencil_pass_z_fail_operation
    SRSFrontStencilPassZPassOperation = SRS_front_stencil_pass_z_pass_operation
    SRSReference = SRS_reference
    SRSReadMask = SRS_read_mask
    SRSWriteMask = SRS_write_mask
    SRSBackComparisonFunction = SRS_back_comparison_function
    SRSBackStencilFailOperation = SRS_back_stencil_fail_operation
    SRSBackStencilPassZFailOperation = SRS_back_stencil_pass_z_fail_operation
    SRSBackStencilPassZPassOperation = SRS_back_stencil_pass_z_pass_operation
    SRSClear = SRS_clear
    SRSClearValue = SRS_clear_value
    SRSTotal = SRS_total
    SCFNever = SCF_never
    SCFLessThan = SCF_less_than
    SCFEqual = SCF_equal
    SCFLessThanOrEqual = SCF_less_than_or_equal
    SCFGreaterThan = SCF_greater_than
    SCFNotEqual = SCF_not_equal
    SCFGreaterThanOrEqual = SCF_greater_than_or_equal
    SCFAlways = SCF_always
    SOKeep = SO_keep
    SOZero = SO_zero
    SOReplace = SO_replace
    SOIncrement = SO_increment
    SODecrement = SO_decrement
    SOInvert = SO_invert
    SOIncrementSaturate = SO_increment_saturate
    SODecrementSaturate = SO_decrement_saturate

class ShaderPool:
    """This is the preferred interface for loading shaders for the TextNode
    system.  It is similar to ModelPool and TexturePool in that it unifies
    references to the same filename.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @staticmethod
    def has_shader(filename: _Filename) -> bool: ...
    @staticmethod
    def verify_shader(filename: _Filename) -> bool: ...
    @staticmethod
    def load_shader(filename: _Filename) -> Shader: ...
    @staticmethod
    def add_shader(filename: _Filename, shader: Shader) -> None: ...
    @staticmethod
    def release_shader(filename: _Filename) -> None: ...
    @staticmethod
    def release_all_shaders() -> None: ...
    @staticmethod
    def garbage_collect() -> int: ...
    @staticmethod
    def list_contents(out: ostream) -> None: ...
    @staticmethod
    def write(out: ostream) -> None: ...
    hasShader = has_shader
    verifyShader = verify_shader
    loadShader = load_shader
    addShader = add_shader
    releaseShader = release_shader
    releaseAllShaders = release_all_shaders
    garbageCollect = garbage_collect
    listContents = list_contents

def py_decode_NodePath_from_bam_stream(data: bytes) -> NodePath: ...
def py_decode_NodePath_from_bam_stream_persist(unpickler: Any, data: bytes) -> NodePath: ...
pyDecodeNodePathFromBamStream = py_decode_NodePath_from_bam_stream
pyDecodeNodePathFromBamStreamPersist = py_decode_NodePath_from_bam_stream_persist
