from collections.abc import Awaitable, Callable, Generator, Iterator, Sequence
from typing import Any, ClassVar, Literal, TypeAlias, final, overload
from panda3d.core import (
    ButtonHandle,
    ClockObject,
    GlobPattern,
    ModifierButtons,
    Namable,
    ParamValueBase,
    PointerData,
    TypeHandle,
    TypedObject,
    TypedReferenceCount,
    TypedWritableReferenceCount,
    ostream,
)

_AsyncTask_State: TypeAlias = Literal[0, 1, 2, 3, 4, 5, 6]
_ThreadPriority: TypeAlias = Literal[0, 1, 2, 3]
_ButtonEvent_Type: TypeAlias = Literal[0, 1, 2, 3, 4, 5, 6, 7, 8]

class EventParameter:
    """An optional parameter associated with an event.  Each event may have zero
    or more of these.  Each parameter stores a pointer to a
    TypedWritableReferenceCount object, which of course could be pretty much
    anything.  To store a simple value like a double or a string, the
    EventParameter constructors transparently use the ParamValue template class
    from paramValue.h.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, value: float | str) -> None: ...
    @overload
    def __init__(self, copy: EventParameter | float | int | str | None) -> None: ...
    @overload
    def __init__(self, ptr: TypedReferenceCount | TypedWritableReferenceCount) -> None: ...
    def assign(self, copy: EventParameter | float | int | str | None) -> EventParameter: ...
    def is_empty(self) -> bool: ...
    def is_int(self) -> bool: ...
    def get_int_value(self) -> int: ...
    def is_double(self) -> bool: ...
    def get_double_value(self) -> float: ...
    def is_string(self) -> bool: ...
    def get_string_value(self) -> str: ...
    def is_wstring(self) -> bool: ...
    def get_wstring_value(self) -> str: ...
    def is_typed_ref_count(self) -> bool: ...
    def get_typed_ref_count_value(self) -> TypedReferenceCount: ...
    def get_ptr(self) -> TypedWritableReferenceCount: ...
    def output(self, out: ostream) -> None: ...
    isEmpty = is_empty
    isInt = is_int
    getIntValue = get_int_value
    isDouble = is_double
    getDoubleValue = get_double_value
    isString = is_string
    getStringValue = get_string_value
    isWstring = is_wstring
    getWstringValue = get_wstring_value
    isTypedRefCount = is_typed_ref_count
    getTypedRefCountValue = get_typed_ref_count_value
    getPtr = get_ptr

class AsyncFuture(TypedReferenceCount):
    """This class represents a thread-safe handle to a promised future result of
    an asynchronous operation, providing methods to query its status and result
    as well as register callbacks for this future's completion.
    
    An AsyncFuture can be awaited from within a coroutine or task.  It keeps
    track of tasks waiting for this future and automatically reactivates them
    upon this future's completion.
    
    A task itself is also a subclass of AsyncFuture.  Other subclasses are
    not generally necessary, except to override the function of `cancel()`.
    
    Until the future is done, it is "owned" by the resolver thread, though it's
    still legal for other threads to query its state.  When the resolver thread
    resolves this future using `set_result()`, or any thread calls `cancel()`,
    it instantly enters the "done" state, after which the result becomes a
    read-only field that all threads can access.
    
    When the future returns true for done(), a thread can use cancelled() to
    determine whether the future was cancelled or get_result() to access the
    result of the operation.  Not all operations define a meaningful result
    value, so some will always return nullptr.
    
    In Python, the `cancelled()`, `wait()` and `get_result()` methods are
    wrapped up into a single `result()` method which waits for the future to
    complete before either returning the result or throwing an exception if the
    future was cancelled.
    However, it is preferable to use the `await` keyword when running from a
    coroutine, which only suspends the current task and not the entire thread.
    
    This API aims to mirror and be compatible with Python's Future class.
    
    @since 1.10.0
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    done_event: str
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, __param0: AsyncFuture) -> None: ...
    @staticmethod
    def __await__() -> Generator[Awaitable, None, None]: ...
    @staticmethod
    def __iter__() -> Generator[Awaitable, None, None]: ...
    def done(self) -> bool: ...
    def cancelled(self) -> bool: ...
    def result(self, timeout: Any = ...) -> Any: ...
    def cancel(self) -> bool: ...
    def set_done_event(self, done_event: str) -> None: ...
    def get_done_event(self) -> str: ...
    def add_done_callback(self, fn: Any) -> Any: ...
    @staticmethod
    def gather(args: Any) -> Any: ...
    def output(self, out: ostream) -> None: ...
    @overload
    def wait(self) -> None: ...
    @overload
    def wait(self, timeout: float) -> None: ...
    def set_result(self, __param0: Any) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    setDoneEvent = set_done_event
    getDoneEvent = get_done_event
    addDoneCallback = add_done_callback
    setResult = set_result
    getClassType = get_class_type

class AsyncTask(AsyncFuture, Namable):
    """This class represents a concrete task performed by an AsyncManager.
    Normally, you would subclass from this class, and override do_task(), to
    define the functionality you wish to have the task perform.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    name: str
    task_chain: str
    sort: int
    priority: int
    done_event: str
    DS_done: ClassVar[Literal[0]]
    DS_cont: ClassVar[Literal[1]]
    DS_again: ClassVar[Literal[2]]
    DS_pickup: ClassVar[Literal[3]]
    DS_exit: ClassVar[Literal[4]]
    DS_pause: ClassVar[Literal[5]]
    DS_interrupt: ClassVar[Literal[6]]
    DS_await: ClassVar[Literal[7]]
    S_inactive: ClassVar[Literal[0]]
    S_active: ClassVar[Literal[1]]
    S_servicing: ClassVar[Literal[2]]
    S_servicing_removed: ClassVar[Literal[3]]
    S_sleeping: ClassVar[Literal[4]]
    S_active_nested: ClassVar[Literal[5]]
    S_awaiting: ClassVar[Literal[6]]
    @property
    def state(self) -> _AsyncTask_State: ...
    @property
    def alive(self) -> bool: ...
    @property
    def manager(self) -> AsyncTaskManager: ...
    @property
    def id(self) -> int: ...
    @property
    def dt(self) -> float: ...
    @property
    def max_dt(self) -> float: ...
    @property
    def average_dt(self) -> float: ...
    def __init__(self, __param0: AsyncTask) -> None: ...
    def upcast_to_AsyncFuture(self) -> AsyncFuture: ...
    def upcast_to_Namable(self) -> Namable: ...
    def get_state(self) -> _AsyncTask_State: ...
    def is_alive(self) -> bool: ...
    def get_manager(self) -> AsyncTaskManager: ...
    def remove(self) -> bool: ...
    def set_delay(self, delay: float) -> None: ...
    def clear_delay(self) -> None: ...
    def has_delay(self) -> bool: ...
    def get_delay(self) -> float: ...
    def get_wake_time(self) -> float: ...
    def recalc_wake_time(self) -> None: ...
    def get_start_time(self) -> float: ...
    def get_elapsed_time(self) -> float: ...
    def get_start_frame(self) -> int: ...
    def get_elapsed_frames(self) -> int: ...
    def set_name(self, name: str) -> None: ...
    def clear_name(self) -> None: ...
    def get_name_prefix(self) -> str: ...
    def get_task_id(self) -> int: ...
    def set_task_chain(self, chain_name: str) -> None: ...
    def get_task_chain(self) -> str: ...
    def set_sort(self, sort: int) -> None: ...
    def get_sort(self) -> int: ...
    def set_priority(self, priority: int) -> None: ...
    def get_priority(self) -> int: ...
    def set_done_event(self, done_event: str) -> None: ...
    def get_dt(self) -> float: ...
    def get_max_dt(self) -> float: ...
    def get_average_dt(self) -> float: ...
    def output(self, out: ostream) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    upcastToAsyncFuture = upcast_to_AsyncFuture
    upcastToNamable = upcast_to_Namable
    getState = get_state
    isAlive = is_alive
    getManager = get_manager
    setDelay = set_delay
    clearDelay = clear_delay
    hasDelay = has_delay
    getDelay = get_delay
    getWakeTime = get_wake_time
    recalcWakeTime = recalc_wake_time
    getStartTime = get_start_time
    getElapsedTime = get_elapsed_time
    getStartFrame = get_start_frame
    getElapsedFrames = get_elapsed_frames
    setName = set_name
    clearName = clear_name
    getNamePrefix = get_name_prefix
    getTaskId = get_task_id
    setTaskChain = set_task_chain
    getTaskChain = get_task_chain
    setSort = set_sort
    getSort = get_sort
    setPriority = set_priority
    getPriority = get_priority
    setDoneEvent = set_done_event
    getDt = get_dt
    getMaxDt = get_max_dt
    getAverageDt = get_average_dt
    getClassType = get_class_type
    DSDone = DS_done
    DSCont = DS_cont
    DSAgain = DS_again
    DSPickup = DS_pickup
    DSExit = DS_exit
    DSPause = DS_pause
    DSInterrupt = DS_interrupt
    DSAwait = DS_await
    SInactive = S_inactive
    SActive = S_active
    SServicing = S_servicing
    SServicingRemoved = S_servicing_removed
    SSleeping = S_sleeping
    SActiveNested = S_active_nested
    SAwaiting = S_awaiting

class AsyncTaskManager(TypedReferenceCount, Namable):
    """A class to manage a loose queue of isolated tasks, which can be performed
    either synchronously (in the foreground thread) or asynchronously (by a
    background thread).
    
    The AsyncTaskManager is actually a collection of AsyncTaskChains, each of
    which maintains a list of tasks.  Each chain can be either foreground or
    background (it may run only in the main thread, or it may be serviced by
    one or more background threads). See AsyncTaskChain for more information.
    
    If you do not require background processing, it is perfectly acceptable to
    create only one AsyncTaskChain, which runs in the main thread.  This is a
    common configuration.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    clock: ClockObject
    @property
    def tasks(self) -> AsyncTaskCollection: ...
    @property
    def active_tasks(self) -> AsyncTaskCollection: ...
    @property
    def sleeping_tasks(self) -> AsyncTaskCollection: ...
    @property
    def next_wake_time(self) -> float: ...
    def __init__(self, name: str) -> None: ...
    def upcast_to_TypedReferenceCount(self) -> TypedReferenceCount: ...
    def upcast_to_Namable(self) -> Namable: ...
    def cleanup(self) -> None: ...
    def set_clock(self, clock: ClockObject) -> None: ...
    def get_clock(self) -> ClockObject: ...
    def get_num_task_chains(self) -> int: ...
    def get_task_chain(self, n: int) -> AsyncTaskChain: ...
    def make_task_chain(self, name: str) -> AsyncTaskChain: ...
    def find_task_chain(self, name: str) -> AsyncTaskChain: ...
    def remove_task_chain(self, name: str) -> bool: ...
    def add(self, task: AsyncTask) -> None: ...
    def has_task(self, task: AsyncTask) -> bool: ...
    def find_task(self, name: str) -> AsyncTask: ...
    def find_tasks(self, name: str) -> AsyncTaskCollection: ...
    def find_tasks_matching(self, pattern: GlobPattern) -> AsyncTaskCollection: ...
    @overload
    def remove(self, task: AsyncTask) -> bool: ...
    @overload
    def remove(self, tasks: AsyncTaskCollection) -> int: ...
    def wait_for_tasks(self) -> None: ...
    def stop_threads(self) -> None: ...
    def start_threads(self) -> None: ...
    def get_num_tasks(self) -> int: ...
    def get_tasks(self) -> AsyncTaskCollection: ...
    def get_active_tasks(self) -> AsyncTaskCollection: ...
    def get_sleeping_tasks(self) -> AsyncTaskCollection: ...
    def poll(self) -> None: ...
    def get_next_wake_time(self) -> float: ...
    def output(self, out: ostream) -> None: ...
    def write(self, out: ostream, indent_level: int = ...) -> None: ...
    @staticmethod
    def get_global_ptr() -> AsyncTaskManager: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    def get_task_chains(self) -> tuple[AsyncTaskChain, ...]: ...
    upcastToTypedReferenceCount = upcast_to_TypedReferenceCount
    upcastToNamable = upcast_to_Namable
    setClock = set_clock
    getClock = get_clock
    getNumTaskChains = get_num_task_chains
    getTaskChain = get_task_chain
    makeTaskChain = make_task_chain
    findTaskChain = find_task_chain
    removeTaskChain = remove_task_chain
    hasTask = has_task
    findTask = find_task
    findTasks = find_tasks
    findTasksMatching = find_tasks_matching
    waitForTasks = wait_for_tasks
    stopThreads = stop_threads
    startThreads = start_threads
    getNumTasks = get_num_tasks
    getTasks = get_tasks
    getActiveTasks = get_active_tasks
    getSleepingTasks = get_sleeping_tasks
    getNextWakeTime = get_next_wake_time
    getGlobalPtr = get_global_ptr
    getClassType = get_class_type
    getTaskChains = get_task_chains

class AsyncTaskCollection:
    """A list of tasks, for instance as returned by some of the AsyncTaskManager
    query functions.  This also serves to define an AsyncTaskSequence.
    
    TODO: None of this is thread-safe yet.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, copy: AsyncTaskCollection) -> None: ...
    def __getitem__(self, index: int) -> AsyncTask: ...
    def __len__(self) -> int: ...
    def __iadd__(self, other: AsyncTaskCollection) -> AsyncTaskCollection: ...
    def __add__(self, other: AsyncTaskCollection) -> AsyncTaskCollection: ...
    def __iter__(self) -> Iterator[AsyncTask]: ...
    def assign(self, copy: AsyncTaskCollection) -> AsyncTaskCollection: ...
    def add_task(self, task: AsyncTask) -> None: ...
    @overload
    def remove_task(self, task: AsyncTask) -> bool: ...
    @overload
    def remove_task(self, index: int) -> None: ...
    def add_tasks_from(self, other: AsyncTaskCollection) -> None: ...
    def remove_tasks_from(self, other: AsyncTaskCollection) -> None: ...
    def remove_duplicate_tasks(self) -> None: ...
    def has_task(self, task: AsyncTask) -> bool: ...
    def clear(self) -> None: ...
    def find_task(self, name: str) -> AsyncTask: ...
    def get_num_tasks(self) -> int: ...
    def get_task(self, index: int) -> AsyncTask: ...
    def output(self, out: ostream) -> None: ...
    def write(self, out: ostream, indent_level: int = ...) -> None: ...
    def get_tasks(self) -> tuple[AsyncTask, ...]: ...
    addTask = add_task
    removeTask = remove_task
    addTasksFrom = add_tasks_from
    removeTasksFrom = remove_tasks_from
    removeDuplicateTasks = remove_duplicate_tasks
    hasTask = has_task
    findTask = find_task
    getNumTasks = get_num_tasks
    getTask = get_task
    getTasks = get_tasks

class AsyncTaskChain(TypedReferenceCount, Namable):
    """The AsyncTaskChain is a subset of the AsyncTaskManager.  Each chain
    maintains a separate list of tasks, and will execute them with its own set
    of threads.  Each chain may thereby operate independently of the other
    chains.
    
    The AsyncTaskChain will spawn a specified number of threads (possibly 0) to
    serve the tasks.  If there are no threads, you must call poll() from time
    to time to serve the tasks in the main thread.  Normally this is done by
    calling AsyncTaskManager::poll().
    
    Each task will run exactly once each epoch.  Beyond that, the tasks' sort
    and priority values control the order in which they are run: tasks are run
    in increasing order by sort value, and within the same sort value, they are
    run roughly in decreasing order by priority value, with some exceptions for
    parallelism.  Tasks with different sort values are never run in parallel
    together, but tasks with different priority values might be (if there is
    more than one thread).
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def upcast_to_TypedReferenceCount(self) -> TypedReferenceCount: ...
    def upcast_to_Namable(self) -> Namable: ...
    def set_tick_clock(self, tick_clock: bool) -> None: ...
    def get_tick_clock(self) -> bool: ...
    def set_num_threads(self, num_threads: int) -> None: ...
    def get_num_threads(self) -> int: ...
    def get_num_running_threads(self) -> int: ...
    def set_thread_priority(self, priority: _ThreadPriority) -> None: ...
    def get_thread_priority(self) -> _ThreadPriority: ...
    def set_frame_budget(self, frame_budget: float) -> None: ...
    def get_frame_budget(self) -> float: ...
    def set_frame_sync(self, frame_sync: bool) -> None: ...
    def get_frame_sync(self) -> bool: ...
    def set_timeslice_priority(self, timeslice_priority: bool) -> None: ...
    def get_timeslice_priority(self) -> bool: ...
    def stop_threads(self) -> None: ...
    def start_threads(self) -> None: ...
    def is_started(self) -> bool: ...
    def has_task(self, task: AsyncTask) -> bool: ...
    def wait_for_tasks(self) -> None: ...
    def get_num_tasks(self) -> int: ...
    def get_tasks(self) -> AsyncTaskCollection: ...
    def get_active_tasks(self) -> AsyncTaskCollection: ...
    def get_sleeping_tasks(self) -> AsyncTaskCollection: ...
    def poll(self) -> None: ...
    def get_next_wake_time(self) -> float: ...
    def output(self, out: ostream) -> None: ...
    def write(self, out: ostream, indent_level: int = ...) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    upcastToTypedReferenceCount = upcast_to_TypedReferenceCount
    upcastToNamable = upcast_to_Namable
    setTickClock = set_tick_clock
    getTickClock = get_tick_clock
    setNumThreads = set_num_threads
    getNumThreads = get_num_threads
    getNumRunningThreads = get_num_running_threads
    setThreadPriority = set_thread_priority
    getThreadPriority = get_thread_priority
    setFrameBudget = set_frame_budget
    getFrameBudget = get_frame_budget
    setFrameSync = set_frame_sync
    getFrameSync = get_frame_sync
    setTimeslicePriority = set_timeslice_priority
    getTimeslicePriority = get_timeslice_priority
    stopThreads = stop_threads
    startThreads = start_threads
    isStarted = is_started
    hasTask = has_task
    waitForTasks = wait_for_tasks
    getNumTasks = get_num_tasks
    getTasks = get_tasks
    getActiveTasks = get_active_tasks
    getSleepingTasks = get_sleeping_tasks
    getNextWakeTime = get_next_wake_time
    getClassType = get_class_type

class AsyncTaskPause(AsyncTask):
    """A special kind of task that simple returns DS_pause, to pause for a
    specified number of seconds and then finish.  It's intended to be used
    within an AsyncTaskSequence.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self, __param0: AsyncTaskPause) -> None: ...
    @overload
    def __init__(self, delay: float) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getClassType = get_class_type

class AsyncTaskSequence(AsyncTask, AsyncTaskCollection):
    """A special kind of task that serves as a list of tasks internally.  Each
    task on the list is executed in sequence, one per epoch.
    
    This is similar to a Sequence interval, though it has some slightly
    different abilities.  For instance, although you can't start at any
    arbitrary point in the sequence, you can construct a task sequence whose
    duration changes during playback.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self, __param0: AsyncTaskSequence) -> None: ...
    @overload
    def __init__(self, name: str) -> None: ...
    def upcast_to_AsyncTask(self) -> AsyncTask: ...
    def upcast_to_AsyncTaskCollection(self) -> AsyncTaskCollection: ...
    def set_repeat_count(self, repeat_count: int) -> None: ...
    def get_repeat_count(self) -> int: ...
    def get_current_task_index(self) -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    upcastToAsyncTask = upcast_to_AsyncTask
    upcastToAsyncTaskCollection = upcast_to_AsyncTaskCollection
    setRepeatCount = set_repeat_count
    getRepeatCount = get_repeat_count
    getCurrentTaskIndex = get_current_task_index
    getClassType = get_class_type

class ButtonEvent:
    """Records a button event of some kind.  This is either a keyboard or mouse
    button (or some other kind of button) changing state from up to down, or
    vice-versa, or it is a single "keystroke".
    
    A keystroke is different than a button event in that (a) it does not
    necessarily correspond to a physical button on a keyboard, but might be the
    result of a combination of buttons (e.g.  "A" is the result of shift +
    "a"); and (b) it does not manage separate "up" and "down" events, but is
    itself an instantaneous event.
    
    Normal up/down button events can be used to track the state of a particular
    button on the keyboard, while keystroke events are best used to monitor
    what a user is attempting to type.
    
    Button up/down events are defined across all the physical keys on the
    keyboard (and other buttons for which there is a corresponding ButtonHandle
    object), while keystroke events are defined across the entire Unicode
    character set.
    
    This API should not be considered stable and may change in a future version
    of Panda3D.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    T_down: ClassVar[Literal[0]]
    T_resume_down: ClassVar[Literal[1]]
    T_up: ClassVar[Literal[2]]
    T_repeat: ClassVar[Literal[3]]
    T_keystroke: ClassVar[Literal[4]]
    T_candidate: ClassVar[Literal[5]]
    T_move: ClassVar[Literal[6]]
    T_raw_down: ClassVar[Literal[7]]
    T_raw_up: ClassVar[Literal[8]]
    @property
    def button(self) -> ButtonHandle: ...
    @property
    def keycode(self) -> int: ...
    @property
    def type(self) -> _ButtonEvent_Type: ...
    @property
    def time(self) -> float: ...
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...
    def __lt__(self, other: ButtonEvent) -> bool: ...
    def __le__(self, other: ButtonEvent) -> bool: ...
    TDown = T_down
    TResumeDown = T_resume_down
    TUp = T_up
    TRepeat = T_repeat
    TKeystroke = T_keystroke
    TCandidate = T_candidate
    TMove = T_move
    TRawDown = T_raw_down
    TRawUp = T_raw_up

class ButtonEventList(ParamValueBase):
    """Records a set of button events that happened recently.  This class is
    usually used only in the data graph, to transmit the recent button presses,
    but it may be used anywhere a list of ButtonEvents is desired.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def events(self) -> Sequence[ButtonEvent]: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, copy: ButtonEventList) -> None: ...
    def assign(self, copy: ButtonEventList) -> ButtonEventList: ...
    def add_event(self, event: ButtonEvent) -> None: ...
    def get_num_events(self) -> int: ...
    def get_event(self, n: int) -> ButtonEvent: ...
    def clear(self) -> None: ...
    def add_events(self, other: ButtonEventList) -> None: ...
    def update_mods(self, mods: ModifierButtons) -> None: ...
    def write(self, out: ostream, indent_level: int = ...) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    addEvent = add_event
    getNumEvents = get_num_events
    getEvent = get_event
    addEvents = add_events
    updateMods = update_mods
    getClassType = get_class_type

class Event(TypedReferenceCount):
    """A named event, possibly with parameters.  Anyone in any thread may throw an
    event at any time; there will be one process responsible for reading and
    dispacting on the events (but not necessarily immediately).
    
    This function use to inherit from Namable, but that makes it too expensive
    to get its name the Python code.  Now it just copies the Namable interface
    in.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    name: str
    @property
    def parameters(self) -> Sequence[EventParameter]: ...
    def __init__(self, copy: Event) -> None: ...
    def assign(self, copy: Event) -> Event: ...
    def set_name(self, name: str) -> None: ...
    def clear_name(self) -> None: ...
    def has_name(self) -> bool: ...
    def get_name(self) -> str: ...
    def add_parameter(self, obj: EventParameter | float | int | str | None) -> None: ...
    def get_num_parameters(self) -> int: ...
    def get_parameter(self, n: int) -> EventParameter: ...
    def has_receiver(self) -> bool: ...
    def clear_receiver(self) -> None: ...
    def output(self, out: ostream) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    def get_parameters(self) -> tuple[EventParameter, ...]: ...
    setName = set_name
    clearName = clear_name
    hasName = has_name
    getName = get_name
    addParameter = add_parameter
    getNumParameters = get_num_parameters
    getParameter = get_parameter
    hasReceiver = has_receiver
    clearReceiver = clear_receiver
    getClassType = get_class_type
    getParameters = get_parameters

class EventHandler(TypedObject):
    """A class to monitor events from the C++ side of things.  It maintains a set
    of "hooks", function pointers assigned to event names, and calls the
    appropriate hooks when the matching event is detected.
    
    This class is not necessary when the hooks are detected and processed
    entirely by the scripting language, e.g.  via Scheme hooks or the messenger
    in Python.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, ev_queue: EventQueue) -> None: ...
    def get_future(self, event_name: str) -> AsyncFuture: ...
    def process_events(self) -> None: ...
    def dispatch_event(self, event: Event) -> None: ...
    def write(self, out: ostream) -> None: ...
    @staticmethod
    def get_global_event_handler(queue: EventQueue = ...) -> EventHandler: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getFuture = get_future
    processEvents = process_events
    dispatchEvent = dispatch_event
    getGlobalEventHandler = get_global_event_handler
    getClassType = get_class_type

class EventQueue:
    """A queue of pending events.  As events are thrown, they are added to this
    queue; eventually, they will be extracted out again by an EventHandler and
    processed.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self) -> None: ...
    def queue_event(self, event: Event) -> None: ...
    def clear(self) -> None: ...
    def is_queue_empty(self) -> bool: ...
    def is_queue_full(self) -> bool: ...
    def dequeue_event(self) -> Event: ...
    @staticmethod
    def get_global_event_queue() -> EventQueue: ...
    queueEvent = queue_event
    isQueueEmpty = is_queue_empty
    isQueueFull = is_queue_full
    dequeueEvent = dequeue_event
    getGlobalEventQueue = get_global_event_queue

class PointerEventList(ParamValueBase):
    """Records a set of pointer events that happened recently.  This class is
    usually used only in the data graph, to transmit the recent pointer
    presses, but it may be used anywhere a list of PointerEvents is desired.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self) -> None: ...
    def get_num_events(self) -> int: ...
    def get_in_window(self, n: int) -> bool: ...
    def get_xpos(self, n: int) -> int: ...
    def get_ypos(self, n: int) -> int: ...
    def get_dx(self, n: int) -> float: ...
    def get_dy(self, n: int) -> float: ...
    def get_sequence(self, n: int) -> int: ...
    def get_length(self, n: int) -> float: ...
    def get_direction(self, n: int) -> float: ...
    def get_rotation(self, n: int) -> float: ...
    def get_time(self, n: int) -> float: ...
    def clear(self) -> None: ...
    def pop_front(self) -> None: ...
    @overload
    def add_event(self, data: PointerData, seq: int, time: float) -> None: ...
    @overload
    def add_event(self, in_win: bool, xpos: int, ypos: int, seq: int, time: float) -> None: ...
    @overload
    def add_event(self, in_win: bool, xpos: int, ypos: int, xdelta: float, ydelta: float, seq: int, time: float) -> None: ...
    def encircles(self, x: int, y: int) -> bool: ...
    def total_turns(self, sec: float) -> float: ...
    def match_pattern(self, pattern: str, rot: float, seglen: float) -> float: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getNumEvents = get_num_events
    getInWindow = get_in_window
    getXpos = get_xpos
    getYpos = get_ypos
    getDx = get_dx
    getDy = get_dy
    getSequence = get_sequence
    getLength = get_length
    getDirection = get_direction
    getRotation = get_rotation
    getTime = get_time
    popFront = pop_front
    addEvent = add_event
    totalTurns = total_turns
    matchPattern = match_pattern
    getClassType = get_class_type

@final
class PythonTask(AsyncTask):
    """This class exists to allow association of a Python function or coroutine
    with the AsyncTaskManager.
    """
    DtoolClassDict: ClassVar[dict[str, Any]]
    delay_time: float
    delayTime: float
    __dict__: Any
    @property
    def time(self) -> float: ...
    @property
    def wake_time(self) -> float: ...
    @property
    def wakeTime(self) -> float: ...
    @property
    def frame(self) -> int: ...
    @overload
    def __init__(self, function: Callable = ..., name: str = ...) -> None: ...
    @overload
    def __init__(self, __param0: PythonTask) -> None: ...
    def set_function(self, function: Callable) -> None: ...
    def get_function(self) -> Callable: ...
    def set_args(self, args: Any, append_task: bool) -> None: ...
    def get_args(self) -> tuple[Any, ...]: ...
    def set_upon_death(self, upon_death: Callable) -> None: ...
    def get_upon_death(self) -> Callable: ...
    def set_owner(self, owner: Any) -> None: ...
    def get_owner(self) -> Any: ...
    def set_result(self, result: Any) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    setFunction = set_function
    getFunction = get_function
    setArgs = set_args
    getArgs = get_args
    setUponDeath = set_upon_death
    getUponDeath = get_upon_death
    setOwner = set_owner
    getOwner = get_owner
    setResult = set_result
    getClassType = get_class_type
