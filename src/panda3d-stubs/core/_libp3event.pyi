from collections.abc import Callable, Sequence
from typing import Any, Awaitable, ClassVar, Generator, Literal, TypeAlias, final, overload

_AsyncTask_State: TypeAlias = Literal[0, 1, 2, 3, 4, 5, 6]
_ThreadPriority: TypeAlias = Literal[0, 1, 2, 3]
_ButtonEvent_Type: TypeAlias = Literal[0, 1, 2, 3, 4, 5, 6, 7, 8]

class EventParameter:
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, value: float | str) -> None: ...
    @overload
    def __init__(self, copy: EventParameter | float | int | str | None) -> None: ...
    @overload
    def __init__(self, ptr: TypedReferenceCount | TypedWritableReferenceCount) -> None: ...
    def assign(self, copy: EventParameter | float | int | str | None) -> EventParameter: ...
    def is_empty(self) -> bool: ...
    def is_int(self) -> bool: ...
    def get_int_value(self) -> int: ...
    def is_double(self) -> bool: ...
    def get_double_value(self) -> float: ...
    def is_string(self) -> bool: ...
    def get_string_value(self) -> str: ...
    def is_wstring(self) -> bool: ...
    def get_wstring_value(self) -> str: ...
    def is_typed_ref_count(self) -> bool: ...
    def get_typed_ref_count_value(self) -> TypedReferenceCount: ...
    def get_ptr(self) -> TypedWritableReferenceCount: ...
    def output(self, out: ostream) -> None: ...
    isEmpty = is_empty
    isInt = is_int
    getIntValue = get_int_value
    isDouble = is_double
    getDoubleValue = get_double_value
    isString = is_string
    getStringValue = get_string_value
    isWstring = is_wstring
    getWstringValue = get_wstring_value
    isTypedRefCount = is_typed_ref_count
    getTypedRefCountValue = get_typed_ref_count_value
    getPtr = get_ptr

class AsyncFuture(TypedReferenceCount):
    DtoolClassDict: ClassVar[dict[str, Any]]
    done_event: str
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, __param0: AsyncFuture) -> None: ...
    @staticmethod
    def __await__() -> Generator[Awaitable, None, None]: ...
    @staticmethod
    def __iter__() -> Generator[Awaitable, None, None]: ...
    def done(self) -> bool: ...
    def cancelled(self) -> bool: ...
    def result(self, timeout: Any = ...) -> Any: ...
    def cancel(self) -> bool: ...
    def set_done_event(self, done_event: str) -> None: ...
    def get_done_event(self) -> str: ...
    def add_done_callback(self, fn: Any) -> Any: ...
    @staticmethod
    def gather(args: Any) -> Any: ...
    def output(self, out: ostream) -> None: ...
    @overload
    def wait(self) -> None: ...
    @overload
    def wait(self, timeout: float) -> None: ...
    def set_result(self, __param0: Any) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    setDoneEvent = set_done_event
    getDoneEvent = get_done_event
    addDoneCallback = add_done_callback
    setResult = set_result
    getClassType = get_class_type

class AsyncTask(AsyncFuture, Namable):
    DtoolClassDict: ClassVar[dict[str, Any]]
    name: str
    task_chain: str
    sort: int
    priority: int
    done_event: str
    DS_done: ClassVar[Literal[0]]
    DS_cont: ClassVar[Literal[1]]
    DS_again: ClassVar[Literal[2]]
    DS_pickup: ClassVar[Literal[3]]
    DS_exit: ClassVar[Literal[4]]
    DS_pause: ClassVar[Literal[5]]
    DS_interrupt: ClassVar[Literal[6]]
    DS_await: ClassVar[Literal[7]]
    S_inactive: ClassVar[Literal[0]]
    S_active: ClassVar[Literal[1]]
    S_servicing: ClassVar[Literal[2]]
    S_servicing_removed: ClassVar[Literal[3]]
    S_sleeping: ClassVar[Literal[4]]
    S_active_nested: ClassVar[Literal[5]]
    S_awaiting: ClassVar[Literal[6]]
    @property
    def state(self) -> _AsyncTask_State: ...
    @property
    def alive(self) -> bool: ...
    @property
    def manager(self) -> AsyncTaskManager: ...
    @property
    def id(self) -> int: ...
    @property
    def dt(self) -> float: ...
    @property
    def max_dt(self) -> float: ...
    @property
    def average_dt(self) -> float: ...
    def __init__(self, __param0: AsyncTask) -> None: ...
    def upcast_to_AsyncFuture(self) -> AsyncFuture: ...
    def upcast_to_Namable(self) -> Namable: ...
    def get_state(self) -> _AsyncTask_State: ...
    def is_alive(self) -> bool: ...
    def get_manager(self) -> AsyncTaskManager: ...
    def remove(self) -> bool: ...
    def set_delay(self, delay: float) -> None: ...
    def clear_delay(self) -> None: ...
    def has_delay(self) -> bool: ...
    def get_delay(self) -> float: ...
    def get_wake_time(self) -> float: ...
    def recalc_wake_time(self) -> None: ...
    def get_start_time(self) -> float: ...
    def get_elapsed_time(self) -> float: ...
    def get_start_frame(self) -> int: ...
    def get_elapsed_frames(self) -> int: ...
    def set_name(self, name: str) -> None: ...
    def clear_name(self) -> None: ...
    def get_name_prefix(self) -> str: ...
    def get_task_id(self) -> int: ...
    def set_task_chain(self, chain_name: str) -> None: ...
    def get_task_chain(self) -> str: ...
    def set_sort(self, sort: int) -> None: ...
    def get_sort(self) -> int: ...
    def set_priority(self, priority: int) -> None: ...
    def get_priority(self) -> int: ...
    def set_done_event(self, done_event: str) -> None: ...
    def get_dt(self) -> float: ...
    def get_max_dt(self) -> float: ...
    def get_average_dt(self) -> float: ...
    def output(self, out: ostream) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    upcastToAsyncFuture = upcast_to_AsyncFuture
    upcastToNamable = upcast_to_Namable
    getState = get_state
    isAlive = is_alive
    getManager = get_manager
    setDelay = set_delay
    clearDelay = clear_delay
    hasDelay = has_delay
    getDelay = get_delay
    getWakeTime = get_wake_time
    recalcWakeTime = recalc_wake_time
    getStartTime = get_start_time
    getElapsedTime = get_elapsed_time
    getStartFrame = get_start_frame
    getElapsedFrames = get_elapsed_frames
    setName = set_name
    clearName = clear_name
    getNamePrefix = get_name_prefix
    getTaskId = get_task_id
    setTaskChain = set_task_chain
    getTaskChain = get_task_chain
    setSort = set_sort
    getSort = get_sort
    setPriority = set_priority
    getPriority = get_priority
    setDoneEvent = set_done_event
    getDt = get_dt
    getMaxDt = get_max_dt
    getAverageDt = get_average_dt
    getClassType = get_class_type
    DSDone = DS_done
    DSCont = DS_cont
    DSAgain = DS_again
    DSPickup = DS_pickup
    DSExit = DS_exit
    DSPause = DS_pause
    DSInterrupt = DS_interrupt
    DSAwait = DS_await
    SInactive = S_inactive
    SActive = S_active
    SServicing = S_servicing
    SServicingRemoved = S_servicing_removed
    SSleeping = S_sleeping
    SActiveNested = S_active_nested
    SAwaiting = S_awaiting

class AsyncTaskManager(TypedReferenceCount, Namable):
    DtoolClassDict: ClassVar[dict[str, Any]]
    clock: ClockObject
    @property
    def tasks(self) -> AsyncTaskCollection: ...
    @property
    def active_tasks(self) -> AsyncTaskCollection: ...
    @property
    def sleeping_tasks(self) -> AsyncTaskCollection: ...
    @property
    def next_wake_time(self) -> float: ...
    def __init__(self, name: str) -> None: ...
    def upcast_to_TypedReferenceCount(self) -> TypedReferenceCount: ...
    def upcast_to_Namable(self) -> Namable: ...
    def cleanup(self) -> None: ...
    def set_clock(self, clock: ClockObject) -> None: ...
    def get_clock(self) -> ClockObject: ...
    def get_num_task_chains(self) -> int: ...
    def get_task_chain(self, n: int) -> AsyncTaskChain: ...
    def make_task_chain(self, name: str) -> AsyncTaskChain: ...
    def find_task_chain(self, name: str) -> AsyncTaskChain: ...
    def remove_task_chain(self, name: str) -> bool: ...
    def add(self, task: AsyncTask) -> None: ...
    def has_task(self, task: AsyncTask) -> bool: ...
    def find_task(self, name: str) -> AsyncTask: ...
    def find_tasks(self, name: str) -> AsyncTaskCollection: ...
    def find_tasks_matching(self, pattern: GlobPattern) -> AsyncTaskCollection: ...
    @overload
    def remove(self, task: AsyncTask) -> bool: ...
    @overload
    def remove(self, tasks: AsyncTaskCollection) -> int: ...
    def wait_for_tasks(self) -> None: ...
    def stop_threads(self) -> None: ...
    def start_threads(self) -> None: ...
    def get_num_tasks(self) -> int: ...
    def get_tasks(self) -> AsyncTaskCollection: ...
    def get_active_tasks(self) -> AsyncTaskCollection: ...
    def get_sleeping_tasks(self) -> AsyncTaskCollection: ...
    def poll(self) -> None: ...
    def get_next_wake_time(self) -> float: ...
    def output(self, out: ostream) -> None: ...
    def write(self, out: ostream, indent_level: int = ...) -> None: ...
    @staticmethod
    def get_global_ptr() -> AsyncTaskManager: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    def get_task_chains(self) -> tuple[AsyncTaskChain, ...]: ...
    upcastToTypedReferenceCount = upcast_to_TypedReferenceCount
    upcastToNamable = upcast_to_Namable
    setClock = set_clock
    getClock = get_clock
    getNumTaskChains = get_num_task_chains
    getTaskChain = get_task_chain
    makeTaskChain = make_task_chain
    findTaskChain = find_task_chain
    removeTaskChain = remove_task_chain
    hasTask = has_task
    findTask = find_task
    findTasks = find_tasks
    findTasksMatching = find_tasks_matching
    waitForTasks = wait_for_tasks
    stopThreads = stop_threads
    startThreads = start_threads
    getNumTasks = get_num_tasks
    getTasks = get_tasks
    getActiveTasks = get_active_tasks
    getSleepingTasks = get_sleeping_tasks
    getNextWakeTime = get_next_wake_time
    getGlobalPtr = get_global_ptr
    getClassType = get_class_type
    getTaskChains = get_task_chains

class AsyncTaskCollection:
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, copy: AsyncTaskCollection) -> None: ...
    def __getitem__(self, index: int) -> AsyncTask: ...
    def __len__(self) -> int: ...
    def __iadd__(self, other: AsyncTaskCollection) -> AsyncTaskCollection: ...
    def __add__(self, other: AsyncTaskCollection) -> AsyncTaskCollection: ...
    def assign(self, copy: AsyncTaskCollection) -> AsyncTaskCollection: ...
    def add_task(self, task: AsyncTask) -> None: ...
    @overload
    def remove_task(self, task: AsyncTask) -> bool: ...
    @overload
    def remove_task(self, index: int) -> None: ...
    def add_tasks_from(self, other: AsyncTaskCollection) -> None: ...
    def remove_tasks_from(self, other: AsyncTaskCollection) -> None: ...
    def remove_duplicate_tasks(self) -> None: ...
    def has_task(self, task: AsyncTask) -> bool: ...
    def clear(self) -> None: ...
    def find_task(self, name: str) -> AsyncTask: ...
    def get_num_tasks(self) -> int: ...
    def get_task(self, index: int) -> AsyncTask: ...
    def output(self, out: ostream) -> None: ...
    def write(self, out: ostream, indent_level: int = ...) -> None: ...
    def get_tasks(self) -> tuple[AsyncTask, ...]: ...
    addTask = add_task
    removeTask = remove_task
    addTasksFrom = add_tasks_from
    removeTasksFrom = remove_tasks_from
    removeDuplicateTasks = remove_duplicate_tasks
    hasTask = has_task
    findTask = find_task
    getNumTasks = get_num_tasks
    getTask = get_task
    getTasks = get_tasks

class AsyncTaskChain(TypedReferenceCount, Namable):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def upcast_to_TypedReferenceCount(self) -> TypedReferenceCount: ...
    def upcast_to_Namable(self) -> Namable: ...
    def set_tick_clock(self, tick_clock: bool) -> None: ...
    def get_tick_clock(self) -> bool: ...
    def set_num_threads(self, num_threads: int) -> None: ...
    def get_num_threads(self) -> int: ...
    def get_num_running_threads(self) -> int: ...
    def set_thread_priority(self, priority: _ThreadPriority) -> None: ...
    def get_thread_priority(self) -> _ThreadPriority: ...
    def set_frame_budget(self, frame_budget: float) -> None: ...
    def get_frame_budget(self) -> float: ...
    def set_frame_sync(self, frame_sync: bool) -> None: ...
    def get_frame_sync(self) -> bool: ...
    def set_timeslice_priority(self, timeslice_priority: bool) -> None: ...
    def get_timeslice_priority(self) -> bool: ...
    def stop_threads(self) -> None: ...
    def start_threads(self) -> None: ...
    def is_started(self) -> bool: ...
    def has_task(self, task: AsyncTask) -> bool: ...
    def wait_for_tasks(self) -> None: ...
    def get_num_tasks(self) -> int: ...
    def get_tasks(self) -> AsyncTaskCollection: ...
    def get_active_tasks(self) -> AsyncTaskCollection: ...
    def get_sleeping_tasks(self) -> AsyncTaskCollection: ...
    def poll(self) -> None: ...
    def get_next_wake_time(self) -> float: ...
    def output(self, out: ostream) -> None: ...
    def write(self, out: ostream, indent_level: int = ...) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    upcastToTypedReferenceCount = upcast_to_TypedReferenceCount
    upcastToNamable = upcast_to_Namable
    setTickClock = set_tick_clock
    getTickClock = get_tick_clock
    setNumThreads = set_num_threads
    getNumThreads = get_num_threads
    getNumRunningThreads = get_num_running_threads
    setThreadPriority = set_thread_priority
    getThreadPriority = get_thread_priority
    setFrameBudget = set_frame_budget
    getFrameBudget = get_frame_budget
    setFrameSync = set_frame_sync
    getFrameSync = get_frame_sync
    setTimeslicePriority = set_timeslice_priority
    getTimeslicePriority = get_timeslice_priority
    stopThreads = stop_threads
    startThreads = start_threads
    isStarted = is_started
    hasTask = has_task
    waitForTasks = wait_for_tasks
    getNumTasks = get_num_tasks
    getTasks = get_tasks
    getActiveTasks = get_active_tasks
    getSleepingTasks = get_sleeping_tasks
    getNextWakeTime = get_next_wake_time
    getClassType = get_class_type

class AsyncTaskPause(AsyncTask):
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self, __param0: AsyncTaskPause) -> None: ...
    @overload
    def __init__(self, delay: float) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getClassType = get_class_type

class AsyncTaskSequence(AsyncTask, AsyncTaskCollection):
    DtoolClassDict: ClassVar[dict[str, Any]]
    @overload
    def __init__(self, __param0: AsyncTaskSequence) -> None: ...
    @overload
    def __init__(self, name: str) -> None: ...
    def upcast_to_AsyncTask(self) -> AsyncTask: ...
    def upcast_to_AsyncTaskCollection(self) -> AsyncTaskCollection: ...
    def set_repeat_count(self, repeat_count: int) -> None: ...
    def get_repeat_count(self) -> int: ...
    def get_current_task_index(self) -> int: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    upcastToAsyncTask = upcast_to_AsyncTask
    upcastToAsyncTaskCollection = upcast_to_AsyncTaskCollection
    setRepeatCount = set_repeat_count
    getRepeatCount = get_repeat_count
    getCurrentTaskIndex = get_current_task_index
    getClassType = get_class_type

class ButtonEvent:
    DtoolClassDict: ClassVar[dict[str, Any]]
    T_down: ClassVar[Literal[0]]
    T_resume_down: ClassVar[Literal[1]]
    T_up: ClassVar[Literal[2]]
    T_repeat: ClassVar[Literal[3]]
    T_keystroke: ClassVar[Literal[4]]
    T_candidate: ClassVar[Literal[5]]
    T_move: ClassVar[Literal[6]]
    T_raw_down: ClassVar[Literal[7]]
    T_raw_up: ClassVar[Literal[8]]
    @property
    def button(self) -> ButtonHandle: ...
    @property
    def keycode(self) -> int: ...
    @property
    def type(self) -> _ButtonEvent_Type: ...
    @property
    def time(self) -> float: ...
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...
    def __lt__(self, other: ButtonEvent) -> bool: ...
    def __le__(self, other: ButtonEvent) -> bool: ...
    TDown = T_down
    TResumeDown = T_resume_down
    TUp = T_up
    TRepeat = T_repeat
    TKeystroke = T_keystroke
    TCandidate = T_candidate
    TMove = T_move
    TRawDown = T_raw_down
    TRawUp = T_raw_up

class ButtonEventList(ParamValueBase):
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def events(self) -> Sequence[ButtonEvent]: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, copy: ButtonEventList) -> None: ...
    def assign(self, copy: ButtonEventList) -> ButtonEventList: ...
    def add_event(self, event: ButtonEvent) -> None: ...
    def get_num_events(self) -> int: ...
    def get_event(self, n: int) -> ButtonEvent: ...
    def clear(self) -> None: ...
    def add_events(self, other: ButtonEventList) -> None: ...
    def update_mods(self, mods: ModifierButtons) -> None: ...
    def write(self, out: ostream, indent_level: int = ...) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    addEvent = add_event
    getNumEvents = get_num_events
    getEvent = get_event
    addEvents = add_events
    updateMods = update_mods
    getClassType = get_class_type

class Event(TypedReferenceCount):
    DtoolClassDict: ClassVar[dict[str, Any]]
    name: str
    @property
    def parameters(self) -> Sequence[EventParameter]: ...
    def __init__(self, copy: Event) -> None: ...
    def assign(self, copy: Event) -> Event: ...
    def set_name(self, name: str) -> None: ...
    def clear_name(self) -> None: ...
    def has_name(self) -> bool: ...
    def get_name(self) -> str: ...
    def add_parameter(self, obj: EventParameter | float | int | str | None) -> None: ...
    def get_num_parameters(self) -> int: ...
    def get_parameter(self, n: int) -> EventParameter: ...
    def has_receiver(self) -> bool: ...
    def clear_receiver(self) -> None: ...
    def output(self, out: ostream) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    def get_parameters(self) -> tuple[EventParameter, ...]: ...
    setName = set_name
    clearName = clear_name
    hasName = has_name
    getName = get_name
    addParameter = add_parameter
    getNumParameters = get_num_parameters
    getParameter = get_parameter
    hasReceiver = has_receiver
    clearReceiver = clear_receiver
    getClassType = get_class_type
    getParameters = get_parameters

class EventHandler(TypedObject):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self, ev_queue: EventQueue) -> None: ...
    def get_future(self, event_name: str) -> AsyncFuture: ...
    def process_events(self) -> None: ...
    def dispatch_event(self, event: Event) -> None: ...
    def write(self, out: ostream) -> None: ...
    @staticmethod
    def get_global_event_handler(queue: EventQueue = ...) -> EventHandler: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getFuture = get_future
    processEvents = process_events
    dispatchEvent = dispatch_event
    getGlobalEventHandler = get_global_event_handler
    getClassType = get_class_type

class EventQueue:
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self) -> None: ...
    def queue_event(self, event: Event) -> None: ...
    def clear(self) -> None: ...
    def is_queue_empty(self) -> bool: ...
    def is_queue_full(self) -> bool: ...
    def dequeue_event(self) -> Event: ...
    @staticmethod
    def get_global_event_queue() -> EventQueue: ...
    queueEvent = queue_event
    isQueueEmpty = is_queue_empty
    isQueueFull = is_queue_full
    dequeueEvent = dequeue_event
    getGlobalEventQueue = get_global_event_queue

class PointerEventList(ParamValueBase):
    DtoolClassDict: ClassVar[dict[str, Any]]
    def __init__(self) -> None: ...
    def get_num_events(self) -> int: ...
    def get_in_window(self, n: int) -> bool: ...
    def get_xpos(self, n: int) -> int: ...
    def get_ypos(self, n: int) -> int: ...
    def get_dx(self, n: int) -> float: ...
    def get_dy(self, n: int) -> float: ...
    def get_sequence(self, n: int) -> int: ...
    def get_length(self, n: int) -> float: ...
    def get_direction(self, n: int) -> float: ...
    def get_rotation(self, n: int) -> float: ...
    def get_time(self, n: int) -> float: ...
    def clear(self) -> None: ...
    def pop_front(self) -> None: ...
    @overload
    def add_event(self, data: PointerData, seq: int, time: float) -> None: ...
    @overload
    def add_event(self, in_win: bool, xpos: int, ypos: int, seq: int, time: float) -> None: ...
    @overload
    def add_event(self, in_win: bool, xpos: int, ypos: int, xdelta: float, ydelta: float, seq: int, time: float) -> None: ...
    def encircles(self, x: int, y: int) -> bool: ...
    def total_turns(self, sec: float) -> float: ...
    def match_pattern(self, pattern: str, rot: float, seglen: float) -> float: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getNumEvents = get_num_events
    getInWindow = get_in_window
    getXpos = get_xpos
    getYpos = get_ypos
    getDx = get_dx
    getDy = get_dy
    getSequence = get_sequence
    getLength = get_length
    getDirection = get_direction
    getRotation = get_rotation
    getTime = get_time
    popFront = pop_front
    addEvent = add_event
    totalTurns = total_turns
    matchPattern = match_pattern
    getClassType = get_class_type

@final
class PythonTask(AsyncTask):
    DtoolClassDict: ClassVar[dict[str, Any]]
    delay_time: float
    delayTime: float
    __dict__: Any
    @property
    def time(self) -> float: ...
    @property
    def wake_time(self) -> float: ...
    @property
    def wakeTime(self) -> float: ...
    @property
    def frame(self) -> int: ...
    @overload
    def __init__(self, function: Callable = ..., name: str = ...) -> None: ...
    @overload
    def __init__(self, __param0: PythonTask) -> None: ...
    def set_function(self, function: Callable) -> None: ...
    def get_function(self) -> Callable: ...
    def set_args(self, args: Any, append_task: bool) -> None: ...
    def get_args(self) -> tuple[Any, ...]: ...
    def set_upon_death(self, upon_death: Callable) -> None: ...
    def get_upon_death(self) -> Callable: ...
    def set_owner(self, owner: Any) -> None: ...
    def get_owner(self) -> Any: ...
    def set_result(self, result: Any) -> None: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    setFunction = set_function
    getFunction = get_function
    setArgs = set_args
    getArgs = get_args
    setUponDeath = set_upon_death
    getUponDeath = get_upon_death
    setOwner = set_owner
    getOwner = get_owner
    setResult = set_result
    getClassType = get_class_type
