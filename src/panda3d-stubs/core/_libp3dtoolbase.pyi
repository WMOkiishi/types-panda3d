from collections.abc import Sequence
from typing import Any, ClassVar, Literal, TypeAlias, final, overload
from panda3d.core import ostream

_TypeHandle_MemoryClass: TypeAlias = Literal[0, 1, 2, 3, 4]

class NeverFreeMemory:
    DtoolClassDict: ClassVar[dict[str, Any]]
    @staticmethod
    def get_total_alloc() -> int: ...
    @staticmethod
    def get_total_used() -> int: ...
    @staticmethod
    def get_total_unused() -> int: ...
    getTotalAlloc = get_total_alloc
    getTotalUsed = get_total_used
    getTotalUnused = get_total_unused

@final
class TypeHandle:
    DtoolClassDict: ClassVar[dict[str, Any]]
    MC_singleton: ClassVar[Literal[0]]
    MC_array: ClassVar[Literal[1]]
    MC_deleted_chain_active: ClassVar[Literal[2]]
    MC_deleted_chain_inactive: ClassVar[Literal[3]]
    MC_limit: ClassVar[Literal[4]]
    @property
    def index(self) -> int: ...
    @property
    def name(self) -> str: ...
    @property
    def parent_classes(self) -> Sequence[TypeHandle]: ...
    @property
    def child_classes(self) -> Sequence[TypeHandle]: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, __param0: TypeHandle) -> None: ...
    def __bool__(self) -> bool: ...
    def __eq__(self, __other: object) -> bool: ...
    def __ne__(self, __other: object) -> bool: ...
    def __lt__(self, other: TypeHandle) -> bool: ...
    def __le__(self, other: TypeHandle) -> bool: ...
    def __gt__(self, other: TypeHandle) -> bool: ...
    def __ge__(self, other: TypeHandle) -> bool: ...
    @staticmethod
    def make(classobj: type) -> TypeHandle: ...
    def compare_to(self, other: TypeHandle) -> int: ...
    def get_hash(self) -> int: ...
    def get_name(self, object: TypedObject = ...) -> str: ...
    def is_derived_from(self, parent: TypeHandle, object: TypedObject = ...) -> bool: ...
    def get_num_parent_classes(self, object: TypedObject = ...) -> int: ...
    def get_parent_class(self, index: int) -> TypeHandle: ...
    def get_num_child_classes(self, object: TypedObject = ...) -> int: ...
    def get_child_class(self, index: int) -> TypeHandle: ...
    def get_parent_towards(self, ancestor: TypeHandle, object: TypedObject = ...) -> TypeHandle: ...
    def get_memory_usage(self, memory_class: _TypeHandle_MemoryClass) -> int: ...
    def inc_memory_usage(self, memory_class: _TypeHandle_MemoryClass, size: int) -> None: ...
    def dec_memory_usage(self, memory_class: _TypeHandle_MemoryClass, size: int) -> None: ...
    def get_index(self) -> int: ...
    def output(self, out: ostream) -> None: ...
    @staticmethod
    def none() -> TypeHandle: ...
    compareTo = compare_to
    getHash = get_hash
    getName = get_name
    isDerivedFrom = is_derived_from
    getNumParentClasses = get_num_parent_classes
    getParentClass = get_parent_class
    getNumChildClasses = get_num_child_classes
    getChildClass = get_child_class
    getParentTowards = get_parent_towards
    getMemoryUsage = get_memory_usage
    incMemoryUsage = inc_memory_usage
    decMemoryUsage = dec_memory_usage
    getIndex = get_index
    MCSingleton = MC_singleton
    MCArray = MC_array
    MCDeletedChainActive = MC_deleted_chain_active
    MCDeletedChainInactive = MC_deleted_chain_inactive
    MCLimit = MC_limit

class TypeRegistry:
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def typehandles(self) -> Sequence[TypeHandle]: ...
    @property
    def root_classes(self) -> Sequence[TypeHandle]: ...
    def __init__(self, __param0: TypeRegistry) -> None: ...
    def register_dynamic_type(self, name: str) -> TypeHandle: ...
    def record_derivation(self, child: TypeHandle, parent: TypeHandle) -> None: ...
    def record_alternate_name(self, type: TypeHandle, name: str) -> None: ...
    def record_python_type(self, type: TypeHandle, python_type: Any) -> None: ...
    def find_type(self, name: str) -> TypeHandle: ...
    def find_type_by_id(self, id: int) -> TypeHandle: ...
    def get_name(self, type: TypeHandle, object: TypedObject) -> str: ...
    def is_derived_from(self, child: TypeHandle, base: TypeHandle, child_object: TypedObject) -> bool: ...
    def get_num_typehandles(self) -> int: ...
    def get_typehandle(self, n: int) -> TypeHandle: ...
    def get_num_root_classes(self) -> int: ...
    def get_root_class(self, n: int) -> TypeHandle: ...
    def get_num_parent_classes(self, child: TypeHandle, child_object: TypedObject) -> int: ...
    def get_parent_class(self, child: TypeHandle, index: int) -> TypeHandle: ...
    def get_num_child_classes(self, child: TypeHandle, child_object: TypedObject) -> int: ...
    def get_child_class(self, child: TypeHandle, index: int) -> TypeHandle: ...
    def get_parent_towards(self, child: TypeHandle, base: TypeHandle, child_object: TypedObject) -> TypeHandle: ...
    @staticmethod
    def reregister_types() -> None: ...
    def write(self, out: ostream) -> None: ...
    @staticmethod
    def ptr() -> TypeRegistry: ...
    def get_typehandles(self) -> tuple[TypeHandle, ...]: ...
    def get_root_classes(self) -> tuple[TypeHandle, ...]: ...
    registerDynamicType = register_dynamic_type
    recordDerivation = record_derivation
    recordAlternateName = record_alternate_name
    recordPythonType = record_python_type
    findType = find_type
    findTypeById = find_type_by_id
    getName = get_name
    isDerivedFrom = is_derived_from
    getNumTypehandles = get_num_typehandles
    getTypehandle = get_typehandle
    getNumRootClasses = get_num_root_classes
    getRootClass = get_root_class
    getNumParentClasses = get_num_parent_classes
    getParentClass = get_parent_class
    getNumChildClasses = get_num_child_classes
    getChildClass = get_child_class
    getParentTowards = get_parent_towards
    reregisterTypes = reregister_types
    getTypehandles = get_typehandles
    getRootClasses = get_root_classes

class TypedObject:
    DtoolClassDict: ClassVar[dict[str, Any]]
    @property
    def type(self) -> TypeHandle: ...
    def get_type(self) -> TypeHandle: ...
    def get_type_index(self) -> int: ...
    def is_of_type(self, handle: TypeHandle) -> bool: ...
    def is_exact_type(self, handle: TypeHandle) -> bool: ...
    @staticmethod
    def get_class_type() -> TypeHandle: ...
    getType = get_type
    getTypeIndex = get_type_index
    isOfType = is_of_type
    isExactType = is_exact_type
    getClassType = get_class_type
