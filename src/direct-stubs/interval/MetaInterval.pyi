__all__ = ['MetaInterval', 'Parallel', 'ParallelEndTogether', 'Sequence', 'Track']

from collections.abc import Iterable, Iterator
from typing import ClassVar, Generic, TypeVar
from typing_extensions import Final, Literal, Self, SupportsIndex, TypeAlias, TypeGuard

from direct.directnotify.Notifier import Notifier
from panda3d.core import PStatCollector, ostream
from panda3d.direct import CInterval, CMetaInterval

from .Interval import Interval

_T = TypeVar('_T')
_Interval: TypeAlias = Interval | CInterval
_RelativeStart: TypeAlias = Literal[0, 1, 2]

PREVIOUS_END: Final = 0
PREVIOUS_START: Final = 1
TRACK_START: Final = 2

class _MetaIntervalBase(CMetaInterval):
    notify: ClassVar[Notifier]
    SequenceNum: ClassVar[int]
    phonyDuration: int
    pstats: PStatCollector | None
    pythonIvals: list[_Interval]
    inPython: bool
    def add_sequence(
        self, list: Iterable[_Interval], name: str, relTime: float, relTo: _RelativeStart, duration: float
    ) -> None: ...
    def add_parallel(
        self, list: Iterable[_Interval], name: str, relTime: float, relTo: _RelativeStart, duration: float
    ) -> None: ...
    def add_parallel_end_together(
        self, list: Iterable[_Interval], name: str, relTime: float, relTo: _RelativeStart, duration: float
    ) -> None: ...
    def add_track(
        self,
        trackList: Iterable[tuple[float, _Interval] | tuple[float, _Interval, _RelativeStart]],
        name: str,
        relTime: float,
        relTo: _RelativeStart,
        duration: float,
    ) -> None: ...
    def add_interval(self, ival: _Interval, relTime: float, relTo: _RelativeStart) -> None: ...
    def start(  # pyright: ignore[reportIncompatibleMethodOverride]
        self, startT: float = 0.0, endT: float = -1.0, playRate: float = 1.0
    ) -> None: ...
    def loop(  # pyright: ignore[reportIncompatibleMethodOverride]
        self, startT: float = 0.0, endT: float = -1.0, playRate: float = 1.0
    ) -> None: ...
    def resume(self, startT: float | None = None) -> None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    def resume_until(self, endT: float) -> None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    def applyIvals(self, meta: _MetaIntervalBase, relTime: float, relTo: _RelativeStart) -> None: ...
    def set_play_rate(self, playRate: float) -> None: ...  # pyright: ignore[reportIncompatibleMethodOverride]
    def priv_post_event(self) -> None: ...
    @property
    def duration(self) -> float: ...
    def timeline(self, out: ostream | None = None) -> None: ...
    addSequence = add_sequence
    addParallel = add_parallel
    addParallelEndTogether = add_parallel_end_together
    addTrack = add_track
    addInterval = add_interval
    resumeUntil = resume_until  # type: ignore[assignment]
    setPlayRate = set_play_rate  # type: ignore[assignment]
    privPostEvent = priv_post_event

class _GenericIntervalSequence(Generic[_T]):
    ivals: tuple[_T, ...] | list[_T]
    def __init__(
        self, *ivals: _T, name: str | None = None, autoPause: bool = False, autoFinish: bool = False, duration: float = -1
    ) -> None: ...
    def append(self, ival: _T) -> None: ...
    def extend(self, ivals: Iterable[_T]) -> None: ...
    def index(self, ival: _T) -> int: ...
    def count(self, ival: _T) -> int: ...
    def insert(self, index: SupportsIndex, ival: _T) -> None: ...
    def pop(self, index: SupportsIndex | None = None) -> _T: ...
    def remove(self, ival: _T) -> None: ...
    def reverse(self) -> None: ...
    def sort(self, cmpfunc: None = None) -> None: ...
    def __len__(self) -> int: ...
    def __getitem__(self, index: SupportsIndex) -> _T: ...
    def __setitem__(self, index: SupportsIndex, value: _T) -> None: ...
    def __delitem__(self, index: SupportsIndex) -> None: ...
    def __getslice__(self, i: SupportsIndex, j: SupportsIndex) -> Self: ...
    def __setslice__(self, i: SupportsIndex, j: SupportsIndex, s: Iterable[_T]) -> None: ...
    def __delslice__(self, i: SupportsIndex, j: SupportsIndex) -> None: ...
    def __iadd__(self, other: Iterable[_T]) -> Self: ...
    def __add__(self, other: Iterable[_T]) -> Self: ...
    def __iter__(self) -> Iterator[_T]: ...  # Doesn't actually exist
    def validateComponent(self, component: object) -> TypeGuard[_T]: ...
    def validateComponents(self, components: Iterable[object]) -> TypeGuard[Iterable[_T]]: ...

class MetaInterval(_MetaIntervalBase, _GenericIntervalSequence[_Interval]): ...
class Sequence(MetaInterval): ...
class Parallel(MetaInterval): ...
class ParallelEndTogether(MetaInterval): ...

class Track(_MetaIntervalBase, _GenericIntervalSequence[tuple[float, _Interval]]):
    def validateComponent(  # pyright: ignore[reportIncompatibleMethodOverride]
        self, tupleObj: object
    ) -> TypeGuard[tuple[float, _Interval]]: ...
