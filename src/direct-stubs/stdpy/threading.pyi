__all__ = [
    'BoundedSemaphore',
    'Condition',
    'Event',
    'Lock',
    'RLock',
    'Semaphore',
    'TIMEOUT_MAX',
    'Thread',
    'ThreadError',
    'Timer',
    'active_count',
    'current_thread',
    'enumerate',
    'local',
    'main_thread',
    'setprofile',
    'settrace',
    'stack_size',
]

from collections.abc import Callable, Iterable, Mapping
from typing import Any, NoReturn
from typing_extensions import Final

from panda3d import core
from .thread import error as ThreadError

TIMEOUT_MAX: Final[float]

class local:
    def __del__(self) -> None: ...
    def __setattr__(self, key: str, value: Any) -> None: ...
    def __getattr__(self, key: str) -> None: ...

class ThreadBase:
    name: str
    daemon: bool
    ident: NoReturn
    def __init__(self) -> None: ...
    def getName(self) -> str: ...
    def isDaemon(self) -> bool: ...
    def setDaemon(self, daemon: bool) -> None: ...
    def __setattr__(self, key: str, value: Any) -> None: ...
    forceYield = core.Thread.forceYield
    considerYield = core.Thread.considerYield

class Thread(ThreadBase):
    def __init__(
        self,
        group: None = None,
        target: Callable[..., object] | None = None,
        name: str | None = None,
        args: Iterable[Any] = (),
        kwargs: Mapping[str, Any] = ...,
        daemon: bool | None = None,
    ) -> None: ...
    def __del__(self) -> None: ...
    def is_alive(self) -> bool: ...
    isAlive = is_alive
    def start(self) -> None: ...
    def run(self) -> None: ...
    def join(self, timeout=None) -> None: ...
    def setName(self, name) -> None: ...

class ExternalThread(ThreadBase):
    daemon: bool
    name = ...
    ident = ...
    def __init__(self, extThread, threadId) -> None: ...
    def is_alive(self) -> bool: ...
    def isAlive(self) -> bool: ...
    def start(self) -> NoReturn: ...
    def run(self) -> NoReturn: ...
    def join(self, timeout: object = None) -> NoReturn: ...
    def setDaemon(self, daemon: object) -> NoReturn: ...

class MainThread(ExternalThread):
    def __init__(self, extThread, threadId) -> None: ...

class Lock(core.Mutex):
    def __init__(self, name: str = 'PythonLock') -> None: ...
    def __enter__(self, blocking: bool = True) -> bool: ...
    def __exit__(self, t: object, v: object, tb: object) -> None: ...
    acquire = __enter__

class RLock(core.ReMutex):
    def __init__(self, name: str = 'PythonRLock') -> None: ...
    def __enter__(self, blocking: bool = True) -> bool: ...
    def __exit__(self, t: object, v: object, tb: object) -> None: ...
    acquire = __enter__

class Condition(core.ConditionVarFull):
    def __init__(self, lock: Lock | None = None) -> None: ...
    def acquire(self, blocking: bool = True) -> bool: ...
    def release(self) -> None: ...
    def wait(self, timeout: float | None = None) -> None: ...
    def __enter__(self, blocking: bool = True) -> bool: ...
    def __exit__(self, t: object, v: object, tb: object) -> None: ...

class Semaphore(core.Semaphore):
    def __init__(self, value: int = 1) -> None: ...
    def __enter__(self, blocking: bool = True) -> bool: ...
    def __exit__(self, t: object, v: object, tb: object) -> None: ...
    acquire = __enter__

class BoundedSemaphore(Semaphore): ...

class Event:
    def __init__(self) -> None: ...
    def is_set(self) -> bool: ...
    isSet = is_set
    def set(self) -> None: ...
    def clear(self) -> None: ...
    def wait(self, timeout: float | None) -> None: ...

class Timer(Thread):
    interval: float
    function: Callable[..., object]
    args: Iterable[Any]
    kwargs: Mapping[str, Any]
    finished: Event
    def __init__(
        self,
        interval: float,
        function: Callable[..., object],
        args: Iterable[Any] = ...,
        kwargs: Mapping[str, Any] = ...,
    ) -> None: ...
    def cancel(self) -> None: ...

def current_thread(): ...
def main_thread(): ...
currentThread = current_thread
def enumerate(): ...
def active_count() -> int: ...
activeCount = active_count
def settrace(func): ...
def setprofile(func): ...
def stack_size(size: object = None) -> NoReturn: ...
